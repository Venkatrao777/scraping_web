{"version":3,"file":"1491.e7f91e7e377564f2340d.js?v=e7f91e7e377564f2340d","mappings":"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","sources":["webpack://@jupyterlab/application-top/./node_modules/@lumino/datagrid/dist/index.es6.js"],"sourcesContent":["import { Platform, ClipboardExt, ElementExt } from '@lumino/domutils';\nimport { getKeyboardLayout } from '@lumino/keyboard';\nimport { Drag } from '@lumino/dragdrop';\nimport { some, ArrayExt } from '@lumino/algorithm';\nimport { Signal } from '@lumino/signaling';\nimport { Widget, ScrollBar, GridLayout } from '@lumino/widgets';\nimport { ConflatableMessage, MessageLoop } from '@lumino/messaging';\nimport { PromiseDelegate } from '@lumino/coreutils';\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * A basic implementation of a data grid key handler.\n *\n * #### Notes\n * This class may be subclassed and customized as needed.\n */\nclass BasicKeyHandler {\n    constructor() {\n        this._disposed = false;\n    }\n    /**\n     * Whether the key handler is disposed.\n     */\n    get isDisposed() {\n        return this._disposed;\n    }\n    /**\n     * Dispose of the resources held by the key handler.\n     */\n    dispose() {\n        this._disposed = true;\n    }\n    /**\n     * Handle the key down event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The keydown event of interest.\n     *\n     * #### Notes\n     * This will not be called if the mouse button is pressed.\n     */\n    onKeyDown(grid, event) {\n        // if grid is editable and cell selection available, start cell editing\n        // on key press (letters, numbers and space only)\n        if (grid.editable &&\n            grid.selectionModel.cursorRow !== -1 &&\n            grid.selectionModel.cursorColumn !== -1) {\n            const input = String.fromCharCode(event.keyCode);\n            if (/[a-zA-Z0-9-_ ]/.test(input)) {\n                const row = grid.selectionModel.cursorRow;\n                const column = grid.selectionModel.cursorColumn;\n                const cell = {\n                    grid: grid,\n                    row: row,\n                    column: column\n                };\n                grid.editorController.edit(cell);\n                if (getKeyboardLayout().keyForKeydownEvent(event) === 'Space') {\n                    event.stopPropagation();\n                    event.preventDefault();\n                }\n                return;\n            }\n        }\n        switch (getKeyboardLayout().keyForKeydownEvent(event)) {\n            case 'ArrowLeft':\n                this.onArrowLeft(grid, event);\n                break;\n            case 'ArrowRight':\n                this.onArrowRight(grid, event);\n                break;\n            case 'ArrowUp':\n                this.onArrowUp(grid, event);\n                break;\n            case 'ArrowDown':\n                this.onArrowDown(grid, event);\n                break;\n            case 'PageUp':\n                this.onPageUp(grid, event);\n                break;\n            case 'PageDown':\n                this.onPageDown(grid, event);\n                break;\n            case 'Escape':\n                this.onEscape(grid, event);\n                break;\n            case 'Delete':\n                this.onDelete(grid, event);\n                break;\n            case 'C':\n                this.onKeyC(grid, event);\n                break;\n            case 'Enter':\n                if (grid.selectionModel) {\n                    grid.moveCursor(event.shiftKey ? 'up' : 'down');\n                    grid.scrollToCursor();\n                }\n                break;\n            case 'Tab':\n                if (grid.selectionModel) {\n                    grid.moveCursor(event.shiftKey ? 'left' : 'right');\n                    grid.scrollToCursor();\n                    event.stopPropagation();\n                    event.preventDefault();\n                }\n                break;\n        }\n    }\n    /**\n     * Handle the `'ArrowLeft'` key press for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The keyboard event of interest.\n     */\n    onArrowLeft(grid, event) {\n        // Stop the event propagation.\n        event.preventDefault();\n        event.stopPropagation();\n        // Fetch the selection model.\n        let model = grid.selectionModel;\n        // Fetch the modifier flags.\n        let shift = event.shiftKey;\n        let accel = Platform.accelKey(event);\n        // Handle no model with the accel modifier.\n        if (!model && accel) {\n            grid.scrollTo(0, grid.scrollY);\n            return;\n        }\n        // Handle no model and no modifier. (ignore shift)\n        if (!model) {\n            grid.scrollByStep('left');\n            return;\n        }\n        // Fetch the selection mode.\n        let mode = model.selectionMode;\n        // Handle the row selection mode with accel key.\n        if (mode === 'row' && accel) {\n            grid.scrollTo(0, grid.scrollY);\n            return;\n        }\n        // Handle the row selection mode with no modifier. (ignore shift)\n        if (mode === 'row') {\n            grid.scrollByStep('left');\n            return;\n        }\n        // Fetch the cursor and selection.\n        let r = model.cursorRow;\n        let c = model.cursorColumn;\n        let cs = model.currentSelection();\n        // Set up the selection variables.\n        let r1;\n        let r2;\n        let c1;\n        let c2;\n        let cr;\n        let cc;\n        let clear;\n        // Dispatch based on the modifier keys.\n        if (accel && shift) {\n            r1 = cs ? cs.r1 : 0;\n            r2 = cs ? cs.r2 : 0;\n            c1 = cs ? cs.c1 : 0;\n            c2 = 0;\n            cr = r;\n            cc = c;\n            clear = 'current';\n        }\n        else if (shift) {\n            r1 = cs ? cs.r1 : 0;\n            r2 = cs ? cs.r2 : 0;\n            c1 = cs ? cs.c1 : 0;\n            c2 = cs ? cs.c2 - 1 : 0;\n            cr = r;\n            cc = c;\n            clear = 'current';\n        }\n        else if (accel) {\n            r1 = r;\n            r2 = r;\n            c1 = 0;\n            c2 = 0;\n            cr = r1;\n            cc = c1;\n            clear = 'all';\n        }\n        else {\n            r1 = r;\n            r2 = r;\n            c1 = c - 1;\n            c2 = c - 1;\n            cr = r1;\n            cc = c1;\n            clear = 'all';\n        }\n        // Create the new selection.\n        model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });\n        // Re-fetch the current selection.\n        cs = model.currentSelection();\n        // Bail if there is no selection.\n        if (!cs) {\n            return;\n        }\n        // Scroll the grid appropriately.\n        if (shift || mode === 'column') {\n            grid.scrollToColumn(cs.c2);\n        }\n        else {\n            grid.scrollToCursor();\n        }\n    }\n    /**\n     * Handle the `'ArrowRight'` key press for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The keyboard event of interest.\n     */\n    onArrowRight(grid, event) {\n        // Stop the event propagation.\n        event.preventDefault();\n        event.stopPropagation();\n        // Fetch the selection model.\n        let model = grid.selectionModel;\n        // Fetch the modifier flags.\n        let shift = event.shiftKey;\n        let accel = Platform.accelKey(event);\n        // Handle no model with the accel modifier.\n        if (!model && accel) {\n            grid.scrollTo(grid.maxScrollX, grid.scrollY);\n            return;\n        }\n        // Handle no model and no modifier. (ignore shift)\n        if (!model) {\n            grid.scrollByStep('right');\n            return;\n        }\n        // Fetch the selection mode.\n        let mode = model.selectionMode;\n        // Handle the row selection model with accel key.\n        if (mode === 'row' && accel) {\n            grid.scrollTo(grid.maxScrollX, grid.scrollY);\n            return;\n        }\n        // Handle the row selection mode with no modifier. (ignore shift)\n        if (mode === 'row') {\n            grid.scrollByStep('right');\n            return;\n        }\n        // Fetch the cursor and selection.\n        let r = model.cursorRow;\n        let c = model.cursorColumn;\n        let cs = model.currentSelection();\n        // Set up the selection variables.\n        let r1;\n        let r2;\n        let c1;\n        let c2;\n        let cr;\n        let cc;\n        let clear;\n        // Dispatch based on the modifier keys.\n        if (accel && shift) {\n            r1 = cs ? cs.r1 : 0;\n            r2 = cs ? cs.r2 : 0;\n            c1 = cs ? cs.c1 : 0;\n            c2 = Infinity;\n            cr = r;\n            cc = c;\n            clear = 'current';\n        }\n        else if (shift) {\n            r1 = cs ? cs.r1 : 0;\n            r2 = cs ? cs.r2 : 0;\n            c1 = cs ? cs.c1 : 0;\n            c2 = cs ? cs.c2 + 1 : 0;\n            cr = r;\n            cc = c;\n            clear = 'current';\n        }\n        else if (accel) {\n            r1 = r;\n            r2 = r;\n            c1 = Infinity;\n            c2 = Infinity;\n            cr = r1;\n            cc = c1;\n            clear = 'all';\n        }\n        else {\n            r1 = r;\n            r2 = r;\n            c1 = c + 1;\n            c2 = c + 1;\n            cr = r1;\n            cc = c1;\n            clear = 'all';\n        }\n        // Create the new selection.\n        model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });\n        // Re-fetch the current selection.\n        cs = model.currentSelection();\n        // Bail if there is no selection.\n        if (!cs) {\n            return;\n        }\n        // Scroll the grid appropriately.\n        if (shift || mode === 'column') {\n            grid.scrollToColumn(cs.c2);\n        }\n        else {\n            grid.scrollToCursor();\n        }\n    }\n    /**\n     * Handle the `'ArrowUp'` key press for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The keyboard event of interest.\n     */\n    onArrowUp(grid, event) {\n        // Stop the event propagation.\n        event.preventDefault();\n        event.stopPropagation();\n        // Fetch the selection model.\n        let model = grid.selectionModel;\n        // Fetch the modifier flags.\n        let shift = event.shiftKey;\n        let accel = Platform.accelKey(event);\n        // Handle no model with the accel modifier.\n        if (!model && accel) {\n            grid.scrollTo(grid.scrollX, 0);\n            return;\n        }\n        // Handle no model and no modifier. (ignore shift)\n        if (!model) {\n            grid.scrollByStep('up');\n            return;\n        }\n        // Fetch the selection mode.\n        let mode = model.selectionMode;\n        // Handle the column selection mode with accel key.\n        if (mode === 'column' && accel) {\n            grid.scrollTo(grid.scrollX, 0);\n            return;\n        }\n        // Handle the column selection mode with no modifier. (ignore shift)\n        if (mode === 'column') {\n            grid.scrollByStep('up');\n            return;\n        }\n        // Fetch the cursor and selection.\n        let r = model.cursorRow;\n        let c = model.cursorColumn;\n        let cs = model.currentSelection();\n        // Set up the selection variables.\n        let r1;\n        let r2;\n        let c1;\n        let c2;\n        let cr;\n        let cc;\n        let clear;\n        // Dispatch based on the modifier keys.\n        if (accel && shift) {\n            r1 = cs ? cs.r1 : 0;\n            r2 = 0;\n            c1 = cs ? cs.c1 : 0;\n            c2 = cs ? cs.c2 : 0;\n            cr = r;\n            cc = c;\n            clear = 'current';\n        }\n        else if (shift) {\n            r1 = cs ? cs.r1 : 0;\n            r2 = cs ? cs.r2 - 1 : 0;\n            c1 = cs ? cs.c1 : 0;\n            c2 = cs ? cs.c2 : 0;\n            cr = r;\n            cc = c;\n            clear = 'current';\n        }\n        else if (accel) {\n            r1 = 0;\n            r2 = 0;\n            c1 = c;\n            c2 = c;\n            cr = r1;\n            cc = c1;\n            clear = 'all';\n        }\n        else {\n            r1 = r - 1;\n            r2 = r - 1;\n            c1 = c;\n            c2 = c;\n            cr = r1;\n            cc = c1;\n            clear = 'all';\n        }\n        // Create the new selection.\n        model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });\n        // Re-fetch the current selection.\n        cs = model.currentSelection();\n        // Bail if there is no selection.\n        if (!cs) {\n            return;\n        }\n        // Scroll the grid appropriately.\n        if (shift || mode === 'row') {\n            grid.scrollToRow(cs.r2);\n        }\n        else {\n            grid.scrollToCursor();\n        }\n    }\n    /**\n     * Handle the `'ArrowDown'` key press for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The keyboard event of interest.\n     */\n    onArrowDown(grid, event) {\n        // Stop the event propagation.\n        event.preventDefault();\n        event.stopPropagation();\n        // Fetch the selection model.\n        let model = grid.selectionModel;\n        // Fetch the modifier flags.\n        let shift = event.shiftKey;\n        let accel = Platform.accelKey(event);\n        // Handle no model with the accel modifier.\n        if (!model && accel) {\n            grid.scrollTo(grid.scrollX, grid.maxScrollY);\n            return;\n        }\n        // Handle no model and no modifier. (ignore shift)\n        if (!model) {\n            grid.scrollByStep('down');\n            return;\n        }\n        // Fetch the selection mode.\n        let mode = model.selectionMode;\n        // Handle the column selection mode with accel key.\n        if (mode === 'column' && accel) {\n            grid.scrollTo(grid.scrollX, grid.maxScrollY);\n            return;\n        }\n        // Handle the column selection mode with no modifier. (ignore shift)\n        if (mode === 'column') {\n            grid.scrollByStep('down');\n            return;\n        }\n        // Fetch the cursor and selection.\n        let r = model.cursorRow;\n        let c = model.cursorColumn;\n        let cs = model.currentSelection();\n        // Set up the selection variables.\n        let r1;\n        let r2;\n        let c1;\n        let c2;\n        let cr;\n        let cc;\n        let clear;\n        // Dispatch based on the modifier keys.\n        if (accel && shift) {\n            r1 = cs ? cs.r1 : 0;\n            r2 = Infinity;\n            c1 = cs ? cs.c1 : 0;\n            c2 = cs ? cs.c2 : 0;\n            cr = r;\n            cc = c;\n            clear = 'current';\n        }\n        else if (shift) {\n            r1 = cs ? cs.r1 : 0;\n            r2 = cs ? cs.r2 + 1 : 0;\n            c1 = cs ? cs.c1 : 0;\n            c2 = cs ? cs.c2 : 0;\n            cr = r;\n            cc = c;\n            clear = 'current';\n        }\n        else if (accel) {\n            r1 = Infinity;\n            r2 = Infinity;\n            c1 = c;\n            c2 = c;\n            cr = r1;\n            cc = c1;\n            clear = 'all';\n        }\n        else {\n            r1 = r + 1;\n            r2 = r + 1;\n            c1 = c;\n            c2 = c;\n            cr = r1;\n            cc = c1;\n            clear = 'all';\n        }\n        // Create the new selection.\n        model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });\n        // Re-fetch the current selection.\n        cs = model.currentSelection();\n        // Bail if there is no selection.\n        if (!cs) {\n            return;\n        }\n        // Scroll the grid appropriately.\n        if (shift || mode === 'row') {\n            grid.scrollToRow(cs.r2);\n        }\n        else {\n            grid.scrollToCursor();\n        }\n    }\n    /**\n     * Handle the `'PageUp'` key press for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The keyboard event of interest.\n     */\n    onPageUp(grid, event) {\n        // Ignore the event if the accel key is pressed.\n        if (Platform.accelKey(event)) {\n            return;\n        }\n        // Stop the event propagation.\n        event.preventDefault();\n        event.stopPropagation();\n        // Fetch the selection model.\n        let model = grid.selectionModel;\n        // Scroll by page if there is no selection model.\n        if (!model || model.selectionMode === 'column') {\n            grid.scrollByPage('up');\n            return;\n        }\n        // Get the normal number of cells in the page height.\n        let n = Math.floor(grid.pageHeight / grid.defaultSizes.rowHeight);\n        // Fetch the cursor and selection.\n        let r = model.cursorRow;\n        let c = model.cursorColumn;\n        let cs = model.currentSelection();\n        // Set up the selection variables.\n        let r1;\n        let r2;\n        let c1;\n        let c2;\n        let cr;\n        let cc;\n        let clear;\n        // Select or resize as needed.\n        if (event.shiftKey) {\n            r1 = cs ? cs.r1 : 0;\n            r2 = cs ? cs.r2 - n : 0;\n            c1 = cs ? cs.c1 : 0;\n            c2 = cs ? cs.c2 : 0;\n            cr = r;\n            cc = c;\n            clear = 'current';\n        }\n        else {\n            r1 = cs ? cs.r1 - n : 0;\n            r2 = r1;\n            c1 = c;\n            c2 = c;\n            cr = r1;\n            cc = c;\n            clear = 'all';\n        }\n        // Create the new selection.\n        model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });\n        // Re-fetch the current selection.\n        cs = model.currentSelection();\n        // Bail if there is no selection.\n        if (!cs) {\n            return;\n        }\n        // Scroll the grid appropriately.\n        grid.scrollToRow(cs.r2);\n    }\n    /**\n     * Handle the `'PageDown'` key press for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The keyboard event of interest.\n     */\n    onPageDown(grid, event) {\n        // Ignore the event if the accel key is pressed.\n        if (Platform.accelKey(event)) {\n            return;\n        }\n        // Stop the event propagation.\n        event.preventDefault();\n        event.stopPropagation();\n        // Fetch the selection model.\n        let model = grid.selectionModel;\n        // Scroll by page if there is no selection model.\n        if (!model || model.selectionMode === 'column') {\n            grid.scrollByPage('down');\n            return;\n        }\n        // Get the normal number of cells in the page height.\n        let n = Math.floor(grid.pageHeight / grid.defaultSizes.rowHeight);\n        // Fetch the cursor and selection.\n        let r = model.cursorRow;\n        let c = model.cursorColumn;\n        let cs = model.currentSelection();\n        // Set up the selection variables.\n        let r1;\n        let r2;\n        let c1;\n        let c2;\n        let cr;\n        let cc;\n        let clear;\n        // Select or resize as needed.\n        if (event.shiftKey) {\n            r1 = cs ? cs.r1 : 0;\n            r2 = cs ? cs.r2 + n : 0;\n            c1 = cs ? cs.c1 : 0;\n            c2 = cs ? cs.c2 : 0;\n            cr = r;\n            cc = c;\n            clear = 'current';\n        }\n        else {\n            r1 = cs ? cs.r1 + n : 0;\n            r2 = r1;\n            c1 = c;\n            c2 = c;\n            cr = r1;\n            cc = c;\n            clear = 'all';\n        }\n        // Create the new selection.\n        model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });\n        // Re-fetch the current selection.\n        cs = model.currentSelection();\n        // Bail if there is no selection.\n        if (!cs) {\n            return;\n        }\n        // Scroll the grid appropriately.\n        grid.scrollToRow(cs.r2);\n    }\n    /**\n     * Handle the `'Escape'` key press for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The keyboard event of interest.\n     */\n    onEscape(grid, event) {\n        if (grid.selectionModel) {\n            grid.selectionModel.clear();\n        }\n    }\n    /**\n     * Handle the `'Delete'` key press for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The keyboard event of interest.\n     */\n    onDelete(grid, event) {\n        if (grid.editable && !grid.selectionModel.isEmpty) {\n            const dataModel = grid.dataModel;\n            // Fetch the max row and column.\n            let maxRow = dataModel.rowCount('body') - 1;\n            let maxColumn = dataModel.columnCount('body') - 1;\n            for (let s of grid.selectionModel.selections()) {\n                // Clamp the cell to the model bounds.\n                let sr1 = Math.max(0, Math.min(s.r1, maxRow));\n                let sc1 = Math.max(0, Math.min(s.c1, maxColumn));\n                let sr2 = Math.max(0, Math.min(s.r2, maxRow));\n                let sc2 = Math.max(0, Math.min(s.c2, maxColumn));\n                for (let r = sr1; r <= sr2; ++r) {\n                    for (let c = sc1; c <= sc2; ++c) {\n                        dataModel.setData('body', r, c, null);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Handle the `'C'` key press for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The keyboard event of interest.\n     */\n    onKeyC(grid, event) {\n        // Bail early if the modifiers aren't correct for copy.\n        if (event.shiftKey || !Platform.accelKey(event)) {\n            return;\n        }\n        // Stop the event propagation.\n        event.preventDefault();\n        event.stopPropagation();\n        // Copy the current selection to the clipboard.\n        grid.copyToClipboard();\n    }\n}\n\n/**\n * An object which renders the cells of a data grid.\n *\n * #### Notes\n * If the predefined cell renderers are insufficient for a particular\n * use case, a custom cell renderer can be defined which derives from\n * this class.\n *\n * The data grid renders cells in column-major order, by region. The\n * region order is: body, row header, column header, corner header.\n */\nclass CellRenderer {\n}\n/**\n * The namespace for the `CellRenderer` class statics.\n */\n(function (CellRenderer) {\n    /**\n     * Resolve a config option for a cell renderer.\n     *\n     * @param option - The config option to resolve.\n     *\n     * @param config - The cell config object.\n     *\n     * @returns The resolved value for the option.\n     */\n    function resolveOption(option, config) {\n        return typeof option === 'function'\n            ? option(config)\n            : option;\n    }\n    CellRenderer.resolveOption = resolveOption;\n})(CellRenderer || (CellRenderer = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * A cell renderer which renders data values as text.\n */\nclass TextRenderer extends CellRenderer {\n    /**\n     * Construct a new text renderer.\n     *\n     * @param options - The options for initializing the renderer.\n     */\n    constructor(options = {}) {\n        super();\n        this.font = options.font || '12px sans-serif';\n        this.textColor = options.textColor || '#000000';\n        this.backgroundColor = options.backgroundColor || '';\n        this.verticalAlignment = options.verticalAlignment || 'center';\n        this.horizontalAlignment = options.horizontalAlignment || 'left';\n        this.horizontalPadding = options.horizontalPadding || 8;\n        this.format = options.format || TextRenderer.formatGeneric();\n        this.elideDirection = options.elideDirection || 'none';\n        this.wrapText = options.wrapText || false;\n    }\n    /**\n     * Paint the content for a cell.\n     *\n     * @param gc - The graphics context to use for drawing.\n     *\n     * @param config - The configuration data for the cell.\n     */\n    paint(gc, config) {\n        this.drawBackground(gc, config);\n        this.drawText(gc, config);\n    }\n    /**\n     * Draw the background for the cell.\n     *\n     * @param gc - The graphics context to use for drawing.\n     *\n     * @param config - The configuration data for the cell.\n     */\n    drawBackground(gc, config) {\n        // Resolve the background color for the cell.\n        let color = CellRenderer.resolveOption(this.backgroundColor, config);\n        // Bail if there is no background color to draw.\n        if (!color) {\n            return;\n        }\n        // Fill the cell with the background color.\n        gc.fillStyle = color;\n        gc.fillRect(config.x, config.y, config.width, config.height);\n    }\n    /**\n     * Get the full text to be rendered by the cell.\n     */\n    getText(config) {\n        return this.format(config);\n    }\n    /**\n     * Draw the text for the cell.\n     *\n     * @param gc - The graphics context to use for drawing.\n     *\n     * @param config - The configuration data for the cell.\n     */\n    drawText(gc, config) {\n        // Resolve the font for the cell.\n        let font = CellRenderer.resolveOption(this.font, config);\n        // Bail if there is no font to draw.\n        if (!font) {\n            return;\n        }\n        // Resolve the text color for the cell.\n        let color = CellRenderer.resolveOption(this.textColor, config);\n        // Bail if there is no text color to draw.\n        if (!color) {\n            return;\n        }\n        // Format the cell value to text.\n        let text = this.getText(config);\n        // Bail if there is no text to draw.\n        if (!text) {\n            return;\n        }\n        // Resolve the vertical and horizontal alignment.\n        let vAlign = CellRenderer.resolveOption(this.verticalAlignment, config);\n        let hAlign = CellRenderer.resolveOption(this.horizontalAlignment, config);\n        // Resolve the elision direction\n        let elideDirection = CellRenderer.resolveOption(this.elideDirection, config);\n        // Resolve the text wrapping flag\n        let wrapText = CellRenderer.resolveOption(this.wrapText, config);\n        // Compute the padded text box height for the specified alignment.\n        let boxHeight = config.height - (vAlign === 'center' ? 1 : 2);\n        // Bail if the text box has no effective size.\n        if (boxHeight <= 0) {\n            return;\n        }\n        // Compute the text height for the gc font.\n        let textHeight = TextRenderer.measureFontHeight(font);\n        // Set up the text position variables.\n        let textX;\n        let textY;\n        let boxWidth;\n        // Compute the Y position for the text.\n        switch (vAlign) {\n            case 'top':\n                textY = config.y + 2 + textHeight;\n                break;\n            case 'center':\n                textY = config.y + config.height / 2 + textHeight / 2;\n                break;\n            case 'bottom':\n                textY = config.y + config.height - 2;\n                break;\n            default:\n                throw 'unreachable';\n        }\n        // Compute the X position for the text.\n        switch (hAlign) {\n            case 'left':\n                textX = config.x + this.horizontalPadding;\n                boxWidth = config.width - 14;\n                break;\n            case 'center':\n                textX = config.x + config.width / 2;\n                boxWidth = config.width;\n                break;\n            case 'right':\n                textX = config.x + config.width - this.horizontalPadding;\n                boxWidth = config.width - 14;\n                break;\n            default:\n                throw 'unreachable';\n        }\n        // Clip the cell if the text is taller than the text box height.\n        if (textHeight > boxHeight) {\n            gc.beginPath();\n            gc.rect(config.x, config.y, config.width, config.height - 1);\n            gc.clip();\n        }\n        // Set the gc state.\n        gc.font = font;\n        gc.fillStyle = color;\n        gc.textAlign = hAlign;\n        gc.textBaseline = 'bottom';\n        // Terminate call here if we're not eliding or wrapping text\n        if (elideDirection === 'none' && !wrapText) {\n            gc.fillText(text, textX, textY);\n            return;\n        }\n        // The current text width in pixels.\n        let textWidth = gc.measureText(text).width;\n        // Apply text wrapping if enabled.\n        if (wrapText && textWidth > boxWidth) {\n            // Make sure box clipping happens.\n            gc.beginPath();\n            gc.rect(config.x, config.y, config.width, config.height - 1);\n            gc.clip();\n            // Split column name to words based on\n            // whitespace preceding a word boundary.\n            // \"Hello  world\" --> [\"Hello  \", \"world\"]\n            const wordsInColumn = text.split(/\\s(?=\\b)/);\n            // Y-coordinate offset for any additional lines\n            let curY = textY;\n            let textInCurrentLine = wordsInColumn.shift();\n            // Single word. Applying text wrap on word by splitting\n            // it into characters and fitting the maximum number of\n            // characters possible per line (box width).\n            if (wordsInColumn.length === 0) {\n                let curLineTextWidth = gc.measureText(textInCurrentLine).width;\n                while (curLineTextWidth > boxWidth && textInCurrentLine !== '') {\n                    // Iterating from the end of the string until we find a\n                    // substring (0,i) which has a width less than the box width.\n                    for (let i = textInCurrentLine.length; i > 0; i--) {\n                        const curSubString = textInCurrentLine.substring(0, i);\n                        const curSubStringWidth = gc.measureText(curSubString).width;\n                        if (curSubStringWidth < boxWidth || curSubString.length === 1) {\n                            // Found a substring which has a width less than the current\n                            // box width. Rendering that substring on the current line\n                            // and setting the remainder of the parent string as the next\n                            // string to iterate on for the next line.\n                            const nextLineText = textInCurrentLine.substring(i, textInCurrentLine.length);\n                            textInCurrentLine = nextLineText;\n                            curLineTextWidth = gc.measureText(textInCurrentLine).width;\n                            gc.fillText(curSubString, textX, curY);\n                            curY += textHeight;\n                            // No need to continue iterating after we identified\n                            // an index to break the string on.\n                            break;\n                        }\n                    }\n                }\n            }\n            // Multiple words in column header. Fitting maximum\n            // number of words possible per line (box width).\n            else {\n                while (wordsInColumn.length !== 0) {\n                    // Processing the next word in the queue.\n                    const curWord = wordsInColumn.shift();\n                    // Joining that word with the existing text for\n                    // the current line.\n                    const incrementedText = [textInCurrentLine, curWord].join(' ');\n                    const incrementedTextWidth = gc.measureText(incrementedText).width;\n                    if (incrementedTextWidth > boxWidth) {\n                        // If the newly combined text has a width larger than\n                        // the box width, we render the line before the current\n                        // word was added. We set the current word as the next\n                        // line.\n                        gc.fillText(textInCurrentLine, textX, curY);\n                        curY += textHeight;\n                        textInCurrentLine = curWord;\n                    }\n                    else {\n                        // The combined text hasd a width less than the box width. We\n                        // set the the current line text to be the new combined text.\n                        textInCurrentLine = incrementedText;\n                    }\n                }\n            }\n            gc.fillText(textInCurrentLine, textX, curY);\n            // Terminating the call here as we don't want\n            // to apply text eliding when wrapping is active.\n            return;\n        }\n        // Elide text that is too long\n        const elide = '\\u2026';\n        // Loop until text width fits box or only one character remains\n        while (textWidth > boxWidth && text.length > 1) {\n            // Convert text string to array for dealing with astral symbols\n            const textArr = [...text];\n            if (elideDirection === 'right') {\n                // If text width is substantially bigger, take half the string\n                if (textArr.length > 4 && textWidth >= 2 * boxWidth) {\n                    text =\n                        textArr.slice(0, Math.floor(textArr.length / 2 + 1)).join('') +\n                            elide;\n                }\n                else {\n                    // Otherwise incrementally remove the last character\n                    text = textArr.slice(0, textArr.length - 2).join('') + elide;\n                }\n            }\n            else {\n                // If text width is substantially bigger, take half the string\n                if (textArr.length > 4 && textWidth >= 2 * boxWidth) {\n                    text = elide + textArr.slice(Math.floor(textArr.length / 2)).join('');\n                }\n                else {\n                    // Otherwise incrementally remove the last character\n                    text = elide + textArr.slice(2).join('');\n                }\n            }\n            // Measure new text width\n            textWidth = gc.measureText(text).width;\n        }\n        // Draw the text for the cell.\n        gc.fillText(text, textX, textY);\n    }\n}\n/**\n * The namespace for the `TextRenderer` class statics.\n */\n(function (TextRenderer) {\n    /**\n     * Create a generic text format function.\n     *\n     * @param options - The options for creating the format function.\n     *\n     * @returns A new generic text format function.\n     *\n     * #### Notes\n     * This formatter uses the builtin `String()` to coerce any value\n     * to a string.\n     */\n    function formatGeneric(options = {}) {\n        let missing = options.missing || '';\n        return ({ value }) => {\n            if (value === null || value === undefined) {\n                return missing;\n            }\n            return String(value);\n        };\n    }\n    TextRenderer.formatGeneric = formatGeneric;\n    /**\n     * Create a fixed decimal format function.\n     *\n     * @param options - The options for creating the format function.\n     *\n     * @returns A new fixed decimal format function.\n     *\n     * #### Notes\n     * This formatter uses the builtin `Number()` and `toFixed()` to\n     * coerce values.\n     *\n     * The `formatIntlNumber()` formatter is more flexible, but slower.\n     */\n    function formatFixed(options = {}) {\n        let digits = options.digits;\n        let missing = options.missing || '';\n        return ({ value }) => {\n            if (value === null || value === undefined) {\n                return missing;\n            }\n            return Number(value).toFixed(digits);\n        };\n    }\n    TextRenderer.formatFixed = formatFixed;\n    /**\n     * Create a significant figure format function.\n     *\n     * @param options - The options for creating the format function.\n     *\n     * @returns A new significant figure format function.\n     *\n     * #### Notes\n     * This formatter uses the builtin `Number()` and `toPrecision()`\n     * to coerce values.\n     *\n     * The `formatIntlNumber()` formatter is more flexible, but slower.\n     */\n    function formatPrecision(options = {}) {\n        let digits = options.digits;\n        let missing = options.missing || '';\n        return ({ value }) => {\n            if (value === null || value === undefined) {\n                return missing;\n            }\n            return Number(value).toPrecision(digits);\n        };\n    }\n    TextRenderer.formatPrecision = formatPrecision;\n    /**\n     * Create a scientific notation format function.\n     *\n     * @param options - The options for creating the format function.\n     *\n     * @returns A new scientific notation format function.\n     *\n     * #### Notes\n     * This formatter uses the builtin `Number()` and `toExponential()`\n     * to coerce values.\n     *\n     * The `formatIntlNumber()` formatter is more flexible, but slower.\n     */\n    function formatExponential(options = {}) {\n        let digits = options.digits;\n        let missing = options.missing || '';\n        return ({ value }) => {\n            if (value === null || value === undefined) {\n                return missing;\n            }\n            return Number(value).toExponential(digits);\n        };\n    }\n    TextRenderer.formatExponential = formatExponential;\n    /**\n     * Create an international number format function.\n     *\n     * @param options - The options for creating the format function.\n     *\n     * @returns A new international number format function.\n     *\n     * #### Notes\n     * This formatter uses the builtin `Intl.NumberFormat` object to\n     * coerce values.\n     *\n     * This is the most flexible (but slowest) number formatter.\n     */\n    function formatIntlNumber(options = {}) {\n        let missing = options.missing || '';\n        let nft = new Intl.NumberFormat(options.locales, options.options);\n        return ({ value }) => {\n            if (value === null || value === undefined) {\n                return missing;\n            }\n            return nft.format(value);\n        };\n    }\n    TextRenderer.formatIntlNumber = formatIntlNumber;\n    /**\n     * Create a date format function.\n     *\n     * @param options - The options for creating the format function.\n     *\n     * @returns A new date format function.\n     *\n     * #### Notes\n     * This formatter uses `Date.toDateString()` to format the values.\n     *\n     * If a value is not a `Date` object, `new Date(value)` is used to\n     * coerce the value to a date.\n     *\n     * The `formatIntlDateTime()` formatter is more flexible, but slower.\n     */\n    function formatDate(options = {}) {\n        let missing = options.missing || '';\n        return ({ value }) => {\n            if (value === null || value === undefined) {\n                return missing;\n            }\n            if (value instanceof Date) {\n                return value.toDateString();\n            }\n            return new Date(value).toDateString();\n        };\n    }\n    TextRenderer.formatDate = formatDate;\n    /**\n     * Create a time format function.\n     *\n     * @param options - The options for creating the format function.\n     *\n     * @returns A new time format function.\n     *\n     * #### Notes\n     * This formatter uses `Date.toTimeString()` to format the values.\n     *\n     * If a value is not a `Date` object, `new Date(value)` is used to\n     * coerce the value to a date.\n     *\n     * The `formatIntlDateTime()` formatter is more flexible, but slower.\n     */\n    function formatTime(options = {}) {\n        let missing = options.missing || '';\n        return ({ value }) => {\n            if (value === null || value === undefined) {\n                return missing;\n            }\n            if (value instanceof Date) {\n                return value.toTimeString();\n            }\n            return new Date(value).toTimeString();\n        };\n    }\n    TextRenderer.formatTime = formatTime;\n    /**\n     * Create an ISO datetime format function.\n     *\n     * @param options - The options for creating the format function.\n     *\n     * @returns A new ISO datetime format function.\n     *\n     * #### Notes\n     * This formatter uses `Date.toISOString()` to format the values.\n     *\n     * If a value is not a `Date` object, `new Date(value)` is used to\n     * coerce the value to a date.\n     *\n     * The `formatIntlDateTime()` formatter is more flexible, but slower.\n     */\n    function formatISODateTime(options = {}) {\n        let missing = options.missing || '';\n        return ({ value }) => {\n            if (value === null || value === undefined) {\n                return missing;\n            }\n            if (value instanceof Date) {\n                return value.toISOString();\n            }\n            return new Date(value).toISOString();\n        };\n    }\n    TextRenderer.formatISODateTime = formatISODateTime;\n    /**\n     * Create a UTC datetime format function.\n     *\n     * @param options - The options for creating the format function.\n     *\n     * @returns A new UTC datetime format function.\n     *\n     * #### Notes\n     * This formatter uses `Date.toUTCString()` to format the values.\n     *\n     * If a value is not a `Date` object, `new Date(value)` is used to\n     * coerce the value to a date.\n     *\n     * The `formatIntlDateTime()` formatter is more flexible, but slower.\n     */\n    function formatUTCDateTime(options = {}) {\n        let missing = options.missing || '';\n        return ({ value }) => {\n            if (value === null || value === undefined) {\n                return missing;\n            }\n            if (value instanceof Date) {\n                return value.toUTCString();\n            }\n            return new Date(value).toUTCString();\n        };\n    }\n    TextRenderer.formatUTCDateTime = formatUTCDateTime;\n    /**\n     * Create an international datetime format function.\n     *\n     * @param options - The options for creating the format function.\n     *\n     * @returns A new international datetime format function.\n     *\n     * #### Notes\n     * This formatter uses the builtin `Intl.DateTimeFormat` object to\n     * coerce values.\n     *\n     * This is the most flexible (but slowest) datetime formatter.\n     */\n    function formatIntlDateTime(options = {}) {\n        let missing = options.missing || '';\n        let dtf = new Intl.DateTimeFormat(options.locales, options.options);\n        return ({ value }) => {\n            if (value === null || value === undefined) {\n                return missing;\n            }\n            return dtf.format(value);\n        };\n    }\n    TextRenderer.formatIntlDateTime = formatIntlDateTime;\n    /**\n     * Measure the height of a font.\n     *\n     * @param font - The CSS font string of interest.\n     *\n     * @returns The height of the font bounding box.\n     *\n     * #### Notes\n     * This function uses a temporary DOM node to measure the text box\n     * height for the specified font. The first call for a given font\n     * will incur a DOM reflow, but the return value is cached, so any\n     * subsequent call for the same font will return the cached value.\n     */\n    function measureFontHeight(font) {\n        // Look up the cached font height.\n        let height = Private$6.fontHeightCache[font];\n        // Return the cached font height if it exists.\n        if (height !== undefined) {\n            return height;\n        }\n        // Normalize the font.\n        Private$6.fontMeasurementGC.font = font;\n        let normFont = Private$6.fontMeasurementGC.font;\n        // Set the font on the measurement node.\n        Private$6.fontMeasurementNode.style.font = normFont;\n        // Add the measurement node to the document.\n        document.body.appendChild(Private$6.fontMeasurementNode);\n        // Measure the node height.\n        height = Private$6.fontMeasurementNode.offsetHeight;\n        // Remove the measurement node from the document.\n        document.body.removeChild(Private$6.fontMeasurementNode);\n        // Cache the measured height for the font and norm font.\n        Private$6.fontHeightCache[font] = height;\n        Private$6.fontHeightCache[normFont] = height;\n        // Return the measured height.\n        return height;\n    }\n    TextRenderer.measureFontHeight = measureFontHeight;\n})(TextRenderer || (TextRenderer = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$6;\n(function (Private) {\n    /**\n     * A cache of measured font heights.\n     */\n    Private.fontHeightCache = Object.create(null);\n    /**\n     * The DOM node used for font height measurement.\n     */\n    Private.fontMeasurementNode = (() => {\n        let node = document.createElement('div');\n        node.style.position = 'absolute';\n        node.style.top = '-99999px';\n        node.style.left = '-99999px';\n        node.style.visibility = 'hidden';\n        node.textContent = 'M';\n        return node;\n    })();\n    /**\n     * The GC used for font measurement.\n     */\n    Private.fontMeasurementGC = (() => {\n        let canvas = document.createElement('canvas');\n        canvas.width = 0;\n        canvas.height = 0;\n        return canvas.getContext('2d');\n    })();\n})(Private$6 || (Private$6 = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * A cell renderer which renders data values as text.\n */\nclass HyperlinkRenderer extends TextRenderer {\n    /**\n     * Construct a new text renderer.\n     *\n     * @param options - The options for initializing the renderer.\n     */\n    constructor(options = {}) {\n        // Set default parameters before passing over the super.\n        options.textColor = options.textColor || 'navy';\n        options.font = options.font || 'bold 12px sans-serif';\n        super(options);\n        this.url = options.url;\n        this.urlName = options.urlName;\n    }\n    /**\n     * Get the full text to be rendered by the cell.\n     */\n    getText(config) {\n        let urlName = CellRenderer.resolveOption(this.urlName, config);\n        // If we have a friendly URL name, use that.\n        if (urlName) {\n            return this.format({\n                ...config,\n                value: urlName\n            });\n        }\n        // Otherwise use the raw value attribute.\n        return this.format(config);\n    }\n    /**\n     * Draw the text for the cell.\n     *\n     * @param gc - The graphics context to use for drawing.\n     *\n     * @param config - The configuration data for the cell.\n     */\n    drawText(gc, config) {\n        // Resolve the font for the cell.\n        let font = CellRenderer.resolveOption(this.font, config);\n        // Bail if there is no font to draw.\n        if (!font) {\n            return;\n        }\n        // Resolve the text color for the cell.\n        let color = CellRenderer.resolveOption(this.textColor, config);\n        // Bail if there is no text color to draw.\n        if (!color) {\n            return;\n        }\n        let text = this.getText(config);\n        // Bail if there is no text to draw.\n        if (!text) {\n            return;\n        }\n        // Resolve the vertical and horizontal alignment.\n        let vAlign = CellRenderer.resolveOption(this.verticalAlignment, config);\n        let hAlign = CellRenderer.resolveOption(this.horizontalAlignment, config);\n        // Resolve the elision direction\n        let elideDirection = CellRenderer.resolveOption(this.elideDirection, config);\n        // Resolve the text wrapping flag\n        let wrapText = CellRenderer.resolveOption(this.wrapText, config);\n        // Compute the padded text box height for the specified alignment.\n        let boxHeight = config.height - (vAlign === 'center' ? 1 : 2);\n        // Bail if the text box has no effective size.\n        if (boxHeight <= 0) {\n            return;\n        }\n        // Compute the text height for the gc font.\n        let textHeight = HyperlinkRenderer.measureFontHeight(font);\n        // Set up the text position variables.\n        let textX;\n        let textY;\n        let boxWidth;\n        // Compute the Y position for the text.\n        switch (vAlign) {\n            case 'top':\n                textY = config.y + 2 + textHeight;\n                break;\n            case 'center':\n                textY = config.y + config.height / 2 + textHeight / 2;\n                break;\n            case 'bottom':\n                textY = config.y + config.height - 2;\n                break;\n            default:\n                throw 'unreachable';\n        }\n        // Compute the X position for the text.\n        switch (hAlign) {\n            case 'left':\n                textX = config.x + 8;\n                boxWidth = config.width - 14;\n                break;\n            case 'center':\n                textX = config.x + config.width / 2;\n                boxWidth = config.width;\n                break;\n            case 'right':\n                textX = config.x + config.width - 8;\n                boxWidth = config.width - 14;\n                break;\n            default:\n                throw 'unreachable';\n        }\n        // Clip the cell if the text is taller than the text box height.\n        if (textHeight > boxHeight) {\n            gc.beginPath();\n            gc.rect(config.x, config.y, config.width, config.height - 1);\n            gc.clip();\n        }\n        // Set the gc state.\n        gc.font = font;\n        gc.fillStyle = color;\n        gc.textAlign = hAlign;\n        gc.textBaseline = 'bottom';\n        // Terminate call here if we're not eliding or wrapping text\n        if (elideDirection === 'none' && !wrapText) {\n            gc.fillText(text, textX, textY);\n            return;\n        }\n        // The current text width in pixels.\n        let textWidth = gc.measureText(text).width;\n        // Apply text wrapping if enabled.\n        if (wrapText && textWidth > boxWidth) {\n            // Make sure box clipping happens.\n            gc.beginPath();\n            gc.rect(config.x, config.y, config.width, config.height - 1);\n            gc.clip();\n            // Split column name to words based on\n            // whitespace preceding a word boundary.\n            // \"Hello  world\" --> [\"Hello  \", \"world\"]\n            const wordsInColumn = text.split(/\\s(?=\\b)/);\n            // Y-coordinate offset for any additional lines\n            let curY = textY;\n            let textInCurrentLine = wordsInColumn.shift();\n            // Single word. Applying text wrap on word by splitting\n            // it into characters and fitting the maximum number of\n            // characters possible per line (box width).\n            if (wordsInColumn.length === 0) {\n                let curLineTextWidth = gc.measureText(textInCurrentLine).width;\n                while (curLineTextWidth > boxWidth && textInCurrentLine !== '') {\n                    // Iterating from the end of the string until we find a\n                    // substring (0,i) which has a width less than the box width.\n                    for (let i = textInCurrentLine.length; i > 0; i--) {\n                        const curSubString = textInCurrentLine.substring(0, i);\n                        const curSubStringWidth = gc.measureText(curSubString).width;\n                        if (curSubStringWidth < boxWidth || curSubString.length === 1) {\n                            // Found a substring which has a width less than the current\n                            // box width. Rendering that substring on the current line\n                            // and setting the remainder of the parent string as the next\n                            // string to iterate on for the next line.\n                            const nextLineText = textInCurrentLine.substring(i, textInCurrentLine.length);\n                            textInCurrentLine = nextLineText;\n                            curLineTextWidth = gc.measureText(textInCurrentLine).width;\n                            gc.fillText(curSubString, textX, curY);\n                            curY += textHeight;\n                            // No need to continue iterating after we identified\n                            // an index to break the string on.\n                            break;\n                        }\n                    }\n                }\n            }\n            // Multiple words in column header. Fitting maximum\n            // number of words possible per line (box width).\n            else {\n                while (wordsInColumn.length !== 0) {\n                    // Processing the next word in the queue.\n                    const curWord = wordsInColumn.shift();\n                    // Joining that word with the existing text for\n                    // the current line.\n                    const incrementedText = [textInCurrentLine, curWord].join(' ');\n                    const incrementedTextWidth = gc.measureText(incrementedText).width;\n                    if (incrementedTextWidth > boxWidth) {\n                        // If the newly combined text has a width larger than\n                        // the box width, we render the line before the current\n                        // word was added. We set the current word as the next\n                        // line.\n                        gc.fillText(textInCurrentLine, textX, curY);\n                        curY += textHeight;\n                        textInCurrentLine = curWord;\n                    }\n                    else {\n                        // The combined text hasd a width less than the box width. We\n                        // set the the current line text to be the new combined text.\n                        textInCurrentLine = incrementedText;\n                    }\n                }\n            }\n            gc.fillText(textInCurrentLine, textX, curY);\n            // Terminating the call here as we don't want\n            // to apply text eliding when wrapping is active.\n            return;\n        }\n        // Elide text that is too long\n        let elide = '\\u2026';\n        // Compute elided text\n        if (elideDirection === 'right') {\n            while (textWidth > boxWidth && text.length > 1) {\n                if (text.length > 4 && textWidth >= 2 * boxWidth) {\n                    // If text width is substantially bigger, take half the string\n                    text = text.substring(0, text.length / 2 + 1) + elide;\n                }\n                else {\n                    // Otherwise incrementally remove the last character\n                    text = text.substring(0, text.length - 2) + elide;\n                }\n                textWidth = gc.measureText(text).width;\n            }\n        }\n        else {\n            while (textWidth > boxWidth && text.length > 1) {\n                if (text.length > 4 && textWidth >= 2 * boxWidth) {\n                    // If text width is substantially bigger, take half the string\n                    text = elide + text.substring(text.length / 2);\n                }\n                else {\n                    // Otherwise incrementally remove the last character\n                    text = elide + text.substring(2);\n                }\n                textWidth = gc.measureText(text).width;\n            }\n        }\n        // Draw the text for the cell.\n        gc.fillText(text, textX, textY);\n    }\n}\n\n/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\n/**\n * A collection of helper functions relating to merged cell groups\n */\nvar CellGroup;\n(function (CellGroup) {\n    /**\n     * Checks if two cell-groups are intersecting\n     * in the given axis.\n     * @param group1\n     * @param group2\n     * @param axis\n     */\n    function areCellGroupsIntersectingAtAxis(group1, group2, axis) {\n        if (axis === 'row') {\n            return ((group1.r1 >= group2.r1 && group1.r1 <= group2.r2) ||\n                (group1.r2 >= group2.r1 && group1.r2 <= group2.r2) ||\n                (group2.r1 >= group1.r1 && group2.r1 <= group1.r2) ||\n                (group2.r2 >= group1.r1 && group2.r2 <= group1.r2));\n        }\n        return ((group1.c1 >= group2.c1 && group1.c1 <= group2.c2) ||\n            (group1.c2 >= group2.c1 && group1.c2 <= group2.c2) ||\n            (group2.c1 >= group1.c1 && group2.c1 <= group1.c2) ||\n            (group2.c2 >= group1.c1 && group2.c2 <= group1.c2));\n    }\n    CellGroup.areCellGroupsIntersectingAtAxis = areCellGroupsIntersectingAtAxis;\n    /**\n     * Checks if cell-groups are intersecting.\n     * @param group1\n     * @param group2\n     */\n    function areCellGroupsIntersecting(group1, group2) {\n        return (((group1.r1 >= group2.r1 && group1.r1 <= group2.r2) ||\n            (group1.r2 >= group2.r1 && group1.r2 <= group2.r2) ||\n            (group2.r1 >= group1.r1 && group2.r1 <= group1.r2) ||\n            (group2.r2 >= group1.r1 && group2.r2 <= group1.r2)) &&\n            ((group1.c1 >= group2.c1 && group1.c1 <= group2.c2) ||\n                (group1.c2 >= group2.c1 && group1.c2 <= group2.c2) ||\n                (group2.c1 >= group1.c1 && group2.c1 <= group1.c2) ||\n                (group2.c2 >= group1.c1 && group2.c2 <= group1.c2)));\n    }\n    CellGroup.areCellGroupsIntersecting = areCellGroupsIntersecting;\n    /**\n     * Retrieves the index of the cell-group to which\n     * the cell at the given row, column belongs.\n     * @param dataModel\n     * @param rgn\n     * @param row\n     * @param column\n     */\n    function getGroupIndex(dataModel, rgn, row, column) {\n        const numGroups = dataModel.groupCount(rgn);\n        for (let i = 0; i < numGroups; i++) {\n            const group = dataModel.group(rgn, i);\n            if (row >= group.r1 &&\n                row <= group.r2 &&\n                column >= group.c1 &&\n                column <= group.c2) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    CellGroup.getGroupIndex = getGroupIndex;\n    /**\n     * Returns a cell-group for the given row/index coordinates.\n     * @param dataModel\n     * @param rgn\n     * @param row\n     * @param column\n     */\n    function getGroup(dataModel, rgn, row, column) {\n        const groupIndex = getGroupIndex(dataModel, rgn, row, column);\n        if (groupIndex === -1) {\n            return null;\n        }\n        return dataModel.group(rgn, groupIndex);\n    }\n    CellGroup.getGroup = getGroup;\n    /**\n     * Returns all cell groups which belong to\n     * a given cell cell region.\n     * @param dataModel\n     * @param rgn\n     */\n    function getCellGroupsAtRegion(dataModel, rgn) {\n        let groupsAtRegion = [];\n        const numGroups = dataModel.groupCount(rgn);\n        for (let i = 0; i < numGroups; i++) {\n            const group = dataModel.group(rgn, i);\n            groupsAtRegion.push(group);\n        }\n        return groupsAtRegion;\n    }\n    CellGroup.getCellGroupsAtRegion = getCellGroupsAtRegion;\n    /**\n     * Calculates and returns a merged cell-group from\n     * two cell-group objects.\n     * @param groups\n     */\n    function joinCellGroups(groups) {\n        let startRow = Number.MAX_VALUE;\n        let endRow = Number.MIN_VALUE;\n        let startColumn = Number.MAX_VALUE;\n        let endColumn = Number.MIN_VALUE;\n        for (const group of groups) {\n            startRow = Math.min(startRow, group.r1);\n            endRow = Math.max(endRow, group.r2);\n            startColumn = Math.min(startColumn, group.c1);\n            endColumn = Math.max(endColumn, group.c2);\n        }\n        return { r1: startRow, r2: endRow, c1: startColumn, c2: endColumn };\n    }\n    CellGroup.joinCellGroups = joinCellGroups;\n    /**\n     * Merges a cell group with other cells groups in the\n     * same region if they intersect.\n     * @param dataModel the data model of the grid.\n     * @param group the target cell group.\n     * @param region the region of the cell group.\n     * @returns a new cell group after merging has happened.\n     */\n    function joinCellGroupWithMergedCellGroups(dataModel, group, region) {\n        let joinedGroup = { ...group };\n        const mergedCellGroups = getCellGroupsAtRegion(dataModel, region);\n        for (let g = 0; g < mergedCellGroups.length; g++) {\n            const mergedGroup = mergedCellGroups[g];\n            if (areCellGroupsIntersecting(joinedGroup, mergedGroup)) {\n                joinedGroup = joinCellGroups([joinedGroup, mergedGroup]);\n            }\n        }\n        return joinedGroup;\n    }\n    CellGroup.joinCellGroupWithMergedCellGroups = joinCellGroupWithMergedCellGroups;\n    /**\n     * Retrieves a list of cell groups intersecting at\n     * a given row.\n     * @param dataModel data model of the grid.\n     * @param rgn the cell region.\n     * @param row the target row to look for intersections at.\n     * @returns all cell groups intersecting with the row.\n     */\n    function getCellGroupsAtRow(dataModel, rgn, row) {\n        let groupsAtRow = [];\n        const numGroups = dataModel.groupCount(rgn);\n        for (let i = 0; i < numGroups; i++) {\n            const group = dataModel.group(rgn, i);\n            if (row >= group.r1 && row <= group.r2) {\n                groupsAtRow.push(group);\n            }\n        }\n        return groupsAtRow;\n    }\n    CellGroup.getCellGroupsAtRow = getCellGroupsAtRow;\n    /**\n     * Retrieves a list of cell groups intersecting at\n     * a given column.\n     * @param dataModel data model of the grid.\n     * @param rgn the cell region.\n     * @param column the target column to look for intersections at.\n     * @returns all cell groups intersecting with the column.\n     */\n    function getCellGroupsAtColumn(dataModel, rgn, column) {\n        let groupsAtColumn = [];\n        const numGroups = dataModel.groupCount(rgn);\n        for (let i = 0; i < numGroups; i++) {\n            const group = dataModel.group(rgn, i);\n            if (column >= group.c1 && column <= group.c2) {\n                groupsAtColumn.push(group);\n            }\n        }\n        return groupsAtColumn;\n    }\n    CellGroup.getCellGroupsAtColumn = getCellGroupsAtColumn;\n    /**\n     * Merges a target cell group with any cell groups\n     * it intersects with at a given row or column.\n     * @param dataModel data model of the grid.\n     * @param regions list of cell regions.\n     * @param axis row or column.\n     * @param group the target cell group.\n     * @returns a new merged cell group.\n     */\n    function joinCellGroupsIntersectingAtAxis(dataModel, regions, axis, group) {\n        let groupsAtAxis = [];\n        if (axis === 'row') {\n            for (const region of regions) {\n                for (let r = group.r1; r <= group.r2; r++) {\n                    groupsAtAxis = groupsAtAxis.concat(CellGroup.getCellGroupsAtRow(dataModel, region, r));\n                }\n            }\n        }\n        else {\n            for (const region of regions) {\n                for (let c = group.c1; c <= group.c2; c++) {\n                    groupsAtAxis = groupsAtAxis.concat(CellGroup.getCellGroupsAtColumn(dataModel, region, c));\n                }\n            }\n        }\n        let mergedGroupAtAxis = CellGroup.joinCellGroups(groupsAtAxis);\n        if (groupsAtAxis.length > 0) {\n            let mergedCellGroups = [];\n            for (const region of regions) {\n                mergedCellGroups = mergedCellGroups.concat(CellGroup.getCellGroupsAtRegion(dataModel, region));\n            }\n            for (let g = 0; g < mergedCellGroups.length; g++) {\n                const group = mergedCellGroups[g];\n                if (CellGroup.areCellGroupsIntersectingAtAxis(mergedGroupAtAxis, group, axis)) {\n                    mergedGroupAtAxis = CellGroup.joinCellGroups([\n                        group,\n                        mergedGroupAtAxis\n                    ]);\n                    mergedCellGroups.splice(g, 1);\n                    g = 0;\n                }\n            }\n        }\n        return mergedGroupAtAxis;\n    }\n    CellGroup.joinCellGroupsIntersectingAtAxis = joinCellGroupsIntersectingAtAxis;\n})(CellGroup || (CellGroup = {}));\n\n/**\n * A basic implementation of a data grid mouse handler.\n *\n * #### Notes\n * This class may be subclassed and customized as needed.\n */\nclass BasicMouseHandler {\n    constructor() {\n        this._disposed = false;\n        this._pressData = null;\n    }\n    /**\n     * Dispose of the resources held by the mouse handler.\n     */\n    dispose() {\n        // Bail early if the handler is already disposed.\n        if (this._disposed) {\n            return;\n        }\n        // Release any held resources.\n        this.release();\n        // Mark the handler as disposed.\n        this._disposed = true;\n    }\n    /**\n     * Whether the mouse handler is disposed.\n     */\n    get isDisposed() {\n        return this._disposed;\n    }\n    /**\n     * Release the resources held by the handler.\n     */\n    release() {\n        // Bail early if the is no press data.\n        if (!this._pressData) {\n            return;\n        }\n        // Clear the autoselect timeout.\n        if (this._pressData.type === 'select') {\n            this._pressData.timeout = -1;\n        }\n        // Clear the press data.\n        this._pressData.override.dispose();\n        this._pressData = null;\n    }\n    /**\n     * Handle the mouse hover event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse hover event of interest.\n     */\n    onMouseHover(grid, event) {\n        // Hit test the grid.\n        let hit = grid.hitTest(event.clientX, event.clientY);\n        // Get the resize handle for the hit test.\n        let handle = Private$5.resizeHandleForHitTest(hit);\n        // Fetch the cursor for the handle.\n        let cursor = this.cursorForHandle(handle);\n        // Hyperlink logic.\n        const config = Private$5.createCellConfigObject(grid, hit);\n        if (config) {\n            // Retrieve renderer for hovered cell.\n            const renderer = grid.cellRenderers.get(config);\n            if (renderer instanceof HyperlinkRenderer) {\n                cursor = this.cursorForHandle('hyperlink');\n            }\n        }\n        // Update the viewport cursor based on the part.\n        grid.viewport.node.style.cursor = cursor;\n        // TODO support user-defined hover items\n    }\n    /**\n     * Handle the mouse leave event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse hover event of interest.\n     */\n    onMouseLeave(grid, event) {\n        // TODO support user-defined hover popups.\n        // Clear the viewport cursor.\n        grid.viewport.node.style.cursor = '';\n    }\n    /**\n     * Handle the mouse down event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse down event of interest.\n     */\n    onMouseDown(grid, event) {\n        // Unpack the event.\n        let { clientX, clientY } = event;\n        // Hit test the grid.\n        let hit = grid.hitTest(clientX, clientY);\n        // Unpack the hit test.\n        const { region, row, column } = hit;\n        // Bail if the hit test is on an uninteresting region.\n        if (region === 'void') {\n            return;\n        }\n        // Fetch the modifier flags.\n        let shift = event.shiftKey;\n        let accel = Platform.accelKey(event);\n        // Hyperlink logic.\n        if (grid) {\n            // Create cell config object.\n            const config = Private$5.createCellConfigObject(grid, hit);\n            // Retrieve cell renderer.\n            let renderer = grid.cellRenderers.get(config);\n            // Only process hyperlink renderers.\n            if (renderer instanceof HyperlinkRenderer) {\n                // Use the url param if it exists.\n                let url = CellRenderer.resolveOption(renderer.url, config);\n                // Otherwise assume cell value is the URL.\n                if (!url) {\n                    const format = TextRenderer.formatGeneric();\n                    url = format(config);\n                }\n                // Open the hyperlink only if user hit Ctrl+Click.\n                if (accel) {\n                    window.open(url);\n                    // Reset cursor default after clicking\n                    const cursor = this.cursorForHandle('none');\n                    grid.viewport.node.style.cursor = cursor;\n                    // Not applying selections if navigating away.\n                    return;\n                }\n            }\n        }\n        // If the hit test is the body region, the only option is select.\n        if (region === 'body') {\n            // Fetch the selection model.\n            let model = grid.selectionModel;\n            // Bail early if there is no selection model.\n            if (!model) {\n                return;\n            }\n            // Override the document cursor.\n            let override = Drag.overrideCursor('default');\n            // Set up the press data.\n            this._pressData = {\n                type: 'select',\n                region,\n                row,\n                column,\n                override,\n                localX: -1,\n                localY: -1,\n                timeout: -1\n            };\n            // Set up the selection variables.\n            let r1;\n            let c1;\n            let r2;\n            let c2;\n            let cursorRow;\n            let cursorColumn;\n            let clear;\n            // Accel == new selection, keep old selections.\n            if (accel) {\n                r1 = row;\n                r2 = row;\n                c1 = column;\n                c2 = column;\n                cursorRow = row;\n                cursorColumn = column;\n                clear = 'none';\n            }\n            else if (shift) {\n                r1 = model.cursorRow;\n                r2 = row;\n                c1 = model.cursorColumn;\n                c2 = column;\n                cursorRow = model.cursorRow;\n                cursorColumn = model.cursorColumn;\n                clear = 'current';\n            }\n            else {\n                r1 = row;\n                r2 = row;\n                c1 = column;\n                c2 = column;\n                cursorRow = row;\n                cursorColumn = column;\n                clear = 'all';\n            }\n            // Make the selection.\n            model.select({ r1, c1, r2, c2, cursorRow, cursorColumn, clear });\n            // Done.\n            return;\n        }\n        // Otherwise, the hit test is on a header region.\n        // Convert the hit test into a part.\n        let handle = Private$5.resizeHandleForHitTest(hit);\n        // Fetch the cursor for the handle.\n        let cursor = this.cursorForHandle(handle);\n        // Handle horizontal resize.\n        if (handle === 'left' || handle === 'right') {\n            // Set up the resize data type.\n            const type = 'column-resize';\n            // Determine the column region.\n            let rgn = region === 'column-header' ? 'body' : 'row-header';\n            // Determine the section index.\n            let index = handle === 'left' ? column - 1 : column;\n            // Fetch the section size.\n            let size = grid.columnSize(rgn, index);\n            // Override the document cursor.\n            let override = Drag.overrideCursor(cursor);\n            // Create the temporary press data.\n            this._pressData = { type, region: rgn, index, size, clientX, override };\n            // Done.\n            return;\n        }\n        // Handle vertical resize\n        if (handle === 'top' || handle === 'bottom') {\n            // Set up the resize data type.\n            const type = 'row-resize';\n            // Determine the row region.\n            let rgn = region === 'row-header' ? 'body' : 'column-header';\n            // Determine the section index.\n            let index = handle === 'top' ? row - 1 : row;\n            // Fetch the section size.\n            let size = grid.rowSize(rgn, index);\n            // Override the document cursor.\n            let override = Drag.overrideCursor(cursor);\n            // Create the temporary press data.\n            this._pressData = { type, region: rgn, index, size, clientY, override };\n            // Done.\n            return;\n        }\n        // Otherwise, the only option is select.\n        // Fetch the selection model.\n        let model = grid.selectionModel;\n        // Bail if there is no selection model.\n        if (!model) {\n            return;\n        }\n        // Override the document cursor.\n        let override = Drag.overrideCursor('default');\n        // Set up the press data.\n        this._pressData = {\n            type: 'select',\n            region,\n            row,\n            column,\n            override,\n            localX: -1,\n            localY: -1,\n            timeout: -1\n        };\n        // Set up the selection variables.\n        let r1;\n        let c1;\n        let r2;\n        let c2;\n        let cursorRow;\n        let cursorColumn;\n        let clear;\n        // Compute the selection based on the pressed region.\n        if (region === 'corner-header') {\n            r1 = 0;\n            r2 = Infinity;\n            c1 = 0;\n            c2 = Infinity;\n            cursorRow = accel ? 0 : shift ? model.cursorRow : 0;\n            cursorColumn = accel ? 0 : shift ? model.cursorColumn : 0;\n            clear = accel ? 'none' : shift ? 'current' : 'all';\n        }\n        else if (region === 'row-header') {\n            r1 = accel ? row : shift ? model.cursorRow : row;\n            r2 = row;\n            const selectionGroup = { r1: r1, c1: 0, r2: r2, c2: 0 };\n            const joinedGroup = CellGroup.joinCellGroupsIntersectingAtAxis(grid.dataModel, ['row-header', 'body'], 'row', selectionGroup);\n            // Check if there are any merges\n            if (joinedGroup.r1 != Number.MAX_VALUE) {\n                r1 = joinedGroup.r1;\n                r2 = joinedGroup.r2;\n            }\n            c1 = 0;\n            c2 = Infinity;\n            cursorRow = accel ? row : shift ? model.cursorRow : row;\n            cursorColumn = accel ? 0 : shift ? model.cursorColumn : 0;\n            clear = accel ? 'none' : shift ? 'current' : 'all';\n        }\n        else if (region === 'column-header') {\n            r1 = 0;\n            r2 = Infinity;\n            c1 = accel ? column : shift ? model.cursorColumn : column;\n            c2 = column;\n            const selectionGroup = { r1: 0, c1: c1, r2: 0, c2: c2 };\n            const joinedGroup = CellGroup.joinCellGroupsIntersectingAtAxis(grid.dataModel, ['column-header', 'body'], 'column', selectionGroup);\n            // Check if there are any merges\n            if (joinedGroup.c1 != Number.MAX_VALUE) {\n                c1 = joinedGroup.c1;\n                c2 = joinedGroup.c2;\n            }\n            cursorRow = accel ? 0 : shift ? model.cursorRow : 0;\n            cursorColumn = accel ? column : shift ? model.cursorColumn : column;\n            clear = accel ? 'none' : shift ? 'current' : 'all';\n        }\n        else {\n            r1 = accel ? row : shift ? model.cursorRow : row;\n            r2 = row;\n            c1 = accel ? column : shift ? model.cursorColumn : column;\n            c2 = column;\n            cursorRow = accel ? row : shift ? model.cursorRow : row;\n            cursorColumn = accel ? column : shift ? model.cursorColumn : column;\n            clear = accel ? 'none' : shift ? 'current' : 'all';\n        }\n        // Make the selection.\n        model.select({ r1, c1, r2, c2, cursorRow, cursorColumn, clear });\n    }\n    /**\n     * Handle the mouse move event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse move event of interest.\n     */\n    onMouseMove(grid, event) {\n        // Fetch the press data.\n        const data = this._pressData;\n        // Bail early if there is no press data.\n        if (!data) {\n            return;\n        }\n        // Handle a row resize.\n        if (data.type === 'row-resize') {\n            let dy = event.clientY - data.clientY;\n            grid.resizeRow(data.region, data.index, data.size + dy);\n            return;\n        }\n        // Handle a column resize.\n        if (data.type === 'column-resize') {\n            let dx = event.clientX - data.clientX;\n            grid.resizeColumn(data.region, data.index, data.size + dx);\n            return;\n        }\n        // Otherwise, it's a select.\n        // Mouse moves during a corner header press are a no-op.\n        if (data.region === 'corner-header') {\n            return;\n        }\n        // Fetch the selection model.\n        let model = grid.selectionModel;\n        // Bail early if the selection model was removed.\n        if (!model) {\n            return;\n        }\n        // Map to local coordinates.\n        let { lx, ly } = grid.mapToLocal(event.clientX, event.clientY);\n        // Update the local mouse coordinates in the press data.\n        data.localX = lx;\n        data.localY = ly;\n        // Fetch the grid geometry.\n        let hw = grid.headerWidth;\n        let hh = grid.headerHeight;\n        let vpw = grid.viewportWidth;\n        let vph = grid.viewportHeight;\n        let sx = grid.scrollX;\n        let sy = grid.scrollY;\n        let msx = grid.maxScrollY;\n        let msy = grid.maxScrollY;\n        // Fetch the selection mode.\n        let mode = model.selectionMode;\n        // Set up the timeout variable.\n        let timeout = -1;\n        // Compute the timemout based on hit region and mouse position.\n        if (data.region === 'row-header' || mode === 'row') {\n            if (ly < hh && sy > 0) {\n                timeout = Private$5.computeTimeout(hh - ly);\n            }\n            else if (ly >= vph && sy < msy) {\n                timeout = Private$5.computeTimeout(ly - vph);\n            }\n        }\n        else if (data.region === 'column-header' || mode === 'column') {\n            if (lx < hw && sx > 0) {\n                timeout = Private$5.computeTimeout(hw - lx);\n            }\n            else if (lx >= vpw && sx < msx) {\n                timeout = Private$5.computeTimeout(lx - vpw);\n            }\n        }\n        else {\n            if (lx < hw && sx > 0) {\n                timeout = Private$5.computeTimeout(hw - lx);\n            }\n            else if (lx >= vpw && sx < msx) {\n                timeout = Private$5.computeTimeout(lx - vpw);\n            }\n            else if (ly < hh && sy > 0) {\n                timeout = Private$5.computeTimeout(hh - ly);\n            }\n            else if (ly >= vph && sy < msy) {\n                timeout = Private$5.computeTimeout(ly - vph);\n            }\n        }\n        // Update or initiate the autoselect if needed.\n        if (timeout >= 0) {\n            if (data.timeout < 0) {\n                data.timeout = timeout;\n                setTimeout(() => {\n                    Private$5.autoselect(grid, data);\n                }, timeout);\n            }\n            else {\n                data.timeout = timeout;\n            }\n            return;\n        }\n        // Otherwise, clear the autoselect timeout.\n        data.timeout = -1;\n        // Map the position to virtual coordinates.\n        let { vx, vy } = grid.mapToVirtual(event.clientX, event.clientY);\n        // Clamp the coordinates to the limits.\n        vx = Math.max(0, Math.min(vx, grid.bodyWidth - 1));\n        vy = Math.max(0, Math.min(vy, grid.bodyHeight - 1));\n        // Set up the selection variables.\n        let r1;\n        let c1;\n        let r2;\n        let c2;\n        let cursorRow = model.cursorRow;\n        let cursorColumn = model.cursorColumn;\n        let clear = 'current';\n        // Compute the selection based pressed region.\n        if (data.region === 'row-header' || mode === 'row') {\n            r1 = data.row;\n            r2 = grid.rowAt('body', vy);\n            const selectionGroup = { r1: r1, c1: 0, r2: r2, c2: 0 };\n            const joinedGroup = CellGroup.joinCellGroupsIntersectingAtAxis(grid.dataModel, ['row-header', 'body'], 'row', selectionGroup);\n            // Check if there are any merges\n            if (joinedGroup.r1 != Number.MAX_VALUE) {\n                r1 = Math.min(r1, joinedGroup.r1);\n                r2 = Math.max(r2, joinedGroup.r2);\n            }\n            c1 = 0;\n            c2 = Infinity;\n        }\n        else if (data.region === 'column-header' || mode === 'column') {\n            r1 = 0;\n            r2 = Infinity;\n            c1 = data.column;\n            c2 = grid.columnAt('body', vx);\n            const selectionGroup = { r1: 0, c1: c1, r2: 0, c2: c2 };\n            const joinedGroup = CellGroup.joinCellGroupsIntersectingAtAxis(grid.dataModel, ['column-header', 'body'], 'column', selectionGroup);\n            // Check if there are any merges\n            if (joinedGroup.c1 != Number.MAX_VALUE) {\n                c1 = joinedGroup.c1;\n                c2 = joinedGroup.c2;\n            }\n        }\n        else {\n            r1 = cursorRow;\n            r2 = grid.rowAt('body', vy);\n            c1 = cursorColumn;\n            c2 = grid.columnAt('body', vx);\n        }\n        // Make the selection.\n        model.select({ r1, c1, r2, c2, cursorRow, cursorColumn, clear });\n    }\n    /**\n     * Handle the mouse up event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse up event of interest.\n     */\n    onMouseUp(grid, event) {\n        this.release();\n    }\n    /**\n     * Handle the mouse double click event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse up event of interest.\n     */\n    onMouseDoubleClick(grid, event) {\n        var _a, _b, _c;\n        if (!grid.dataModel) {\n            this.release();\n            return;\n        }\n        // Unpack the event.\n        let { clientX, clientY } = event;\n        // Hit test the grid.\n        let hit = grid.hitTest(clientX, clientY);\n        // Unpack the hit test.\n        let { region, row, column } = hit;\n        if (region === 'void') {\n            this.release();\n            return;\n        }\n        if (region === 'column-header' || region === 'corner-header') {\n            // Convert the hit test into a part.\n            const handle = Private$5.resizeHandleForHitTest(hit);\n            if (handle === 'left' || handle === 'right') {\n                let colIndex = handle === 'left' ? column - 1 : column;\n                let colRegion = region === 'column-header' ? 'body' : 'row-header';\n                if (colIndex < 0) {\n                    if (region === 'column-header') {\n                        // If the column is -1, it means we are in the corner header\n                        colIndex = grid.dataModel.columnCount('row-header') - 1;\n                        colRegion = 'row-header';\n                    }\n                    else {\n                        // If we are on the left edge of the row header, do nothing\n                        return;\n                    }\n                }\n                const cs = (_a = grid.selectionModel) === null || _a === void 0 ? void 0 : _a.currentSelection();\n                const cv = grid.currentViewport;\n                const rowCount = (_c = (_b = grid.selectionModel) === null || _b === void 0 ? void 0 : _b.dataModel.rowCount('body')) !== null && _c !== void 0 ? _c : 0;\n                if (colRegion == 'body' &&\n                    cs != null &&\n                    cv != null &&\n                    cs.r1 == 0 &&\n                    cs.r2 == rowCount - 1) {\n                    // One or more columns are selected\n                    let c1 = Math.max(Math.min(cs.c1, cs.c2), cv.firstColumn);\n                    let c2 = Math.min(Math.max(cs.c1, cs.c2), cv.lastColumn);\n                    if (c1 <= colIndex && colIndex <= c2) {\n                        // When we double-click one of the selected column headers, resize all visible selected columns.\n                        for (let ci = c1; ci <= c2; ci++) {\n                            grid.resizeColumn(colRegion, ci, null);\n                        }\n                    }\n                    else {\n                        // When we double-click the column header outside the selection, resize only the clicked column.\n                        grid.resizeColumn(colRegion, colIndex, null);\n                    }\n                }\n                else {\n                    // When no columns are selected, resize only the clicked column.\n                    grid.resizeColumn(colRegion, colIndex, null);\n                }\n            }\n        }\n        if (region === 'body') {\n            if (grid.editable) {\n                const cell = {\n                    grid: grid,\n                    row: row,\n                    column: column\n                };\n                grid.editorController.edit(cell);\n            }\n        }\n        this.release();\n    }\n    /**\n     * Handle the context menu event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The context menu event of interest.\n     */\n    onContextMenu(grid, event) {\n        // TODO support user-defined context menus\n    }\n    /**\n     * Handle the wheel event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The wheel event of interest.\n     */\n    onWheel(grid, event) {\n        // Bail if a mouse press is in progress.\n        if (this._pressData) {\n            return;\n        }\n        // Extract the delta X and Y movement.\n        let dx = event.deltaX;\n        let dy = event.deltaY;\n        // Convert the delta values to pixel values.\n        switch (event.deltaMode) {\n            case 0: // DOM_DELTA_PIXEL\n                break;\n            case 1: {\n                // DOM_DELTA_LINE\n                let ds = grid.defaultSizes;\n                dx *= ds.columnWidth;\n                dy *= ds.rowHeight;\n                break;\n            }\n            case 2: // DOM_DELTA_PAGE\n                dx *= grid.pageWidth;\n                dy *= grid.pageHeight;\n                break;\n            default:\n                throw 'unreachable';\n        }\n        // Only scroll and stop the event propagation if needed.\n        if (\n        // Scrolling left and not reached min already\n        (dx < 0 && grid.scrollX !== 0) ||\n            // Scrolling right and not reached max already\n            (dx > 0 && grid.scrollX !== grid.maxScrollX) ||\n            // Scrolling top and not reached min already\n            (dy < 0 && grid.scrollY !== 0) ||\n            // Scrolling down and not reached max already\n            (dy > 0 && grid.scrollY !== grid.maxScrollY)) {\n            event.preventDefault();\n            event.stopPropagation();\n            // Scroll by the desired amount.\n            grid.scrollBy(dx, dy);\n        }\n    }\n    /**\n     * Convert a resize handle into a cursor.\n     */\n    cursorForHandle(handle) {\n        return Private$5.cursorMap[handle];\n    }\n    /**\n     * Get the current pressData\n     */\n    get pressData() {\n        return this._pressData;\n    }\n}\n/**\n * The namespace for the module implementation details.\n */\nvar Private$5;\n(function (Private) {\n    /**\n     * Creates a CellConfig object from a hit region.\n     */\n    function createCellConfigObject(grid, hit) {\n        const { region, row, column } = hit;\n        // Terminate call if region is void.\n        if (region === 'void') {\n            return undefined;\n        }\n        // Augment hit region params with value and metadata.\n        const value = grid.dataModel.data(region, row, column);\n        const metadata = grid.dataModel.metadata(region, row, column);\n        // Create cell config object to retrieve cell renderer.\n        const config = {\n            ...hit,\n            value: value,\n            metadata: metadata\n        };\n        return config;\n    }\n    Private.createCellConfigObject = createCellConfigObject;\n    /**\n     * Get the resize handle for a grid hit test.\n     */\n    function resizeHandleForHitTest(hit) {\n        // Fetch the row and column.\n        let r = hit.row;\n        let c = hit.column;\n        // Fetch the leading and trailing sizes.\n        let lw = hit.x;\n        let lh = hit.y;\n        let tw = hit.width - hit.x;\n        let th = hit.height - hit.y;\n        // Set up the result variable.\n        let result;\n        // Dispatch based on hit test region.\n        switch (hit.region) {\n            case 'corner-header':\n                if (c > 0 && lw <= 5) {\n                    result = 'left';\n                }\n                else if (tw <= 6) {\n                    result = 'right';\n                }\n                else if (r > 0 && lh <= 5) {\n                    result = 'top';\n                }\n                else if (th <= 6) {\n                    result = 'bottom';\n                }\n                else {\n                    result = 'none';\n                }\n                break;\n            case 'column-header':\n                if (c > 0 && lw <= 5) {\n                    result = 'left';\n                }\n                else if (tw <= 6) {\n                    result = 'right';\n                }\n                else if (r > 0 && lh <= 5) {\n                    result = 'top';\n                }\n                else if (th <= 6) {\n                    result = 'bottom';\n                }\n                else {\n                    result = 'none';\n                }\n                break;\n            case 'row-header':\n                if (c > 0 && lw <= 5) {\n                    result = 'left';\n                }\n                else if (tw <= 6) {\n                    result = 'right';\n                }\n                else if (r > 0 && lh <= 5) {\n                    result = 'top';\n                }\n                else if (th <= 6) {\n                    result = 'bottom';\n                }\n                else {\n                    result = 'none';\n                }\n                break;\n            case 'body':\n                result = 'none';\n                break;\n            case 'void':\n                result = 'none';\n                break;\n            default:\n                throw 'unreachable';\n        }\n        // Return the result.\n        return result;\n    }\n    Private.resizeHandleForHitTest = resizeHandleForHitTest;\n    /**\n     * A timer callback for the autoselect loop.\n     *\n     * @param grid - The datagrid of interest.\n     *\n     * @param data - The select data of interest.\n     */\n    function autoselect(grid, data) {\n        // Bail early if the timeout has been reset.\n        if (data.timeout < 0) {\n            return;\n        }\n        // Fetch the selection model.\n        let model = grid.selectionModel;\n        // Bail early if the selection model has been removed.\n        if (!model) {\n            return;\n        }\n        // Fetch the current selection.\n        let cs = model.currentSelection();\n        // Bail early if there is no current selection.\n        if (!cs) {\n            return;\n        }\n        // Fetch local X and Y coordinates of the mouse.\n        let lx = data.localX;\n        let ly = data.localY;\n        // Set up the selection variables.\n        let r1 = cs.r1;\n        let c1 = cs.c1;\n        let r2 = cs.r2;\n        let c2 = cs.c2;\n        let cursorRow = model.cursorRow;\n        let cursorColumn = model.cursorColumn;\n        let clear = 'current';\n        // Fetch the grid geometry.\n        let hw = grid.headerWidth;\n        let hh = grid.headerHeight;\n        let vpw = grid.viewportWidth;\n        let vph = grid.viewportHeight;\n        // Fetch the selection mode.\n        let mode = model.selectionMode;\n        // Update the selection based on the hit region.\n        if (data.region === 'row-header' || mode === 'row') {\n            r2 += ly <= hh ? -1 : ly >= vph ? 1 : 0;\n        }\n        else if (data.region === 'column-header' || mode === 'column') {\n            c2 += lx <= hw ? -1 : lx >= vpw ? 1 : 0;\n        }\n        else {\n            r2 += ly <= hh ? -1 : ly >= vph ? 1 : 0;\n            c2 += lx <= hw ? -1 : lx >= vpw ? 1 : 0;\n        }\n        // Update the current selection.\n        model.select({ r1, c1, r2, c2, cursorRow, cursorColumn, clear });\n        // Re-fetch the current selection.\n        cs = model.currentSelection();\n        // Bail if there is no selection.\n        if (!cs) {\n            return;\n        }\n        // Scroll the grid based on the hit region.\n        if (data.region === 'row-header' || mode === 'row') {\n            grid.scrollToRow(cs.r2);\n        }\n        else if (data.region === 'column-header' || mode == 'column') {\n            grid.scrollToColumn(cs.c2);\n        }\n        else if (mode === 'cell') {\n            grid.scrollToCell(cs.r2, cs.c2);\n        }\n        // Schedule the next call with the current timeout.\n        setTimeout(() => {\n            autoselect(grid, data);\n        }, data.timeout);\n    }\n    Private.autoselect = autoselect;\n    /**\n     * Compute the scroll timeout for the given delta distance.\n     *\n     * @param delta - The delta pixels from the origin.\n     *\n     * @returns The scaled timeout in milliseconds.\n     */\n    function computeTimeout(delta) {\n        return 5 + 120 * (1 - Math.min(128, Math.abs(delta)) / 128);\n    }\n    Private.computeTimeout = computeTimeout;\n    /**\n     * A mapping of resize handle to cursor.\n     */\n    Private.cursorMap = {\n        top: 'ns-resize',\n        left: 'ew-resize',\n        right: 'ew-resize',\n        bottom: 'ns-resize',\n        hyperlink: 'pointer',\n        none: 'default'\n    };\n})(Private$5 || (Private$5 = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * A base class for creating data grid selection models.\n *\n * #### Notes\n * If the predefined selection models are insufficient for a particular\n * use case, a custom model can be defined which derives from this class.\n */\nclass SelectionModel {\n    /**\n     * Construct a new selection model.\n     *\n     * @param options - The options for initializing the model.\n     */\n    constructor(options) {\n        this._changed = new Signal(this);\n        this._selectionMode = 'cell';\n        this.dataModel = options.dataModel;\n        this._selectionMode = options.selectionMode || 'cell';\n        this.dataModel.changed.connect(this.onDataModelChanged, this);\n    }\n    /**\n     * A signal emitted when the selection model has changed.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * Get the selection mode for the model.\n     */\n    get selectionMode() {\n        return this._selectionMode;\n    }\n    /**\n     * Set the selection mode for the model.\n     *\n     * #### Notes\n     * This will clear the selection model.\n     */\n    set selectionMode(value) {\n        // Bail early if the mode does not change.\n        if (this._selectionMode === value) {\n            return;\n        }\n        // Update the internal mode.\n        this._selectionMode = value;\n        // Clear the current selections.\n        this.clear();\n    }\n    /**\n     * Test whether any selection intersects a row.\n     *\n     * @param index - The row index of interest.\n     *\n     * @returns Whether any selection intersects the row.\n     *\n     * #### Notes\n     * This method may be reimplemented in a subclass.\n     */\n    isRowSelected(index) {\n        return some(this.selections(), s => Private$4.containsRow(s, index));\n    }\n    /**\n     * Test whether any selection intersects a column.\n     *\n     * @param index - The column index of interest.\n     *\n     * @returns Whether any selection intersects the column.\n     *\n     * #### Notes\n     * This method may be reimplemented in a subclass.\n     */\n    isColumnSelected(index) {\n        return some(this.selections(), s => Private$4.containsColumn(s, index));\n    }\n    /**\n     * Test whether any selection intersects a cell.\n     *\n     * @param row - The row index of interest.\n     *\n     * @param column - The column index of interest.\n     *\n     * @returns Whether any selection intersects the cell.\n     *\n     * #### Notes\n     * This method may be reimplemented in a subclass.\n     */\n    isCellSelected(row, column) {\n        return some(this.selections(), s => Private$4.containsCell(s, row, column));\n    }\n    /**\n     * A signal handler for the data model `changed` signal.\n     *\n     * @param args - The arguments for the signal.\n     *\n     * #### Notes\n     * Selection model implementations should update their selections\n     * in a manner that is relevant for the changes to the data model.\n     *\n     * The default implementation of this method is a no-op.\n     */\n    onDataModelChanged(sender, args) {\n        // pass\n    }\n    /**\n     * Emit the `changed` signal for the selection model.\n     *\n     * #### Notes\n     * Subclasses should call this method whenever the selection model\n     * has changed so that attached data grids can update themselves.\n     */\n    emitChanged() {\n        this._changed.emit(undefined);\n    }\n}\n/**\n * The namespace for the module implementation details.\n */\nvar Private$4;\n(function (Private) {\n    /**\n     * Test whether a selection contains a given row.\n     */\n    function containsRow(selection, row) {\n        let { r1, r2 } = selection;\n        return (row >= r1 && row <= r2) || (row >= r2 && row <= r1);\n    }\n    Private.containsRow = containsRow;\n    /**\n     * Test whether a selection contains a given column.\n     */\n    function containsColumn(selection, column) {\n        let { c1, c2 } = selection;\n        return (column >= c1 && column <= c2) || (column >= c2 && column <= c1);\n    }\n    Private.containsColumn = containsColumn;\n    /**\n     * Test whether a selection contains a given cell.\n     */\n    function containsCell(selection, row, column) {\n        return containsRow(selection, row) && containsColumn(selection, column);\n    }\n    Private.containsCell = containsCell;\n})(Private$4 || (Private$4 = {}));\n\n/**\n * A basic selection model implementation.\n *\n * #### Notes\n * This selection model is sufficient for most use cases where\n * structural knowledge of the data source is *not* required.\n */\nclass BasicSelectionModel extends SelectionModel {\n    constructor() {\n        super(...arguments);\n        this._cursorRow = -1;\n        this._cursorColumn = -1;\n        this._cursorRectIndex = -1;\n        this._selections = [];\n    }\n    /**\n     * Whether the selection model is empty.\n     */\n    get isEmpty() {\n        return this._selections.length === 0;\n    }\n    /**\n     * The row index of the cursor.\n     */\n    get cursorRow() {\n        return this._cursorRow;\n    }\n    /**\n     * The column index of the cursor.\n     */\n    get cursorColumn() {\n        return this._cursorColumn;\n    }\n    /**\n     * Move cursor down/up/left/right while making sure it remains\n     * within the bounds of selected rectangles\n     *\n     * @param direction - The direction of the movement.\n     */\n    moveCursorWithinSelections(direction) {\n        // Bail early if there are no selections or no existing cursor\n        if (this.isEmpty || this.cursorRow === -1 || this._cursorColumn === -1) {\n            return;\n        }\n        // Bail early if only single cell is selected\n        const firstSelection = this._selections[0];\n        if (this._selections.length === 1 &&\n            firstSelection.r1 === firstSelection.r2 &&\n            firstSelection.c1 === firstSelection.c2) {\n            return;\n        }\n        // start from last selection rectangle\n        if (this._cursorRectIndex === -1) {\n            this._cursorRectIndex = this._selections.length - 1;\n        }\n        let cursorRect = this._selections[this._cursorRectIndex];\n        const dr = direction === 'down' ? 1 : direction === 'up' ? -1 : 0;\n        const dc = direction === 'right' ? 1 : direction === 'left' ? -1 : 0;\n        let newRow = this._cursorRow + dr;\n        let newColumn = this._cursorColumn + dc;\n        const r1 = Math.min(cursorRect.r1, cursorRect.r2);\n        const r2 = Math.max(cursorRect.r1, cursorRect.r2);\n        const c1 = Math.min(cursorRect.c1, cursorRect.c2);\n        const c2 = Math.max(cursorRect.c1, cursorRect.c2);\n        const moveToNextRect = () => {\n            this._cursorRectIndex =\n                (this._cursorRectIndex + 1) % this._selections.length;\n            cursorRect = this._selections[this._cursorRectIndex];\n            newRow = Math.min(cursorRect.r1, cursorRect.r2);\n            newColumn = Math.min(cursorRect.c1, cursorRect.c2);\n        };\n        const moveToPreviousRect = () => {\n            this._cursorRectIndex =\n                this._cursorRectIndex === 0\n                    ? this._selections.length - 1\n                    : this._cursorRectIndex - 1;\n            cursorRect = this._selections[this._cursorRectIndex];\n            newRow = Math.max(cursorRect.r1, cursorRect.r2);\n            newColumn = Math.max(cursorRect.c1, cursorRect.c2);\n        };\n        if (newRow > r2) {\n            newRow = r1;\n            newColumn += 1;\n            if (newColumn > c2) {\n                moveToNextRect();\n            }\n        }\n        else if (newRow < r1) {\n            newRow = r2;\n            newColumn -= 1;\n            if (newColumn < c1) {\n                moveToPreviousRect();\n            }\n        }\n        else if (newColumn > c2) {\n            newColumn = c1;\n            newRow += 1;\n            if (newRow > r2) {\n                moveToNextRect();\n            }\n        }\n        else if (newColumn < c1) {\n            newColumn = c2;\n            newRow -= 1;\n            if (newRow < r1) {\n                moveToPreviousRect();\n            }\n        }\n        this._cursorRow = newRow;\n        this._cursorColumn = newColumn;\n        // Emit the changed signal.\n        this.emitChanged();\n    }\n    /**\n     * Get the current selection in the selection model.\n     *\n     * @returns The current selection or `null`.\n     *\n     * #### Notes\n     * This is the selection which holds the cursor.\n     */\n    currentSelection() {\n        return this._selections[this._selections.length - 1] || null;\n    }\n    /**\n     * Get an iterator of the selections in the model.\n     *\n     * @returns A new iterator of the current selections.\n     *\n     * #### Notes\n     * The data grid will render the selections in order.\n     */\n    *selections() {\n        yield* this._selections;\n    }\n    /**\n     * Select the specified cells.\n     *\n     * @param args - The arguments for the selection.\n     */\n    select(args) {\n        // Fetch the current row and column counts;\n        let rowCount = this.dataModel.rowCount('body');\n        let columnCount = this.dataModel.columnCount('body');\n        // Bail early if there is no content.\n        if (rowCount <= 0 || columnCount <= 0) {\n            return;\n        }\n        // Unpack the arguments.\n        let { r1, c1, r2, c2, cursorRow, cursorColumn, clear } = args;\n        // Clear the necessary selections.\n        if (clear === 'all') {\n            this._selections.length = 0;\n        }\n        else if (clear === 'current') {\n            this._selections.pop();\n        }\n        // Clamp to the data model bounds.\n        r1 = Math.max(0, Math.min(r1, rowCount - 1));\n        r2 = Math.max(0, Math.min(r2, rowCount - 1));\n        c1 = Math.max(0, Math.min(c1, columnCount - 1));\n        c2 = Math.max(0, Math.min(c2, columnCount - 1));\n        // Indicate if a row/column has already been selected.\n        let alreadySelected = false;\n        // Handle the selection mode.\n        if (this.selectionMode === 'row') {\n            c1 = 0;\n            c2 = columnCount - 1;\n            alreadySelected =\n                this._selections.filter(selection => selection.r1 === r1).length !== 0;\n            // Remove from selections if already selected.\n            this._selections = alreadySelected\n                ? this._selections.filter(selection => selection.r1 !== r1)\n                : this._selections;\n        }\n        else if (this.selectionMode === 'column') {\n            r1 = 0;\n            r2 = rowCount - 1;\n            alreadySelected =\n                this._selections.filter(selection => selection.c1 === c1).length !== 0;\n            // Remove from selections if already selected.\n            this._selections = alreadySelected\n                ? this._selections.filter(selection => selection.c1 !== c1)\n                : this._selections;\n        }\n        // Alias the cursor row and column.\n        let cr = cursorRow;\n        let cc = cursorColumn;\n        // Compute the new cursor location.\n        if (cr < 0 || (cr < r1 && cr < r2) || (cr > r1 && cr > r2)) {\n            cr = r1;\n        }\n        if (cc < 0 || (cc < c1 && cc < c2) || (cc > c1 && cc > c2)) {\n            cc = c1;\n        }\n        // Update the cursor.\n        this._cursorRow = cr;\n        this._cursorColumn = cc;\n        this._cursorRectIndex = this._selections.length;\n        // Add the new selection if it wasn't already selected.\n        if (!alreadySelected) {\n            this._selections.push({ r1, c1, r2, c2 });\n        }\n        // Emit the changed signal.\n        this.emitChanged();\n    }\n    /**\n     * Clear all selections in the selection model.\n     */\n    clear() {\n        // Bail early if there are no selections.\n        if (this._selections.length === 0) {\n            return;\n        }\n        // Reset the internal state.\n        this._cursorRow = -1;\n        this._cursorColumn = -1;\n        this._cursorRectIndex = -1;\n        this._selections.length = 0;\n        // Emit the changed signal.\n        this.emitChanged();\n    }\n    /**\n     * A signal handler for the data model `changed` signal.\n     *\n     * @param args - The arguments for the signal.\n     */\n    onDataModelChanged(sender, args) {\n        // Bail early if the model has no current selections.\n        if (this._selections.length === 0) {\n            return;\n        }\n        // Bail early if the cells have changed in place.\n        if (args.type === 'cells-changed') {\n            return;\n        }\n        // Bail early if there is no change to the row or column count.\n        if (args.type === 'rows-moved' || args.type === 'columns-moved') {\n            return;\n        }\n        // Fetch the last row and column index.\n        let lr = sender.rowCount('body') - 1;\n        let lc = sender.columnCount('body') - 1;\n        // Bail early if the data model is empty.\n        if (lr < 0 || lc < 0) {\n            this._selections.length = 0;\n            this.emitChanged();\n            return;\n        }\n        // Fetch the selection mode.\n        let mode = this.selectionMode;\n        // Set up the assignment index variable.\n        let j = 0;\n        // Iterate over the current selections.\n        for (let i = 0, n = this._selections.length; i < n; ++i) {\n            // Unpack the selection.\n            let { r1, c1, r2, c2 } = this._selections[i];\n            // Skip the selection if it will disappear.\n            if ((lr < r1 && lr < r2) || (lc < c1 && lc < c2)) {\n                continue;\n            }\n            // Modify the bounds based on the selection mode.\n            if (mode === 'row') {\n                r1 = Math.max(0, Math.min(r1, lr));\n                r2 = Math.max(0, Math.min(r2, lr));\n                c1 = 0;\n                c2 = lc;\n            }\n            else if (mode === 'column') {\n                r1 = 0;\n                r2 = lr;\n                c1 = Math.max(0, Math.min(c1, lc));\n                c2 = Math.max(0, Math.min(c2, lc));\n            }\n            else {\n                r1 = Math.max(0, Math.min(r1, lr));\n                r2 = Math.max(0, Math.min(r2, lr));\n                c1 = Math.max(0, Math.min(c1, lc));\n                c2 = Math.max(0, Math.min(c2, lc));\n            }\n            // Assign the modified selection to the array.\n            this._selections[j++] = { r1, c1, r2, c2 };\n        }\n        // Remove the stale selections.\n        this._selections.length = j;\n        // Emit the changed signal.\n        this.emitChanged();\n    }\n}\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2023, Lumino Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * An object which renders the cells of a data grid asynchronously.\n *\n * #### Notes\n * For performance reason, the datagrid only paints cells synchronously,\n * though if your cell renderer inherits from AsyncCellRenderer, you will\n * be able to do some asynchronous work prior to painting the cell.\n * See `ImageRenderer` for an example of an asynchronous renderer.\n */\nclass AsyncCellRenderer extends CellRenderer {\n}\n\n/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\n// default validation error message\nconst DEFAULT_INVALID_INPUT_MESSAGE = 'Invalid input!';\n/**\n * A cell input validator object which always returns valid.\n */\nclass PassInputValidator {\n    /**\n     * Validate cell input.\n     *\n     * @param cell - The object holding cell configuration data.\n     *\n     * @param value - The cell value input.\n     *\n     * @returns An object with validation result.\n     */\n    validate(cell, value) {\n        return { valid: true };\n    }\n}\n/**\n * Text cell input validator.\n */\nclass TextInputValidator {\n    constructor() {\n        /**\n         * Minimum text length\n         *\n         * The default is Number.NaN, meaning no minimum constraint\n         */\n        this.minLength = Number.NaN;\n        /**\n         * Maximum text length\n         *\n         * The default is Number.NaN, meaning no maximum constraint\n         */\n        this.maxLength = Number.NaN;\n        /**\n         * Required text pattern as regular expression\n         *\n         * The default is null, meaning no pattern constraint\n         */\n        this.pattern = null;\n    }\n    /**\n     * Validate cell input.\n     *\n     * @param cell - The object holding cell configuration data.\n     *\n     * @param value - The cell value input.\n     *\n     * @returns An object with validation result.\n     */\n    validate(cell, value) {\n        if (value === null) {\n            return { valid: true };\n        }\n        if (typeof value !== 'string') {\n            return {\n                valid: false,\n                message: 'Input must be valid text'\n            };\n        }\n        if (!isNaN(this.minLength) && value.length < this.minLength) {\n            return {\n                valid: false,\n                message: `Text length must be greater than ${this.minLength}`\n            };\n        }\n        if (!isNaN(this.maxLength) && value.length > this.maxLength) {\n            return {\n                valid: false,\n                message: `Text length must be less than ${this.maxLength}`\n            };\n        }\n        if (this.pattern && !this.pattern.test(value)) {\n            return {\n                valid: false,\n                message: `Text doesn't match the required pattern`\n            };\n        }\n        return { valid: true };\n    }\n}\n/**\n * Integer cell input validator.\n */\nclass IntegerInputValidator {\n    constructor() {\n        /**\n         * Minimum value\n         *\n         * The default is Number.NaN, meaning no minimum constraint\n         */\n        this.min = Number.NaN;\n        /**\n         * Maximum value\n         *\n         * The default is Number.NaN, meaning no maximum constraint\n         */\n        this.max = Number.NaN;\n    }\n    /**\n     * Validate cell input.\n     *\n     * @param cell - The object holding cell configuration data.\n     *\n     * @param value - The cell value input.\n     *\n     * @returns An object with validation result.\n     */\n    validate(cell, value) {\n        if (value === null) {\n            return { valid: true };\n        }\n        if (isNaN(value) || value % 1 !== 0) {\n            return {\n                valid: false,\n                message: 'Input must be valid integer'\n            };\n        }\n        if (!isNaN(this.min) && value < this.min) {\n            return {\n                valid: false,\n                message: `Input must be greater than ${this.min}`\n            };\n        }\n        if (!isNaN(this.max) && value > this.max) {\n            return {\n                valid: false,\n                message: `Input must be less than ${this.max}`\n            };\n        }\n        return { valid: true };\n    }\n}\n/**\n * Real number cell input validator.\n */\nclass NumberInputValidator {\n    constructor() {\n        /**\n         * Minimum value\n         *\n         * The default is Number.NaN, meaning no minimum constraint\n         */\n        this.min = Number.NaN;\n        /**\n         * Maximum value\n         *\n         * The default is Number.NaN, meaning no maximum constraint\n         */\n        this.max = Number.NaN;\n    }\n    /**\n     * Validate cell input.\n     *\n     * @param cell - The object holding cell configuration data.\n     *\n     * @param value - The cell value input.\n     *\n     * @returns An object with validation result.\n     */\n    validate(cell, value) {\n        if (value === null) {\n            return { valid: true };\n        }\n        if (isNaN(value)) {\n            return {\n                valid: false,\n                message: 'Input must be valid number'\n            };\n        }\n        if (!isNaN(this.min) && value < this.min) {\n            return {\n                valid: false,\n                message: `Input must be greater than ${this.min}`\n            };\n        }\n        if (!isNaN(this.max) && value > this.max) {\n            return {\n                valid: false,\n                message: `Input must be less than ${this.max}`\n            };\n        }\n        return { valid: true };\n    }\n}\n/**\n * An abstract base class that provides the most of the functionality\n * needed by a cell editor. All of the built-in cell editors\n * for various cell types are derived from this base class. Custom cell editors\n * can be easily implemented by extending this class.\n */\nclass CellEditor {\n    /**\n     * Construct a new cell editor.\n     */\n    constructor() {\n        /**\n         * A signal emitted when input changes.\n         */\n        this.inputChanged = new Signal(this);\n        /**\n         * Notification popup used to show validation error messages.\n         */\n        this.validityNotification = null;\n        /**\n         * Whether the cell editor is disposed.\n         */\n        this._disposed = false;\n        /**\n         * Whether the value input is valid.\n         */\n        this._validInput = true;\n        /**\n         * Grid wheel event handler.\n         */\n        this._gridWheelEventHandler = null;\n        this.inputChanged.connect(() => {\n            this.validate();\n        });\n    }\n    /**\n     * Whether the cell editor is disposed.\n     */\n    get isDisposed() {\n        return this._disposed;\n    }\n    /**\n     * Dispose of the resources held by cell editor.\n     */\n    dispose() {\n        if (this._disposed) {\n            return;\n        }\n        if (this._gridWheelEventHandler) {\n            this.cell.grid.node.removeEventListener('wheel', this._gridWheelEventHandler);\n            this._gridWheelEventHandler = null;\n        }\n        this._closeValidityNotification();\n        this._disposed = true;\n        this.cell.grid.node.removeChild(this.viewportOccluder);\n    }\n    /**\n     * Start editing the cell.\n     *\n     * @param cell - The object holding cell configuration data.\n     *\n     * @param options - The cell editing options.\n     */\n    edit(cell, options) {\n        this.cell = cell;\n        this.onCommit = options && options.onCommit;\n        this.onCancel = options && options.onCancel;\n        this.validator =\n            options && options.validator\n                ? options.validator\n                : this.createValidatorBasedOnType();\n        this._gridWheelEventHandler = () => {\n            this._closeValidityNotification();\n            this.updatePosition();\n        };\n        cell.grid.node.addEventListener('wheel', this._gridWheelEventHandler);\n        this._addContainer();\n        this.updatePosition();\n        this.startEditing();\n    }\n    /**\n     * Cancel editing the cell.\n     */\n    cancel() {\n        if (this._disposed) {\n            return;\n        }\n        this.dispose();\n        if (this.onCancel) {\n            this.onCancel();\n        }\n    }\n    /**\n     * Whether the value input is valid.\n     */\n    get validInput() {\n        return this._validInput;\n    }\n    /**\n     * Validate the cell input. Shows validation error notification when input is invalid.\n     */\n    validate() {\n        let value;\n        try {\n            value = this.getInput();\n        }\n        catch (error) {\n            console.log(`Input error: ${error.message}`);\n            this.setValidity(false, error.message || DEFAULT_INVALID_INPUT_MESSAGE);\n            return;\n        }\n        if (this.validator) {\n            const result = this.validator.validate(this.cell, value);\n            if (result.valid) {\n                this.setValidity(true);\n            }\n            else {\n                this.setValidity(false, result.message || DEFAULT_INVALID_INPUT_MESSAGE);\n            }\n        }\n        else {\n            this.setValidity(true);\n        }\n    }\n    /**\n     * Set validity flag.\n     *\n     * @param valid - Whether the input is valid.\n     *\n     * @param message - Notification message to show.\n     *\n     * If message is set to empty string (which is the default)\n     * existing notification popup is removed if any.\n     */\n    setValidity(valid, message = '') {\n        this._validInput = valid;\n        this._closeValidityNotification();\n        if (valid) {\n            this.editorContainer.classList.remove('lm-mod-invalid');\n        }\n        else {\n            this.editorContainer.classList.add('lm-mod-invalid');\n            // show a notification popup\n            if (message !== '') {\n                this.validityNotification = new CellEditor.Notification({\n                    target: this.editorContainer,\n                    message: message,\n                    placement: 'bottom',\n                    timeout: 5000\n                });\n                this.validityNotification.show();\n            }\n        }\n    }\n    /**\n     * Create and return a cell input validator based on configuration of the\n     * cell being edited. If no suitable validator can be found, it returns undefined.\n     */\n    createValidatorBasedOnType() {\n        const cell = this.cell;\n        const metadata = cell.grid.dataModel.metadata('body', cell.row, cell.column);\n        switch (metadata && metadata.type) {\n            case 'string':\n                {\n                    const validator = new TextInputValidator();\n                    if (typeof metadata.format === 'string') {\n                        const format = metadata.format;\n                        switch (format) {\n                            case 'email':\n                                validator.pattern = new RegExp('^([a-z0-9_.-]+)@([da-z.-]+).([a-z.]{2,6})$');\n                                break;\n                            case 'uuid':\n                                validator.pattern = new RegExp('[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}');\n                                break;\n                        }\n                    }\n                    if (metadata.constraint) {\n                        if (metadata.constraint.minLength !== undefined) {\n                            validator.minLength = metadata.constraint.minLength;\n                        }\n                        if (metadata.constraint.maxLength !== undefined) {\n                            validator.maxLength = metadata.constraint.maxLength;\n                        }\n                        if (typeof metadata.constraint.pattern === 'string') {\n                            validator.pattern = new RegExp(metadata.constraint.pattern);\n                        }\n                    }\n                    return validator;\n                }\n            case 'number':\n                {\n                    const validator = new NumberInputValidator();\n                    if (metadata.constraint) {\n                        if (metadata.constraint.minimum !== undefined) {\n                            validator.min = metadata.constraint.minimum;\n                        }\n                        if (metadata.constraint.maximum !== undefined) {\n                            validator.max = metadata.constraint.maximum;\n                        }\n                    }\n                    return validator;\n                }\n            case 'integer':\n                {\n                    const validator = new IntegerInputValidator();\n                    if (metadata.constraint) {\n                        if (metadata.constraint.minimum !== undefined) {\n                            validator.min = metadata.constraint.minimum;\n                        }\n                        if (metadata.constraint.maximum !== undefined) {\n                            validator.max = metadata.constraint.maximum;\n                        }\n                    }\n                    return validator;\n                }\n        }\n        return undefined;\n    }\n    /**\n     * Compute cell rectangle and return with other cell properties.\n     */\n    getCellInfo(cell) {\n        const { grid, row, column } = cell;\n        let data, columnX, rowY, width, height;\n        const cellGroup = CellGroup.getGroup(grid.dataModel, 'body', row, column);\n        if (cellGroup) {\n            columnX =\n                grid.headerWidth -\n                    grid.scrollX +\n                    grid.columnOffset('body', cellGroup.c1);\n            rowY =\n                grid.headerHeight - grid.scrollY + grid.rowOffset('body', cellGroup.r1);\n            width = 0;\n            height = 0;\n            for (let r = cellGroup.r1; r <= cellGroup.r2; r++) {\n                height += grid.rowSize('body', r);\n            }\n            for (let c = cellGroup.c1; c <= cellGroup.c2; c++) {\n                width += grid.columnSize('body', c);\n            }\n            data = grid.dataModel.data('body', cellGroup.r1, cellGroup.c1);\n        }\n        else {\n            columnX =\n                grid.headerWidth - grid.scrollX + grid.columnOffset('body', column);\n            rowY = grid.headerHeight - grid.scrollY + grid.rowOffset('body', row);\n            width = grid.columnSize('body', column);\n            height = grid.rowSize('body', row);\n            data = grid.dataModel.data('body', row, column);\n        }\n        return {\n            grid: grid,\n            row: row,\n            column: column,\n            data: data,\n            x: columnX,\n            y: rowY,\n            width: width,\n            height: height\n        };\n    }\n    /**\n     * Reposition cell editor by moving viewport occluder and cell editor container.\n     */\n    updatePosition() {\n        const grid = this.cell.grid;\n        const cellInfo = this.getCellInfo(this.cell);\n        const headerHeight = grid.headerHeight;\n        const headerWidth = grid.headerWidth;\n        this.viewportOccluder.style.top = headerHeight + 'px';\n        this.viewportOccluder.style.left = headerWidth + 'px';\n        this.viewportOccluder.style.width = grid.viewportWidth - headerWidth + 'px';\n        this.viewportOccluder.style.height =\n            grid.viewportHeight - headerHeight + 'px';\n        this.viewportOccluder.style.position = 'absolute';\n        this.editorContainer.style.left = cellInfo.x - 1 - headerWidth + 'px';\n        this.editorContainer.style.top = cellInfo.y - 1 - headerHeight + 'px';\n        this.editorContainer.style.width = cellInfo.width + 1 + 'px';\n        this.editorContainer.style.height = cellInfo.height + 1 + 'px';\n        this.editorContainer.style.visibility = 'visible';\n        this.editorContainer.style.position = 'absolute';\n    }\n    /**\n     * Commit the edited value.\n     *\n     * @param cursorMovement - Cursor move direction based on keys pressed to end the edit.\n     *\n     * @returns true on valid input, false otherwise.\n     */\n    commit(cursorMovement = 'none') {\n        this.validate();\n        if (!this._validInput) {\n            return false;\n        }\n        let value;\n        try {\n            value = this.getInput();\n        }\n        catch (error) {\n            console.log(`Input error: ${error.message}`);\n            return false;\n        }\n        this.dispose();\n        if (this.onCommit) {\n            this.onCommit({\n                cell: this.cell,\n                value: value,\n                cursorMovement: cursorMovement\n            });\n        }\n        return true;\n    }\n    /**\n     * Create container elements needed to prevent editor widget overflow\n     * beyond viewport and to position cell editor widget.\n     */\n    _addContainer() {\n        this.viewportOccluder = document.createElement('div');\n        this.viewportOccluder.className = 'lm-DataGrid-cellEditorOccluder';\n        this.cell.grid.node.appendChild(this.viewportOccluder);\n        this.editorContainer = document.createElement('div');\n        this.editorContainer.className = 'lm-DataGrid-cellEditorContainer';\n        this.viewportOccluder.appendChild(this.editorContainer);\n        // update mouse event pass-through state based on input validity\n        this.editorContainer.addEventListener('mouseleave', (event) => {\n            this.viewportOccluder.style.pointerEvents = this._validInput\n                ? 'none'\n                : 'auto';\n        });\n        this.editorContainer.addEventListener('mouseenter', (event) => {\n            this.viewportOccluder.style.pointerEvents = 'none';\n        });\n    }\n    /**\n     * Remove validity notification popup.\n     */\n    _closeValidityNotification() {\n        if (this.validityNotification) {\n            this.validityNotification.close();\n            this.validityNotification = null;\n        }\n    }\n}\n/**\n * Abstract base class with shared functionality\n * for cell editors which use HTML Input widget as editor.\n */\nclass InputCellEditor extends CellEditor {\n    /**\n     * Handle the DOM events for the editor.\n     *\n     * @param event - The DOM event sent to the editor.\n     */\n    handleEvent(event) {\n        switch (event.type) {\n            case 'keydown':\n                this._onKeyDown(event);\n                break;\n            case 'blur':\n                this._onBlur(event);\n                break;\n            case 'input':\n                this._onInput(event);\n                break;\n        }\n    }\n    /**\n     * Dispose of the resources held by cell editor.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._unbindEvents();\n        super.dispose();\n    }\n    /**\n     * Start editing the cell.\n     */\n    startEditing() {\n        this.createWidget();\n        const cell = this.cell;\n        const cellInfo = this.getCellInfo(cell);\n        this.input.value = this.deserialize(cellInfo.data);\n        this.editorContainer.appendChild(this.input);\n        this.input.focus();\n        this.input.select();\n        this.bindEvents();\n    }\n    deserialize(value) {\n        if (value === null || value === undefined) {\n            return '';\n        }\n        return value.toString();\n    }\n    createWidget() {\n        const input = document.createElement('input');\n        input.classList.add('lm-DataGrid-cellEditorWidget');\n        input.classList.add('lm-DataGrid-cellEditorInput');\n        input.spellcheck = false;\n        input.type = this.inputType;\n        this.input = input;\n    }\n    bindEvents() {\n        this.input.addEventListener('keydown', this);\n        this.input.addEventListener('blur', this);\n        this.input.addEventListener('input', this);\n    }\n    _unbindEvents() {\n        this.input.removeEventListener('keydown', this);\n        this.input.removeEventListener('blur', this);\n        this.input.removeEventListener('input', this);\n    }\n    _onKeyDown(event) {\n        switch (getKeyboardLayout().keyForKeydownEvent(event)) {\n            case 'Enter':\n                this.commit(event.shiftKey ? 'up' : 'down');\n                break;\n            case 'Tab':\n                this.commit(event.shiftKey ? 'left' : 'right');\n                event.stopPropagation();\n                event.preventDefault();\n                break;\n            case 'Escape':\n                this.cancel();\n                break;\n        }\n    }\n    _onBlur(event) {\n        if (this.isDisposed) {\n            return;\n        }\n        if (!this.commit()) {\n            event.preventDefault();\n            event.stopPropagation();\n            this.input.focus();\n        }\n    }\n    _onInput(event) {\n        this.inputChanged.emit(void 0);\n    }\n}\n/**\n * Cell editor for text cells.\n */\nclass TextCellEditor extends InputCellEditor {\n    constructor() {\n        super(...arguments);\n        this.inputType = 'text';\n    }\n    /**\n     * Return the current text input entered.\n     */\n    getInput() {\n        return this.input.value;\n    }\n}\n/**\n * Cell editor for real number cells.\n */\nclass NumberCellEditor extends InputCellEditor {\n    constructor() {\n        super(...arguments);\n        this.inputType = 'number';\n    }\n    /**\n     * Start editing the cell.\n     */\n    startEditing() {\n        super.startEditing();\n        this.input.step = 'any';\n        const cell = this.cell;\n        const metadata = cell.grid.dataModel.metadata('body', cell.row, cell.column);\n        const constraint = metadata.constraint;\n        if (constraint) {\n            if (constraint.minimum) {\n                this.input.min = constraint.minimum;\n            }\n            if (constraint.maximum) {\n                this.input.max = constraint.maximum;\n            }\n        }\n    }\n    /**\n     * Return the current number input entered. This method throws exception\n     * if input is invalid.\n     */\n    getInput() {\n        let value = this.input.value;\n        if (value.trim() === '') {\n            return null;\n        }\n        const floatValue = parseFloat(value);\n        if (isNaN(floatValue)) {\n            throw new Error('Invalid input');\n        }\n        return floatValue;\n    }\n}\n/**\n * Cell editor for integer cells.\n */\nclass IntegerCellEditor extends InputCellEditor {\n    constructor() {\n        super(...arguments);\n        this.inputType = 'number';\n    }\n    /**\n     * Start editing the cell.\n     */\n    startEditing() {\n        super.startEditing();\n        this.input.step = '1';\n        const cell = this.cell;\n        const metadata = cell.grid.dataModel.metadata('body', cell.row, cell.column);\n        const constraint = metadata.constraint;\n        if (constraint) {\n            if (constraint.minimum) {\n                this.input.min = constraint.minimum;\n            }\n            if (constraint.maximum) {\n                this.input.max = constraint.maximum;\n            }\n        }\n    }\n    /**\n     * Return the current integer input entered. This method throws exception\n     * if input is invalid.\n     */\n    getInput() {\n        let value = this.input.value;\n        if (value.trim() === '') {\n            return null;\n        }\n        let intValue = parseInt(value);\n        if (isNaN(intValue)) {\n            throw new Error('Invalid input');\n        }\n        return intValue;\n    }\n}\n/**\n * Cell editor for date cells.\n */\nclass DateCellEditor extends CellEditor {\n    /**\n     * Handle the DOM events for the editor.\n     *\n     * @param event - The DOM event sent to the editor.\n     */\n    handleEvent(event) {\n        switch (event.type) {\n            case 'keydown':\n                this._onKeyDown(event);\n                break;\n            case 'blur':\n                this._onBlur(event);\n                break;\n        }\n    }\n    /**\n     * Dispose of the resources held by cell editor.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._unbindEvents();\n        super.dispose();\n    }\n    /**\n     * Start editing the cell.\n     */\n    startEditing() {\n        this._createWidget();\n        const cell = this.cell;\n        const cellInfo = this.getCellInfo(cell);\n        this._input.value = this._deserialize(cellInfo.data);\n        this.editorContainer.appendChild(this._input);\n        this._input.focus();\n        this._bindEvents();\n    }\n    /**\n     * Return the current date input entered.\n     */\n    getInput() {\n        return this._input.value;\n    }\n    _deserialize(value) {\n        if (value === null || value === undefined) {\n            return '';\n        }\n        return value.toString();\n    }\n    _createWidget() {\n        const input = document.createElement('input');\n        input.type = 'date';\n        input.pattern = 'd{4}-d{2}-d{2}';\n        input.classList.add('lm-DataGrid-cellEditorWidget');\n        input.classList.add('lm-DataGrid-cellEditorInput');\n        this._input = input;\n    }\n    _bindEvents() {\n        this._input.addEventListener('keydown', this);\n        this._input.addEventListener('blur', this);\n    }\n    _unbindEvents() {\n        this._input.removeEventListener('keydown', this);\n        this._input.removeEventListener('blur', this);\n    }\n    _onKeyDown(event) {\n        switch (getKeyboardLayout().keyForKeydownEvent(event)) {\n            case 'Enter':\n                this.commit(event.shiftKey ? 'up' : 'down');\n                break;\n            case 'Tab':\n                this.commit(event.shiftKey ? 'left' : 'right');\n                event.stopPropagation();\n                event.preventDefault();\n                break;\n            case 'Escape':\n                this.cancel();\n                break;\n        }\n    }\n    _onBlur(event) {\n        if (this.isDisposed) {\n            return;\n        }\n        if (!this.commit()) {\n            event.preventDefault();\n            event.stopPropagation();\n            this._input.focus();\n        }\n    }\n}\n/**\n * Cell editor for boolean cells.\n */\nclass BooleanCellEditor extends CellEditor {\n    /**\n     * Handle the DOM events for the editor.\n     *\n     * @param event - The DOM event sent to the editor.\n     */\n    handleEvent(event) {\n        switch (event.type) {\n            case 'keydown':\n                this._onKeyDown(event);\n                break;\n            case 'mousedown':\n                // fix focus loss problem in Safari and Firefox\n                this._input.focus();\n                event.stopPropagation();\n                event.preventDefault();\n                break;\n            case 'blur':\n                this._onBlur(event);\n                break;\n        }\n    }\n    /**\n     * Dispose of the resources held by cell editor.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._unbindEvents();\n        super.dispose();\n    }\n    /**\n     * Start editing the cell.\n     */\n    startEditing() {\n        this._createWidget();\n        const cell = this.cell;\n        const cellInfo = this.getCellInfo(cell);\n        this._input.checked = this._deserialize(cellInfo.data);\n        this.editorContainer.appendChild(this._input);\n        this._input.focus();\n        this._bindEvents();\n    }\n    /**\n     * Return the current boolean input entered.\n     */\n    getInput() {\n        return this._input.checked;\n    }\n    _deserialize(value) {\n        if (value === null || value === undefined) {\n            return false;\n        }\n        return value == true;\n    }\n    _createWidget() {\n        const input = document.createElement('input');\n        input.classList.add('lm-DataGrid-cellEditorWidget');\n        input.classList.add('lm-DataGrid-cellEditorCheckbox');\n        input.type = 'checkbox';\n        input.spellcheck = false;\n        this._input = input;\n    }\n    _bindEvents() {\n        this._input.addEventListener('keydown', this);\n        this._input.addEventListener('mousedown', this);\n        this._input.addEventListener('blur', this);\n    }\n    _unbindEvents() {\n        this._input.removeEventListener('keydown', this);\n        this._input.removeEventListener('mousedown', this);\n        this._input.removeEventListener('blur', this);\n    }\n    _onKeyDown(event) {\n        switch (getKeyboardLayout().keyForKeydownEvent(event)) {\n            case 'Enter':\n                this.commit(event.shiftKey ? 'up' : 'down');\n                break;\n            case 'Tab':\n                this.commit(event.shiftKey ? 'left' : 'right');\n                event.stopPropagation();\n                event.preventDefault();\n                break;\n            case 'Escape':\n                this.cancel();\n                break;\n        }\n    }\n    _onBlur(event) {\n        if (this.isDisposed) {\n            return;\n        }\n        if (!this.commit()) {\n            event.preventDefault();\n            event.stopPropagation();\n            this._input.focus();\n        }\n    }\n}\n/**\n * Cell editor for option cells.\n *\n * It supports multiple option selection. If cell metadata contains\n * type attribute 'array', then it behaves as a multi select.\n * In that case cell data is expected to be list of string values.\n */\nclass OptionCellEditor extends CellEditor {\n    constructor() {\n        super(...arguments);\n        this._isMultiSelect = false;\n    }\n    /**\n     * Dispose of the resources held by cell editor.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        super.dispose();\n        if (this._isMultiSelect) {\n            document.body.removeChild(this._select);\n        }\n    }\n    /**\n     * Start editing the cell.\n     */\n    startEditing() {\n        const cell = this.cell;\n        const cellInfo = this.getCellInfo(cell);\n        const metadata = cell.grid.dataModel.metadata('body', cell.row, cell.column);\n        this._isMultiSelect = metadata.type === 'array';\n        this._createWidget();\n        if (this._isMultiSelect) {\n            this._select.multiple = true;\n            const values = this._deserialize(cellInfo.data);\n            for (let i = 0; i < this._select.options.length; ++i) {\n                const option = this._select.options.item(i);\n                option.selected = values.indexOf(option.value) !== -1;\n            }\n            document.body.appendChild(this._select);\n        }\n        else {\n            this._select.value = this._deserialize(cellInfo.data);\n            this.editorContainer.appendChild(this._select);\n        }\n        this._select.focus();\n        this._bindEvents();\n        this.updatePosition();\n    }\n    /**\n     * Return the current option input.\n     */\n    getInput() {\n        if (this._isMultiSelect) {\n            const input = [];\n            for (let i = 0; i < this._select.selectedOptions.length; ++i) {\n                input.push(this._select.selectedOptions.item(i).value);\n            }\n            return input;\n        }\n        else {\n            return this._select.value;\n        }\n    }\n    /**\n     * Reposition cell editor.\n     */\n    updatePosition() {\n        super.updatePosition();\n        if (!this._isMultiSelect) {\n            return;\n        }\n        const cellInfo = this.getCellInfo(this.cell);\n        this._select.style.position = 'absolute';\n        const editorContainerRect = this.editorContainer.getBoundingClientRect();\n        this._select.style.left = editorContainerRect.left + 'px';\n        this._select.style.top = editorContainerRect.top + cellInfo.height + 'px';\n        this._select.style.width = editorContainerRect.width + 'px';\n        this._select.style.maxHeight = '60px';\n        this.editorContainer.style.visibility = 'hidden';\n    }\n    _deserialize(value) {\n        if (value === null || value === undefined) {\n            return '';\n        }\n        if (this._isMultiSelect) {\n            const values = [];\n            if (Array.isArray(value)) {\n                for (let item of value) {\n                    values.push(item.toString());\n                }\n            }\n            return values;\n        }\n        else {\n            return value.toString();\n        }\n    }\n    _createWidget() {\n        const cell = this.cell;\n        const metadata = cell.grid.dataModel.metadata('body', cell.row, cell.column);\n        const items = metadata.constraint.enum;\n        const select = document.createElement('select');\n        select.classList.add('lm-DataGrid-cellEditorWidget');\n        for (let item of items) {\n            const option = document.createElement('option');\n            option.value = item;\n            option.text = item;\n            select.appendChild(option);\n        }\n        this._select = select;\n    }\n    _bindEvents() {\n        this._select.addEventListener('keydown', this._onKeyDown.bind(this));\n        this._select.addEventListener('blur', this._onBlur.bind(this));\n    }\n    _onKeyDown(event) {\n        switch (getKeyboardLayout().keyForKeydownEvent(event)) {\n            case 'Enter':\n                this.commit(event.shiftKey ? 'up' : 'down');\n                break;\n            case 'Tab':\n                this.commit(event.shiftKey ? 'left' : 'right');\n                event.stopPropagation();\n                event.preventDefault();\n                break;\n            case 'Escape':\n                this.cancel();\n                break;\n        }\n    }\n    _onBlur(event) {\n        if (this.isDisposed) {\n            return;\n        }\n        if (!this.commit()) {\n            event.preventDefault();\n            event.stopPropagation();\n            this._select.focus();\n        }\n    }\n}\n/**\n * Cell editor for option cells whose value can be any value\n * from set of pre-defined options or values that can be input by user.\n */\nclass DynamicOptionCellEditor extends CellEditor {\n    /**\n     * Handle the DOM events for the editor.\n     *\n     * @param event - The DOM event sent to the editor.\n     */\n    handleEvent(event) {\n        switch (event.type) {\n            case 'keydown':\n                this._onKeyDown(event);\n                break;\n            case 'blur':\n                this._onBlur(event);\n                break;\n        }\n    }\n    /**\n     * Dispose of the resources held by cell editor.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._unbindEvents();\n        super.dispose();\n    }\n    /**\n     * Start editing the cell.\n     */\n    startEditing() {\n        this._createWidget();\n        const cell = this.cell;\n        const cellInfo = this.getCellInfo(cell);\n        this._input.value = this._deserialize(cellInfo.data);\n        this.editorContainer.appendChild(this._input);\n        this._input.focus();\n        this._input.select();\n        this._bindEvents();\n    }\n    /**\n     * Return the current option input.\n     */\n    getInput() {\n        return this._input.value;\n    }\n    _deserialize(value) {\n        if (value === null || value === undefined) {\n            return '';\n        }\n        return value.toString();\n    }\n    _createWidget() {\n        const cell = this.cell;\n        const grid = cell.grid;\n        const dataModel = grid.dataModel;\n        const rowCount = dataModel.rowCount('body');\n        const listId = 'cell-editor-list';\n        const list = document.createElement('datalist');\n        list.id = listId;\n        const input = document.createElement('input');\n        input.classList.add('lm-DataGrid-cellEditorWidget');\n        input.classList.add('lm-DataGrid-cellEditorInput');\n        const valueSet = new Set();\n        for (let r = 0; r < rowCount; ++r) {\n            const data = dataModel.data('body', r, cell.column);\n            if (data) {\n                valueSet.add(data);\n            }\n        }\n        valueSet.forEach((value) => {\n            const option = document.createElement('option');\n            option.value = value;\n            option.text = value;\n            list.appendChild(option);\n        });\n        this.editorContainer.appendChild(list);\n        input.setAttribute('list', listId);\n        this._input = input;\n    }\n    _bindEvents() {\n        this._input.addEventListener('keydown', this);\n        this._input.addEventListener('blur', this);\n    }\n    _unbindEvents() {\n        this._input.removeEventListener('keydown', this);\n        this._input.removeEventListener('blur', this);\n    }\n    _onKeyDown(event) {\n        switch (getKeyboardLayout().keyForKeydownEvent(event)) {\n            case 'Enter':\n                this.commit(event.shiftKey ? 'up' : 'down');\n                break;\n            case 'Tab':\n                this.commit(event.shiftKey ? 'left' : 'right');\n                event.stopPropagation();\n                event.preventDefault();\n                break;\n            case 'Escape':\n                this.cancel();\n                break;\n        }\n    }\n    _onBlur(event) {\n        if (this.isDisposed) {\n            return;\n        }\n        if (!this.commit()) {\n            event.preventDefault();\n            event.stopPropagation();\n            this._input.focus();\n        }\n    }\n}\n/**\n * The namespace for the `CellEditor` class statics.\n */\n(function (CellEditor) {\n    /**\n     * A widget which implements a notification popup.\n     */\n    class Notification extends Widget {\n        /**\n         * Construct a new notification.\n         *\n         * @param options - The options for initializing the notification.\n         */\n        constructor(options) {\n            super({ node: Notification.createNode() });\n            this._message = '';\n            this.addClass('lm-DataGrid-notification');\n            this.setFlag(Widget.Flag.DisallowLayout);\n            this._target = options.target;\n            this._message = options.message || '';\n            this._placement = options.placement || 'bottom';\n            Widget.attach(this, document.body);\n            if (options.timeout && options.timeout > 0) {\n                setTimeout(() => {\n                    this.close();\n                }, options.timeout);\n            }\n        }\n        /**\n         * Handle the DOM events for the notification.\n         *\n         * @param event - The DOM event sent to the notification.\n         *\n         * #### Notes\n         * This method implements the DOM `EventListener` interface and is\n         * called in response to events on the notification's DOM node.\n         *\n         * This should not be called directly by user code.\n         */\n        handleEvent(event) {\n            switch (event.type) {\n                case 'mousedown':\n                    this._evtMouseDown(event);\n                    break;\n                case 'contextmenu':\n                    event.preventDefault();\n                    event.stopPropagation();\n                    break;\n            }\n        }\n        /**\n         * Get the placement of the notification.\n         */\n        get placement() {\n            return this._placement;\n        }\n        /**\n         * Set the placement of the notification.\n         */\n        set placement(value) {\n            // Do nothing if the placement does not change.\n            if (this._placement === value) {\n                return;\n            }\n            // Update the internal placement.\n            this._placement = value;\n            // Schedule an update for notification.\n            this.update();\n        }\n        /**\n         * Get the current value of the message.\n         */\n        get message() {\n            return this._message;\n        }\n        /**\n         * Set the current value of the message.\n         *\n         */\n        set message(value) {\n            // Do nothing if the value does not change.\n            if (this._message === value) {\n                return;\n            }\n            // Update the internal value.\n            this._message = value;\n            // Schedule an update for notification.\n            this.update();\n        }\n        /**\n         * Get the node presenting the message.\n         */\n        get messageNode() {\n            return this.node.getElementsByClassName('lm-DataGrid-notificationMessage')[0];\n        }\n        /**\n         * A method invoked on a 'before-attach' message.\n         */\n        onBeforeAttach(msg) {\n            this.node.addEventListener('mousedown', this);\n            this.update();\n        }\n        /**\n         * A method invoked on an 'after-detach' message.\n         */\n        onAfterDetach(msg) {\n            this.node.removeEventListener('mousedown', this);\n        }\n        /**\n         * A method invoked on an 'update-request' message.\n         */\n        onUpdateRequest(msg) {\n            const targetRect = this._target.getBoundingClientRect();\n            const style = this.node.style;\n            switch (this._placement) {\n                case 'bottom':\n                    style.left = targetRect.left + 'px';\n                    style.top = targetRect.bottom + 'px';\n                    break;\n                case 'top':\n                    style.left = targetRect.left + 'px';\n                    style.height = targetRect.top + 'px';\n                    style.top = '0';\n                    style.alignItems = 'flex-end';\n                    style.justifyContent = 'flex-end';\n                    break;\n                case 'left':\n                    style.left = '0';\n                    style.width = targetRect.left + 'px';\n                    style.top = targetRect.top + 'px';\n                    style.alignItems = 'flex-end';\n                    style.justifyContent = 'flex-end';\n                    break;\n                case 'right':\n                    style.left = targetRect.right + 'px';\n                    style.top = targetRect.top + 'px';\n                    break;\n            }\n            this.messageNode.innerHTML = this._message;\n        }\n        /**\n         * Handle the `'mousedown'` event for the notification.\n         */\n        _evtMouseDown(event) {\n            // Do nothing if it's not a left mouse press.\n            if (event.button !== 0) {\n                return;\n            }\n            event.preventDefault();\n            event.stopPropagation();\n            this.close();\n        }\n    }\n    CellEditor.Notification = Notification;\n    /**\n     * The namespace for the `Notification` class statics.\n     */\n    (function (Notification) {\n        /**\n         * Create the DOM node for notification.\n         */\n        function createNode() {\n            const node = document.createElement('div');\n            const container = document.createElement('div');\n            container.className = 'lm-DataGrid-notificationContainer';\n            const message = document.createElement('span');\n            message.className = 'lm-DataGrid-notificationMessage';\n            container.appendChild(message);\n            node.appendChild(container);\n            return node;\n        }\n        Notification.createNode = createNode;\n    })(Notification = CellEditor.Notification || (CellEditor.Notification = {}));\n})(CellEditor || (CellEditor = {}));\n\n/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * Resolve a config option for a cell editor.\n *\n * @param option - The config option to resolve.\n *\n * @param config - The cell config object.\n *\n * @returns The resolved value for the option.\n */\nfunction resolveOption(option, config) {\n    return typeof option === 'function'\n        ? option(config)\n        : option;\n}\n/**\n * An object which manages cell editing. It stores editor overrides,\n * decides which editor to use for a cell, makes sure there is only one editor active.\n */\nclass CellEditorController {\n    constructor() {\n        // active cell editor\n        this._editor = null;\n        // active cell being edited\n        this._cell = null;\n        // cell editor overrides based on cell data type identifier\n        this._typeBasedOverrides = new Map();\n        // cell editor overrides based on partial metadata match\n        this._metadataBasedOverrides = new Map();\n    }\n    /**\n     * Override cell editor for the cells matching the identifier.\n     *\n     * @param identifier - Cell identifier to use when matching cells.\n     * if identifier is a CellDataType, then cell matching is done using data type of the cell,\n     * if identifier is a Metadata, then partial match of the cell metadata with identifier is used for match,\n     * if identifier is 'default' then override is used as default editor when no other editor is found suitable\n     *\n     * @param editor - The cell editor to use or resolver to use to get an editor for matching cells.\n     */\n    setEditor(identifier, editor) {\n        if (typeof identifier === 'string') {\n            this._typeBasedOverrides.set(identifier, editor);\n        }\n        else {\n            const key = this._metadataIdentifierToKey(identifier);\n            this._metadataBasedOverrides.set(key, [identifier, editor]);\n        }\n    }\n    /**\n     * Start editing a cell.\n     *\n     * @param cell - The object holding cell configuration data.\n     *\n     * @param options - The cell editing options.\n     */\n    edit(cell, options) {\n        const grid = cell.grid;\n        if (!grid.editable) {\n            console.error('Grid cannot be edited!');\n            return false;\n        }\n        this.cancel();\n        this._cell = cell;\n        options = options || {};\n        options.onCommit = options.onCommit || this._onCommit.bind(this);\n        options.onCancel = options.onCancel || this._onCancel.bind(this);\n        // if an editor is passed in with options, then use it for editing\n        if (options.editor) {\n            this._editor = options.editor;\n            options.editor.edit(cell, options);\n            return true;\n        }\n        // choose an editor based on overrides / cell data type\n        const editor = this._getEditor(cell);\n        if (editor) {\n            this._editor = editor;\n            editor.edit(cell, options);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Cancel editing.\n     */\n    cancel() {\n        if (this._editor) {\n            this._editor.cancel();\n            this._editor = null;\n        }\n        this._cell = null;\n    }\n    _onCommit(response) {\n        const cell = this._cell;\n        if (!cell) {\n            return;\n        }\n        const grid = cell.grid;\n        const dataModel = grid.dataModel;\n        let row = cell.row;\n        let column = cell.column;\n        const cellGroup = CellGroup.getGroup(grid.dataModel, 'body', row, column);\n        if (cellGroup) {\n            row = cellGroup.r1;\n            column = cellGroup.c1;\n        }\n        dataModel.setData('body', row, column, response.value);\n        grid.viewport.node.focus();\n        if (response.cursorMovement !== 'none') {\n            grid.moveCursor(response.cursorMovement);\n            grid.scrollToCursor();\n        }\n    }\n    _onCancel() {\n        if (!this._cell) {\n            return;\n        }\n        this._cell.grid.viewport.node.focus();\n    }\n    _getDataTypeKey(cell) {\n        const metadata = cell.grid.dataModel\n            ? cell.grid.dataModel.metadata('body', cell.row, cell.column)\n            : null;\n        if (!metadata) {\n            return 'default';\n        }\n        let key = '';\n        if (metadata) {\n            key = metadata.type;\n        }\n        if (metadata.constraint && metadata.constraint.enum) {\n            if (metadata.constraint.enum === 'dynamic') {\n                key += ':dynamic-option';\n            }\n            else {\n                key += ':option';\n            }\n        }\n        return key;\n    }\n    _objectToKey(object) {\n        let str = '';\n        for (let key in object) {\n            const value = object[key];\n            if (typeof value === 'object') {\n                str += `${key}:${this._objectToKey(value)}`;\n            }\n            else {\n                str += `[${key}:${value}]`;\n            }\n        }\n        return str;\n    }\n    _metadataIdentifierToKey(metadata) {\n        return this._objectToKey(metadata);\n    }\n    _metadataMatchesIdentifier(metadata, identifier) {\n        for (let key in identifier) {\n            if (!metadata.hasOwnProperty(key)) {\n                return false;\n            }\n            const identifierValue = identifier[key];\n            const metadataValue = metadata[key];\n            if (typeof identifierValue === 'object') {\n                if (!this._metadataMatchesIdentifier(metadataValue, identifierValue)) {\n                    return false;\n                }\n            }\n            else if (metadataValue !== identifierValue) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _getMetadataBasedEditor(cell) {\n        let editorMatched;\n        const metadata = cell.grid.dataModel.metadata('body', cell.row, cell.column);\n        if (metadata) {\n            this._metadataBasedOverrides.forEach(value => {\n                if (!editorMatched) {\n                    let [identifier, editor] = value;\n                    if (this._metadataMatchesIdentifier(metadata, identifier)) {\n                        editorMatched = resolveOption(editor, cell);\n                    }\n                }\n            });\n        }\n        return editorMatched;\n    }\n    /**\n     * Choose the most appropriate cell editor to use based on overrides / cell data type.\n     *\n     * If no match is found in overrides or based on cell data type, and if cell has a primitive\n     * data type then TextCellEditor is used as default cell editor. If 'default' cell editor\n     * is overridden, then it is used instead of TextCellEditor for default.\n     */\n    _getEditor(cell) {\n        const dtKey = this._getDataTypeKey(cell);\n        // find an editor based on data type based override\n        if (this._typeBasedOverrides.has(dtKey)) {\n            const editor = this._typeBasedOverrides.get(dtKey);\n            return resolveOption(editor, cell);\n        } // find an editor based on metadata match based override\n        else if (this._metadataBasedOverrides.size > 0) {\n            const editor = this._getMetadataBasedEditor(cell);\n            if (editor) {\n                return editor;\n            }\n        }\n        // choose an editor based on data type\n        switch (dtKey) {\n            case 'string':\n                return new TextCellEditor();\n            case 'number':\n                return new NumberCellEditor();\n            case 'integer':\n                return new IntegerCellEditor();\n            case 'boolean':\n                return new BooleanCellEditor();\n            case 'date':\n                return new DateCellEditor();\n            case 'string:option':\n            case 'number:option':\n            case 'integer:option':\n            case 'date:option':\n            case 'array:option':\n                return new OptionCellEditor();\n            case 'string:dynamic-option':\n            case 'number:dynamic-option':\n            case 'integer:dynamic-option':\n            case 'date:dynamic-option':\n                return new DynamicOptionCellEditor();\n        }\n        // if an override exists for 'default', then use it\n        if (this._typeBasedOverrides.has('default')) {\n            const editor = this._typeBasedOverrides.get('default');\n            return resolveOption(editor, cell);\n        }\n        // if cell has a primitive data type then use TextCellEditor\n        const data = cell.grid.dataModel.data('body', cell.row, cell.column);\n        if (!data || typeof data !== 'object') {\n            return new TextCellEditor();\n        }\n        // no suitable editor found for the cell\n        return undefined;\n    }\n}\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * An object which provides the data for a data grid.\n *\n * #### Notes\n * If the predefined data models are insufficient for a particular use\n * case, a custom model can be defined which derives from this class.\n */\nclass DataModel {\n    constructor() {\n        this._changed = new Signal(this);\n    }\n    /**\n     * A signal emitted when the data model has changed.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * Get the count of merged cell groups pertaining to a given\n     * cell region.\n     * @param region the target cell region.\n     */\n    groupCount(region) {\n        return 0;\n    }\n    /**\n     * Get the metadata for a cell in the data model.\n     *\n     * @param region - The cell region of interest.\n     *\n     * @param row - The row index of the cell of interest.\n     *\n     * @param column - The column index of the cell of interest.\n     *\n     * @returns The metadata for the specified cell.\n     *\n     * #### Notes\n     * The returned metadata should be treated as immutable.\n     *\n     * This method is called often, and so should be efficient.\n     *\n     * The default implementation returns `{}`.\n     */\n    metadata(region, row, column) {\n        return DataModel.emptyMetadata;\n    }\n    /**\n     * Get the merged cell group corresponding to a region and index number.\n     * @param region the cell region of cell group.\n     * @param groupIndex the group index of the cell group.\n     * @returns a cell group.\n     */\n    group(region, groupIndex) {\n        return null;\n    }\n    /**\n     * Emit the `changed` signal for the data model.\n     *\n     * #### Notes\n     * Subclasses should call this method whenever the data model has\n     * changed so that attached data grids can update themselves.\n     */\n    emitChanged(args) {\n        this._changed.emit(args);\n    }\n}\n/**\n * An object which provides the mutable data for a data grid.\n *\n * #### Notes\n * This object is an extension to `DataModel` and it only adds ability to\n * change data for cells.\n */\nclass MutableDataModel extends DataModel {\n}\n/**\n * The namespace for the `DataModel` class statics.\n */\n(function (DataModel) {\n    /**\n     * A singleton empty metadata object.\n     */\n    DataModel.emptyMetadata = Object.freeze({});\n})(DataModel || (DataModel = {}));\n\n/**\n * A thin caching wrapper around a 2D canvas rendering context.\n *\n * #### Notes\n * This class is mostly a transparent wrapper around a canvas rendering\n * context which improves performance when writing context state.\n *\n * For best performance, avoid reading state from the `gc`. Writes are\n * cached based on the previously written value.\n *\n * Unless otherwise specified, the API and semantics of this class are\n * identical to the builtin 2D canvas rendering context:\n * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D\n *\n * The wrapped canvas context should not be manipulated externally\n * until the wrapping `GraphicsContext` object is disposed.\n */\nclass GraphicsContext {\n    /**\n     * Create a new graphics context object.\n     *\n     * @param context - The 2D canvas rendering context to wrap.\n     */\n    constructor(context) {\n        this._disposed = false;\n        this._context = context;\n        this._state = Private$3.State.create(context);\n    }\n    dispose() {\n        // Bail if the gc is already disposed.\n        if (this._disposed) {\n            return;\n        }\n        // Mark the gc as disposed.\n        this._disposed = true;\n        // Pop any unrestored saves.\n        while (this._state.next) {\n            this._state = this._state.next;\n            this._context.restore();\n        }\n    }\n    get isDisposed() {\n        return this._disposed;\n    }\n    get fillStyle() {\n        return this._context.fillStyle;\n    }\n    set fillStyle(value) {\n        if (this._state.fillStyle !== value) {\n            this._state.fillStyle = value;\n            this._context.fillStyle = value;\n        }\n    }\n    get strokeStyle() {\n        return this._context.strokeStyle;\n    }\n    set strokeStyle(value) {\n        if (this._state.strokeStyle !== value) {\n            this._state.strokeStyle = value;\n            this._context.strokeStyle = value;\n        }\n    }\n    get font() {\n        return this._context.font;\n    }\n    set font(value) {\n        if (this._state.font !== value) {\n            this._state.font = value;\n            this._context.font = value;\n        }\n    }\n    get textAlign() {\n        return this._context.textAlign;\n    }\n    set textAlign(value) {\n        if (this._state.textAlign !== value) {\n            this._state.textAlign = value;\n            this._context.textAlign = value;\n        }\n    }\n    get textBaseline() {\n        return this._context.textBaseline;\n    }\n    set textBaseline(value) {\n        if (this._state.textBaseline !== value) {\n            this._state.textBaseline = value;\n            this._context.textBaseline = value;\n        }\n    }\n    get lineCap() {\n        return this._context.lineCap;\n    }\n    set lineCap(value) {\n        if (this._state.lineCap !== value) {\n            this._state.lineCap = value;\n            this._context.lineCap = value;\n        }\n    }\n    get lineDashOffset() {\n        return this._context.lineDashOffset;\n    }\n    set lineDashOffset(value) {\n        if (this._state.lineDashOffset !== value) {\n            this._state.lineDashOffset = value;\n            this._context.lineDashOffset = value;\n        }\n    }\n    get lineJoin() {\n        return this._context.lineJoin;\n    }\n    set lineJoin(value) {\n        if (this._state.lineJoin !== value) {\n            this._state.lineJoin = value;\n            this._context.lineJoin = value;\n        }\n    }\n    get lineWidth() {\n        return this._context.lineWidth;\n    }\n    set lineWidth(value) {\n        if (this._state.lineWidth !== value) {\n            this._state.lineWidth = value;\n            this._context.lineWidth = value;\n        }\n    }\n    get miterLimit() {\n        return this._context.miterLimit;\n    }\n    set miterLimit(value) {\n        if (this._state.miterLimit !== value) {\n            this._state.miterLimit = value;\n            this._context.miterLimit = value;\n        }\n    }\n    get shadowBlur() {\n        return this._context.shadowBlur;\n    }\n    set shadowBlur(value) {\n        if (this._state.shadowBlur !== value) {\n            this._state.shadowBlur = value;\n            this._context.shadowBlur = value;\n        }\n    }\n    get shadowColor() {\n        return this._context.shadowColor;\n    }\n    set shadowColor(value) {\n        if (this._state.shadowColor !== value) {\n            this._state.shadowColor = value;\n            this._context.shadowColor = value;\n        }\n    }\n    get shadowOffsetX() {\n        return this._context.shadowOffsetX;\n    }\n    set shadowOffsetX(value) {\n        if (this._state.shadowOffsetX !== value) {\n            this._state.shadowOffsetX = value;\n            this._context.shadowOffsetX = value;\n        }\n    }\n    get shadowOffsetY() {\n        return this._context.shadowOffsetY;\n    }\n    set shadowOffsetY(value) {\n        if (this._state.shadowOffsetY !== value) {\n            this._state.shadowOffsetY = value;\n            this._context.shadowOffsetY = value;\n        }\n    }\n    get imageSmoothingEnabled() {\n        return this._context.imageSmoothingEnabled;\n    }\n    set imageSmoothingEnabled(value) {\n        if (this._state.imageSmoothingEnabled !== value) {\n            this._state.imageSmoothingEnabled = value;\n            this._context.imageSmoothingEnabled = value;\n        }\n    }\n    get globalAlpha() {\n        return this._context.globalAlpha;\n    }\n    set globalAlpha(value) {\n        if (this._state.globalAlpha !== value) {\n            this._state.globalAlpha = value;\n            this._context.globalAlpha = value;\n        }\n    }\n    get globalCompositeOperation() {\n        return this._context.globalCompositeOperation;\n    }\n    set globalCompositeOperation(value) {\n        if (this._state.globalCompositeOperation !== value) {\n            this._state.globalCompositeOperation = value;\n            this._context.globalCompositeOperation = value;\n        }\n    }\n    getLineDash() {\n        return this._context.getLineDash();\n    }\n    setLineDash(segments) {\n        this._context.setLineDash(segments);\n    }\n    rotate(angle) {\n        this._context.rotate(angle);\n    }\n    scale(x, y) {\n        this._context.scale(x, y);\n    }\n    transform(m11, m12, m21, m22, dx, dy) {\n        this._context.transform(m11, m12, m21, m22, dx, dy);\n    }\n    translate(x, y) {\n        this._context.translate(x, y);\n    }\n    setTransform(m11, m12, m21, m22, dx, dy) {\n        this._context.setTransform(m11, m12, m21, m22, dx, dy);\n    }\n    save() {\n        // Clone an push the current state to the stack.\n        this._state = Private$3.State.push(this._state);\n        // Save the wrapped context state.\n        this._context.save();\n    }\n    restore() {\n        // Bail if there is no state to restore.\n        if (!this._state.next) {\n            return;\n        }\n        // Pop the saved state from the stack.\n        this._state = Private$3.State.pop(this._state);\n        // Restore the wrapped context state.\n        this._context.restore();\n    }\n    beginPath() {\n        return this._context.beginPath();\n    }\n    closePath() {\n        this._context.closePath();\n    }\n    isPointInPath(x, y, fillRule) {\n        let result;\n        if (arguments.length === 2) {\n            result = this._context.isPointInPath(x, y);\n        }\n        else {\n            result = this._context.isPointInPath(x, y, fillRule);\n        }\n        return result;\n    }\n    arc(x, y, radius, startAngle, endAngle, anticlockwise) {\n        if (arguments.length === 5) {\n            this._context.arc(x, y, radius, startAngle, endAngle);\n        }\n        else {\n            this._context.arc(x, y, radius, startAngle, endAngle, anticlockwise);\n        }\n    }\n    arcTo(x1, y1, x2, y2, radius) {\n        this._context.arcTo(x1, y1, x2, y2, radius);\n    }\n    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {\n        this._context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n    }\n    ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {\n        if (arguments.length === 7) {\n            this._context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle);\n        }\n        else {\n            this._context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);\n        }\n    }\n    lineTo(x, y) {\n        this._context.lineTo(x, y);\n    }\n    moveTo(x, y) {\n        this._context.moveTo(x, y);\n    }\n    quadraticCurveTo(cpx, cpy, x, y) {\n        this._context.quadraticCurveTo(cpx, cpy, x, y);\n    }\n    rect(x, y, w, h) {\n        this._context.rect(x, y, w, h);\n    }\n    clip(fillRule) {\n        if (arguments.length === 0) {\n            this._context.clip();\n        }\n        else {\n            this._context.clip(fillRule);\n        }\n    }\n    fill(fillRule) {\n        if (arguments.length === 0) {\n            this._context.fill();\n        }\n        else {\n            this._context.fill(fillRule);\n        }\n    }\n    stroke() {\n        this._context.stroke();\n    }\n    clearRect(x, y, w, h) {\n        return this._context.clearRect(x, y, w, h);\n    }\n    fillRect(x, y, w, h) {\n        this._context.fillRect(x, y, w, h);\n    }\n    fillText(text, x, y, maxWidth) {\n        if (arguments.length === 3) {\n            this._context.fillText(text, x, y);\n        }\n        else {\n            this._context.fillText(text, x, y, maxWidth);\n        }\n    }\n    strokeRect(x, y, w, h) {\n        this._context.strokeRect(x, y, w, h);\n    }\n    strokeText(text, x, y, maxWidth) {\n        if (arguments.length === 3) {\n            this._context.strokeText(text, x, y);\n        }\n        else {\n            this._context.strokeText(text, x, y, maxWidth);\n        }\n    }\n    measureText(text) {\n        return this._context.measureText(text);\n    }\n    createLinearGradient(x0, y0, x1, y1) {\n        return this._context.createLinearGradient(x0, y0, x1, y1);\n    }\n    createRadialGradient(x0, y0, r0, x1, y1, r1) {\n        return this._context.createRadialGradient(x0, y0, r0, x1, y1, r1);\n    }\n    createPattern(image, repetition) {\n        return this._context.createPattern(image, repetition);\n    }\n    createImageData() {\n        // eslint-disable-next-line prefer-spread, prefer-rest-params\n        return this._context.createImageData.apply(this._context, arguments);\n    }\n    getImageData(sx, sy, sw, sh) {\n        return this._context.getImageData(sx, sy, sw, sh);\n    }\n    putImageData() {\n        // eslint-disable-next-line prefer-spread, prefer-rest-params\n        this._context.putImageData.apply(this._context, arguments);\n    }\n    drawImage() {\n        // eslint-disable-next-line prefer-spread, prefer-rest-params\n        this._context.drawImage.apply(this._context, arguments);\n    }\n    drawFocusIfNeeded(element) {\n        this._context.drawFocusIfNeeded(element);\n    }\n}\n/**\n * The namespace for the module implementation details.\n */\nvar Private$3;\n(function (Private) {\n    /**\n     * The index of next valid pool object.\n     */\n    let pi = -1;\n    /**\n     * A state object allocation pool.\n     */\n    const pool = [];\n    /**\n     * An object which holds the state for a gc.\n     */\n    class State {\n        /**\n         * Create a gc state object from a 2D canvas context.\n         */\n        static create(context) {\n            let state = pi < 0 ? new State() : pool[pi--];\n            state.next = null;\n            state.fillStyle = context.fillStyle;\n            state.font = context.font;\n            state.globalAlpha = context.globalAlpha;\n            state.globalCompositeOperation = context.globalCompositeOperation;\n            state.imageSmoothingEnabled = context.imageSmoothingEnabled;\n            state.lineCap = context.lineCap;\n            state.lineDashOffset = context.lineDashOffset;\n            state.lineJoin = context.lineJoin;\n            state.lineWidth = context.lineWidth;\n            state.miterLimit = context.miterLimit;\n            state.shadowBlur = context.shadowBlur;\n            state.shadowColor = context.shadowColor;\n            state.shadowOffsetX = context.shadowOffsetX;\n            state.shadowOffsetY = context.shadowOffsetY;\n            state.strokeStyle = context.strokeStyle;\n            state.textAlign = context.textAlign;\n            state.textBaseline = context.textBaseline;\n            return state;\n        }\n        /**\n         * Clone an existing gc state object and add it to the state stack.\n         */\n        static push(other) {\n            let state = pi < 0 ? new State() : pool[pi--];\n            state.next = other;\n            state.fillStyle = other.fillStyle;\n            state.font = other.font;\n            state.globalAlpha = other.globalAlpha;\n            state.globalCompositeOperation = other.globalCompositeOperation;\n            state.imageSmoothingEnabled = other.imageSmoothingEnabled;\n            state.lineCap = other.lineCap;\n            state.lineDashOffset = other.lineDashOffset;\n            state.lineJoin = other.lineJoin;\n            state.lineWidth = other.lineWidth;\n            state.miterLimit = other.miterLimit;\n            state.shadowBlur = other.shadowBlur;\n            state.shadowColor = other.shadowColor;\n            state.shadowOffsetX = other.shadowOffsetX;\n            state.shadowOffsetY = other.shadowOffsetY;\n            state.strokeStyle = other.strokeStyle;\n            state.textAlign = other.textAlign;\n            state.textBaseline = other.textBaseline;\n            return state;\n        }\n        /**\n         * Pop the next state object and return the current to the pool\n         */\n        static pop(state) {\n            state.fillStyle = '';\n            state.strokeStyle = '';\n            pool[++pi] = state;\n            return state.next;\n        }\n    }\n    Private.State = State;\n})(Private$3 || (Private$3 = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * A class which manages the mapping of cell renderers.\n */\nclass RendererMap {\n    /**\n     * Construct a new renderer map.\n     *\n     * @param values - The initial values for the map.\n     *\n     * @param fallback - The renderer of last resort.\n     */\n    constructor(values = {}, fallback) {\n        this._changed = new Signal(this);\n        this._values = { ...values };\n        this._fallback = fallback || new TextRenderer();\n    }\n    /**\n     * A signal emitted when the renderer map has changed.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * Get the cell renderer to use for the given cell config.\n     *\n     * @param config - The cell config of interest.\n     *\n     * @returns The renderer to use for the cell.\n     */\n    get(config) {\n        // Fetch the renderer from the values map.\n        let renderer = this._values[config.region];\n        // Execute a resolver function if necessary.\n        if (typeof renderer === 'function') {\n            try {\n                renderer = renderer(config);\n            }\n            catch (err) {\n                renderer = undefined;\n                console.error(err);\n            }\n        }\n        // Return the renderer or the fallback.\n        return renderer || this._fallback;\n    }\n    /**\n     * Update the renderer map with new values\n     *\n     * @param values - The updated values for the map.\n     *\n     * @param fallback - The renderer of last resort.\n     *\n     * #### Notes\n     * This method always emits the `changed` signal.\n     */\n    update(values = {}, fallback) {\n        this._values = { ...this._values, ...values };\n        this._fallback = fallback || this._fallback;\n        this._changed.emit(undefined);\n    }\n}\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * An object which manages a collection of variable sized sections.\n *\n * #### Notes\n * This class is an implementation detail. It is designed to manage\n * the variable row and column sizes for a data grid. User code will\n * not interact with this class directly.\n */\nclass SectionList {\n    /**\n     * Construct a new section list.\n     *\n     * @param options - The options for initializing the list.\n     */\n    constructor(options) {\n        this._count = 0;\n        this._length = 0;\n        this._sections = [];\n        this._minimumSize = options.minimumSize || 2;\n        this._defaultSize = Math.max(this._minimumSize, Math.floor(options.defaultSize));\n    }\n    /**\n     * The total size of all sections in the list.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    get length() {\n        return this._length;\n    }\n    /**\n     * The total number of sections in the list.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    get count() {\n        return this._count;\n    }\n    /**\n     * Get the minimum size of sections in the list.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    get minimumSize() {\n        return this._minimumSize;\n    }\n    /**\n     * Set the minimum size of sections in the list.\n     *\n     * #### Complexity\n     * Linear on the number of resized sections.\n     */\n    set minimumSize(value) {\n        // Normalize the value.\n        value = Math.max(2, Math.floor(value));\n        // Bail early if the value does not change.\n        if (this._minimumSize === value) {\n            return;\n        }\n        // Update the internal minimum size.\n        this._minimumSize = value;\n        // Update default size if larger than minimum size\n        if (value > this._defaultSize) {\n            this.defaultSize = value;\n        }\n    }\n    /**\n     * Get the default size of sections in the list.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    get defaultSize() {\n        return this._defaultSize;\n    }\n    /**\n     * Set the default size of sections in the list.\n     *\n     * #### Complexity\n     * Linear on the number of resized sections.\n     */\n    set defaultSize(value) {\n        // Normalize the value.\n        value = Math.max(this._minimumSize, Math.floor(value));\n        // Bail early if the value does not change.\n        if (this._defaultSize === value) {\n            return;\n        }\n        // Compute the delta default size.\n        let delta = value - this._defaultSize;\n        // Update the internal default size.\n        this._defaultSize = value;\n        // Update the length.\n        this._length += delta * (this._count - this._sections.length);\n        // Bail early if there are no modified sections.\n        if (this._sections.length === 0) {\n            return;\n        }\n        // Recompute the offsets of the modified sections.\n        for (let i = 0, n = this._sections.length; i < n; ++i) {\n            // Look up the previous and current modified sections.\n            let prev = this._sections[i - 1];\n            let curr = this._sections[i];\n            // Adjust the offset for the current section.\n            if (prev) {\n                let count = curr.index - prev.index - 1;\n                curr.offset = prev.offset + prev.size + count * value;\n            }\n            else {\n                curr.offset = curr.index * value;\n            }\n        }\n    }\n    /**\n     * Clamp a size to the minimum section size\n     *\n     * @param size - The size to clamp.\n     *\n     * @returns The size or the section minimum size, whichever is larger\n     */\n    clampSize(size) {\n        return Math.max(this._minimumSize, Math.floor(size));\n    }\n    /**\n     * Find the index of the section which covers the given offset.\n     *\n     * @param offset - The offset of the section of interest.\n     *\n     * @returns The index of the section which covers the given offset,\n     *   or `-1` if the offset is out of range.\n     *\n     * #### Complexity\n     * Logarithmic on the number of resized sections.\n     */\n    indexOf(offset) {\n        // Bail early if the offset is out of range.\n        if (offset < 0 || offset >= this._length || this._count === 0) {\n            return -1;\n        }\n        // Handle the simple case of no modified sections.\n        if (this._sections.length === 0) {\n            return Math.floor(offset / this._defaultSize);\n        }\n        // Find the modified section for the given offset.\n        let i = ArrayExt.lowerBound(this._sections, offset, Private$2.offsetCmp);\n        // Return the index of an exact match.\n        if (i < this._sections.length && this._sections[i].offset <= offset) {\n            return this._sections[i].index;\n        }\n        // Handle the case of no modified sections before the offset.\n        if (i === 0) {\n            return Math.floor(offset / this._defaultSize);\n        }\n        // Compute the index from the previous modified section.\n        let section = this._sections[i - 1];\n        let span = offset - (section.offset + section.size);\n        return section.index + Math.floor(span / this._defaultSize) + 1;\n    }\n    /**\n     * Find the offset of the section at the given index.\n     *\n     * @param index - The index of the section of interest.\n     *\n     * @returns The offset of the section at the given index, or `-1`\n     *   if the index is out of range.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral.\n     *\n     * #### Complexity\n     * Logarithmic on the number of resized sections.\n     */\n    offsetOf(index) {\n        // Bail early if the index is out of range.\n        if (index < 0 || index >= this._count) {\n            return -1;\n        }\n        // Handle the simple case of no modified sections.\n        if (this._sections.length === 0) {\n            return index * this._defaultSize;\n        }\n        // Find the modified section for the given index.\n        let i = ArrayExt.lowerBound(this._sections, index, Private$2.indexCmp);\n        // Return the offset of an exact match.\n        if (i < this._sections.length && this._sections[i].index === index) {\n            return this._sections[i].offset;\n        }\n        // Handle the case of no modified sections before the index.\n        if (i === 0) {\n            return index * this._defaultSize;\n        }\n        // Compute the offset from the previous modified section.\n        let section = this._sections[i - 1];\n        let span = index - section.index - 1;\n        return section.offset + section.size + span * this._defaultSize;\n    }\n    /**\n     * Find the extent of the section at the given index.\n     *\n     * @param index - The index of the section of interest.\n     *\n     * @returns The extent of the section at the given index, or `-1`\n     *   if the index is out of range.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral.\n     *\n     * #### Complexity\n     * Logarithmic on the number of resized sections.\n     */\n    extentOf(index) {\n        // Bail early if the index is out of range.\n        if (index < 0 || index >= this._count) {\n            return -1;\n        }\n        // Handle the simple case of no modified sections.\n        if (this._sections.length === 0) {\n            return (index + 1) * this._defaultSize - 1;\n        }\n        // Find the modified section for the given index.\n        let i = ArrayExt.lowerBound(this._sections, index, Private$2.indexCmp);\n        // Return the offset of an exact match.\n        if (i < this._sections.length && this._sections[i].index === index) {\n            return this._sections[i].offset + this._sections[i].size - 1;\n        }\n        // Handle the case of no modified sections before the index.\n        if (i === 0) {\n            return (index + 1) * this._defaultSize - 1;\n        }\n        // Compute the offset from the previous modified section.\n        let section = this._sections[i - 1];\n        let span = index - section.index;\n        return section.offset + section.size + span * this._defaultSize - 1;\n    }\n    /**\n     * Find the size of the section at the given index.\n     *\n     * @param index - The index of the section of interest.\n     *\n     * @returns The size of the section at the given index, or `-1`\n     *   if the index is out of range.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral.\n     *\n     * #### Complexity\n     * Logarithmic on the number of resized sections.\n     */\n    sizeOf(index) {\n        // Bail early if the index is out of range.\n        if (index < 0 || index >= this._count) {\n            return -1;\n        }\n        // Handle the simple case of no modified sections.\n        if (this._sections.length === 0) {\n            return this._defaultSize;\n        }\n        // Find the modified section for the given index.\n        let i = ArrayExt.lowerBound(this._sections, index, Private$2.indexCmp);\n        // Return the size of an exact match.\n        if (i < this._sections.length && this._sections[i].index === index) {\n            return this._sections[i].size;\n        }\n        // Return the default size for all other cases.\n        return this._defaultSize;\n    }\n    /**\n     * Resize a section in the list.\n     *\n     * @param index - The index of the section to resize. This method\n     *   is a no-op if this value is out of range.\n     *\n     * @param size - The new size of the section. This value will be\n     *   clamped to an integer `>= 0`.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral.\n     *\n     * #### Complexity\n     * Linear on the number of resized sections.\n     */\n    resize(index, size) {\n        // Bail early if the index is out of range.\n        if (index < 0 || index >= this._count) {\n            return;\n        }\n        // Clamp the size to an integer >= minimum size.\n        size = Math.max(this._minimumSize, Math.floor(size));\n        // Find the modified section for the given index.\n        let i = ArrayExt.lowerBound(this._sections, index, Private$2.indexCmp);\n        // Update or create the modified section as needed.\n        let delta;\n        if (i < this._sections.length && this._sections[i].index === index) {\n            let section = this._sections[i];\n            delta = size - section.size;\n            section.size = size;\n        }\n        else if (i === 0) {\n            let offset = index * this._defaultSize;\n            ArrayExt.insert(this._sections, i, { index, offset, size });\n            delta = size - this._defaultSize;\n        }\n        else {\n            let section = this._sections[i - 1];\n            let span = index - section.index - 1;\n            let offset = section.offset + section.size + span * this._defaultSize;\n            ArrayExt.insert(this._sections, i, { index, offset, size });\n            delta = size - this._defaultSize;\n        }\n        // Adjust the length.\n        this._length += delta;\n        // Update all modified sections after the resized section.\n        for (let j = i + 1, n = this._sections.length; j < n; ++j) {\n            this._sections[j].offset += delta;\n        }\n    }\n    /**\n     * Insert sections into the list.\n     *\n     * @param index - The index at which to insert the sections. This\n     *   value will be clamped to the bounds of the list.\n     *\n     * @param count - The number of sections to insert. This method\n     *   is a no-op if this value is `<= 0`.\n     *\n     * #### Undefined Behavior\n     * An `index` or `count` which is non-integral.\n     *\n     * #### Complexity\n     * Linear on the number of resized sections.\n     */\n    insert(index, count) {\n        // Bail early if there are no sections to insert.\n        if (count <= 0) {\n            return;\n        }\n        // Clamp the index to the bounds of the list.\n        index = Math.max(0, Math.min(index, this._count));\n        // Add the new sections to the totals.\n        let span = count * this._defaultSize;\n        this._count += count;\n        this._length += span;\n        // Bail early if there are no modified sections to update.\n        if (this._sections.length === 0) {\n            return;\n        }\n        // Find the modified section for the given index.\n        let i = ArrayExt.lowerBound(this._sections, index, Private$2.indexCmp);\n        // Update all modified sections after the insert location.\n        for (let n = this._sections.length; i < n; ++i) {\n            let section = this._sections[i];\n            section.index += count;\n            section.offset += span;\n        }\n    }\n    /**\n     * Remove sections from the list.\n     *\n     * @param index - The index of the first section to remove. This\n     *   method is a no-op if this value is out of range.\n     *\n     * @param count - The number of sections to remove. This method\n     *   is a no-op if this value is `<= 0`.\n     *\n     * #### Undefined Behavior\n     * An `index` or `count` which is non-integral.\n     *\n     * #### Complexity\n     * Linear on the number of resized sections.\n     */\n    remove(index, count) {\n        // Bail early if there is nothing to remove.\n        if (index < 0 || index >= this._count || count <= 0) {\n            return;\n        }\n        // Clamp the count to the bounds of the list.\n        count = Math.min(this._count - index, count);\n        // Handle the simple case of no modified sections to update.\n        if (this._sections.length === 0) {\n            this._count -= count;\n            this._length -= count * this._defaultSize;\n            return;\n        }\n        // Handle the simple case of removing all sections.\n        if (count === this._count) {\n            this._length = 0;\n            this._count = 0;\n            this._sections.length = 0;\n            return;\n        }\n        // Find the modified section for the start index.\n        let i = ArrayExt.lowerBound(this._sections, index, Private$2.indexCmp);\n        // Find the modified section for the end index.\n        let j = ArrayExt.lowerBound(this._sections, index + count, Private$2.indexCmp);\n        // Remove the relevant modified sections.\n        let removed = this._sections.splice(i, j - i);\n        // Compute the total removed span.\n        let span = (count - removed.length) * this._defaultSize;\n        for (let k = 0, n = removed.length; k < n; ++k) {\n            span += removed[k].size;\n        }\n        // Adjust the totals.\n        this._count -= count;\n        this._length -= span;\n        // Update all modified sections after the removed span.\n        for (let k = i, n = this._sections.length; k < n; ++k) {\n            let section = this._sections[k];\n            section.index -= count;\n            section.offset -= span;\n        }\n    }\n    /**\n     * Move sections within the list.\n     *\n     * @param index - The index of the first section to move. This method\n     *   is a no-op if this value is out of range.\n     *\n     * @param count - The number of sections to move. This method is a\n     *   no-op if this value is `<= 0`.\n     *\n     * @param destination - The destination index for the first section.\n     *   This value will be clamped to the allowable range.\n     *\n     * #### Undefined Behavior\n     * An `index`, `count`, or `destination` which is non-integral.\n     *\n     * #### Complexity\n     * Linear on the number of moved resized sections.\n     */\n    move(index, count, destination) {\n        // Bail early if there is nothing to move.\n        if (index < 0 || index >= this._count || count <= 0) {\n            return;\n        }\n        // Handle the simple case of no modified sections.\n        if (this._sections.length === 0) {\n            return;\n        }\n        // Clamp the move count to the limit.\n        count = Math.min(count, this._count - index);\n        // Clamp the destination index to the limit.\n        destination = Math.min(Math.max(0, destination), this._count - count);\n        // Bail early if there is no effective move.\n        if (index === destination) {\n            return;\n        }\n        // Compute the first affected index.\n        let i1 = Math.min(index, destination);\n        // Look up the first affected modified section.\n        let k1 = ArrayExt.lowerBound(this._sections, i1, Private$2.indexCmp);\n        // Bail early if there are no affected modified sections.\n        if (k1 === this._sections.length) {\n            return;\n        }\n        // Compute the last affected index.\n        let i2 = Math.max(index + count - 1, destination + count - 1);\n        // Look up the last affected modified section.\n        let k2 = ArrayExt.upperBound(this._sections, i2, Private$2.indexCmp) - 1;\n        // Bail early if there are no affected modified sections.\n        if (k2 < k1) {\n            return;\n        }\n        // Compute the pivot index.\n        let pivot = destination < index ? index : index + count;\n        // Compute the count for each side of the pivot.\n        let count1 = pivot - i1;\n        let count2 = i2 - pivot + 1;\n        // Compute the span for each side of the pivot.\n        let span1 = count1 * this._defaultSize;\n        let span2 = count2 * this._defaultSize;\n        // Adjust the spans for the modified sections.\n        for (let j = k1; j <= k2; ++j) {\n            let section = this._sections[j];\n            if (section.index < pivot) {\n                span1 += section.size - this._defaultSize;\n            }\n            else {\n                span2 += section.size - this._defaultSize;\n            }\n        }\n        // Look up the pivot section.\n        let k3 = ArrayExt.lowerBound(this._sections, pivot, Private$2.indexCmp);\n        // Rotate the modified sections if needed.\n        if (k1 <= k3 && k3 <= k2) {\n            ArrayExt.rotate(this._sections, k3 - k1, k1, k2);\n        }\n        // Adjust the modified section indices and offsets.\n        for (let j = k1; j <= k2; ++j) {\n            let section = this._sections[j];\n            if (section.index < pivot) {\n                section.index += count2;\n                section.offset += span2;\n            }\n            else {\n                section.index -= count1;\n                section.offset -= span1;\n            }\n        }\n    }\n    /**\n     * Reset all modified sections to the default size.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    reset() {\n        this._sections.length = 0;\n        this._length = this._count * this._defaultSize;\n    }\n    /**\n     * Remove all sections from the list.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    clear() {\n        this._count = 0;\n        this._length = 0;\n        this._sections.length = 0;\n    }\n}\n/**\n * The namespace for the module implementation details.\n */\nvar Private$2;\n(function (Private) {\n    /**\n     * A comparison function for searching by offset.\n     */\n    function offsetCmp(section, offset) {\n        if (offset < section.offset) {\n            return 1;\n        }\n        if (section.offset + section.size <= offset) {\n            return -1;\n        }\n        return 0;\n    }\n    Private.offsetCmp = offsetCmp;\n    /**\n     * A comparison function for searching by index.\n     */\n    function indexCmp(section, index) {\n        return section.index - index;\n    }\n    Private.indexCmp = indexCmp;\n})(Private$2 || (Private$2 = {}));\n\n/**\n * A widget which implements a high-performance tabular data grid.\n *\n * #### Notes\n * A data grid is implemented as a composition of child widgets. These\n * child widgets are considered an implementation detail. Manipulating\n * the child widgets of a data grid directly is undefined behavior.\n *\n * This class is not designed to be subclassed.\n *\n * See also the related [example](../../examples/datagrid/index.html) and\n * its [source](https://github.com/jupyterlab/lumino/tree/main/examples/example-datagrid).\n */\nclass DataGrid extends Widget {\n    /**\n     * Construct a new data grid.\n     *\n     * @param options - The options for initializing the data grid.\n     */\n    constructor(options = {}) {\n        super();\n        this._scrollX = 0;\n        this._scrollY = 0;\n        this._viewportWidth = 0;\n        this._viewportHeight = 0;\n        this._mousedown = false;\n        this._keyHandler = null;\n        this._mouseHandler = null;\n        this._vScrollBarMinWidth = 0;\n        this._hScrollBarMinHeight = 0;\n        this._dpiRatio = Math.ceil(window.devicePixelRatio);\n        this._dataModel = null;\n        this._selectionModel = null;\n        this._editingEnabled = false;\n        this.addClass('lm-DataGrid');\n        // Parse the simple options.\n        this._style = options.style || DataGrid.defaultStyle;\n        this._stretchLastRow = options.stretchLastRow || false;\n        this._stretchLastColumn = options.stretchLastColumn || false;\n        this._headerVisibility = options.headerVisibility || 'all';\n        this._cellRenderers = options.cellRenderers || new RendererMap();\n        this._copyConfig = options.copyConfig || DataGrid.defaultCopyConfig;\n        // Connect to the renderer map changed signal.\n        this._cellRenderers.changed.connect(this._onRenderersChanged, this);\n        // Parse the default sizes.\n        let defaultSizes = options.defaultSizes || DataGrid.defaultSizes;\n        let minimumSizes = options.minimumSizes || DataGrid.minimumSizes;\n        // Set up the sections lists.\n        this._rowSections = new SectionList({\n            defaultSize: defaultSizes.rowHeight,\n            minimumSize: minimumSizes.rowHeight\n        });\n        this._columnSections = new SectionList({\n            defaultSize: defaultSizes.columnWidth,\n            minimumSize: minimumSizes.columnWidth\n        });\n        this._rowHeaderSections = new SectionList({\n            defaultSize: defaultSizes.rowHeaderWidth,\n            minimumSize: minimumSizes.rowHeaderWidth\n        });\n        this._columnHeaderSections = new SectionList({\n            defaultSize: defaultSizes.columnHeaderHeight,\n            minimumSize: minimumSizes.columnHeaderHeight\n        });\n        // Create the canvas, buffer, and overlay objects.\n        this._canvas = Private$1.createCanvas();\n        this._buffer = Private$1.createCanvas();\n        this._overlay = Private$1.createCanvas();\n        // Get the graphics contexts for the canvases.\n        this._canvasGC = this._canvas.getContext('2d');\n        this._bufferGC = this._buffer.getContext('2d');\n        this._overlayGC = this._overlay.getContext('2d');\n        // Set up the on-screen canvas.\n        this._canvas.style.position = 'absolute';\n        this._canvas.style.top = '0px';\n        this._canvas.style.left = '0px';\n        this._canvas.style.width = '0px';\n        this._canvas.style.height = '0px';\n        // Set up the on-screen overlay.\n        this._overlay.style.position = 'absolute';\n        this._overlay.style.top = '0px';\n        this._overlay.style.left = '0px';\n        this._overlay.style.width = '0px';\n        this._overlay.style.height = '0px';\n        // Create the internal widgets for the data grid.\n        this._viewport = new Widget();\n        this._viewport.node.tabIndex = -1;\n        this._viewport.node.style.outline = 'none';\n        this._vScrollBar = new ScrollBar({ orientation: 'vertical' });\n        this._hScrollBar = new ScrollBar({ orientation: 'horizontal' });\n        this._scrollCorner = new Widget();\n        this._editorController = new CellEditorController();\n        // Add the extra class names to the child widgets.\n        this._viewport.addClass('lm-DataGrid-viewport');\n        this._vScrollBar.addClass('lm-DataGrid-scrollBar');\n        this._hScrollBar.addClass('lm-DataGrid-scrollBar');\n        this._scrollCorner.addClass('lm-DataGrid-scrollCorner');\n        // Add the on-screen canvas to the viewport node.\n        this._viewport.node.appendChild(this._canvas);\n        // Add the on-screen overlay to the viewport node.\n        this._viewport.node.appendChild(this._overlay);\n        // Install the message hooks.\n        MessageLoop.installMessageHook(this._viewport, this);\n        MessageLoop.installMessageHook(this._hScrollBar, this);\n        MessageLoop.installMessageHook(this._vScrollBar, this);\n        // Hide the scroll bars and corner from the outset.\n        this._vScrollBar.hide();\n        this._hScrollBar.hide();\n        this._scrollCorner.hide();\n        // Connect to the scroll bar signals.\n        this._vScrollBar.thumbMoved.connect(this._onThumbMoved, this);\n        this._hScrollBar.thumbMoved.connect(this._onThumbMoved, this);\n        this._vScrollBar.pageRequested.connect(this._onPageRequested, this);\n        this._hScrollBar.pageRequested.connect(this._onPageRequested, this);\n        this._vScrollBar.stepRequested.connect(this._onStepRequested, this);\n        this._hScrollBar.stepRequested.connect(this._onStepRequested, this);\n        // Set the layout cell config for the child widgets.\n        GridLayout.setCellConfig(this._viewport, { row: 0, column: 0 });\n        GridLayout.setCellConfig(this._vScrollBar, { row: 0, column: 1 });\n        GridLayout.setCellConfig(this._hScrollBar, { row: 1, column: 0 });\n        GridLayout.setCellConfig(this._scrollCorner, { row: 1, column: 1 });\n        // Create the layout for the data grid.\n        let layout = new GridLayout({\n            rowCount: 2,\n            columnCount: 2,\n            rowSpacing: 0,\n            columnSpacing: 0,\n            fitPolicy: 'set-no-constraint'\n        });\n        // Set the stretch factors for the grid.\n        layout.setRowStretch(0, 1);\n        layout.setRowStretch(1, 0);\n        layout.setColumnStretch(0, 1);\n        layout.setColumnStretch(1, 0);\n        // Add the child widgets to the layout.\n        layout.addWidget(this._viewport);\n        layout.addWidget(this._vScrollBar);\n        layout.addWidget(this._hScrollBar);\n        layout.addWidget(this._scrollCorner);\n        // Install the layout on the data grid.\n        this.layout = layout;\n    }\n    /**\n     * Dispose of the resources held by the widgets.\n     */\n    dispose() {\n        // Release the mouse.\n        this._releaseMouse();\n        // Dispose of the handlers.\n        if (this._keyHandler) {\n            this._keyHandler.dispose();\n        }\n        if (this._mouseHandler) {\n            this._mouseHandler.dispose();\n        }\n        this._keyHandler = null;\n        this._mouseHandler = null;\n        // Clear the models.\n        this._dataModel = null;\n        this._selectionModel = null;\n        // Clear the section lists.\n        this._rowSections.clear();\n        this._columnSections.clear();\n        this._rowHeaderSections.clear();\n        this._columnHeaderSections.clear();\n        // Dispose of the base class.\n        super.dispose();\n    }\n    /**\n     * Get the data model for the data grid.\n     */\n    get dataModel() {\n        return this._dataModel;\n    }\n    /**\n     * Set the data model for the data grid.\n     *\n     * #### Notes\n     * This will automatically remove the current selection model.\n     */\n    set dataModel(value) {\n        // Do nothing if the model does not change.\n        if (this._dataModel === value) {\n            return;\n        }\n        // Release the mouse.\n        this._releaseMouse();\n        // Clear the selection model.\n        this.selectionModel = null;\n        // Disconnect the change handler from the old model.\n        if (this._dataModel) {\n            this._dataModel.changed.disconnect(this._onDataModelChanged, this);\n        }\n        // Connect the change handler for the new model.\n        if (value) {\n            value.changed.connect(this._onDataModelChanged, this);\n        }\n        // Update the internal model reference.\n        this._dataModel = value;\n        // Clear the section lists.\n        this._rowSections.clear();\n        this._columnSections.clear();\n        this._rowHeaderSections.clear();\n        this._columnHeaderSections.clear();\n        // Populate the section lists.\n        if (value) {\n            this._rowSections.insert(0, value.rowCount('body'));\n            this._columnSections.insert(0, value.columnCount('body'));\n            this._rowHeaderSections.insert(0, value.columnCount('row-header'));\n            this._columnHeaderSections.insert(0, value.rowCount('column-header'));\n        }\n        // Reset the scroll position.\n        this._scrollX = 0;\n        this._scrollY = 0;\n        // Sync the viewport.\n        this._syncViewport();\n    }\n    /**\n     * Get the selection model for the data grid.\n     */\n    get selectionModel() {\n        return this._selectionModel;\n    }\n    /**\n     * Set the selection model for the data grid.\n     */\n    set selectionModel(value) {\n        // Do nothing if the selection model does not change.\n        if (this._selectionModel === value) {\n            return;\n        }\n        // Release the mouse.\n        this._releaseMouse();\n        // Ensure the data models are a match.\n        if (value && value.dataModel !== this._dataModel) {\n            throw new Error('SelectionModel.dataModel !== DataGrid.dataModel');\n        }\n        // Disconnect the change handler from the old model.\n        if (this._selectionModel) {\n            this._selectionModel.changed.disconnect(this._onSelectionsChanged, this);\n        }\n        // Connect the change handler for the new model.\n        if (value) {\n            value.changed.connect(this._onSelectionsChanged, this);\n        }\n        // Update the internal selection model reference.\n        this._selectionModel = value;\n        // Schedule a repaint of the overlay.\n        this.repaintOverlay();\n    }\n    /**\n     * Get the key handler for the data grid.\n     */\n    get keyHandler() {\n        return this._keyHandler;\n    }\n    /**\n     * Set the key handler for the data grid.\n     */\n    set keyHandler(value) {\n        this._keyHandler = value;\n    }\n    /**\n     * Get the mouse handler for the data grid.\n     */\n    get mouseHandler() {\n        return this._mouseHandler;\n    }\n    /**\n     * Set the mouse handler for the data grid.\n     */\n    set mouseHandler(value) {\n        // Bail early if the mouse handler does not change.\n        if (this._mouseHandler === value) {\n            return;\n        }\n        // Release the mouse.\n        this._releaseMouse();\n        // Update the internal mouse handler.\n        this._mouseHandler = value;\n    }\n    /**\n     * Get the style for the data grid.\n     */\n    get style() {\n        return this._style;\n    }\n    /**\n     * Set the style for the data grid.\n     */\n    set style(value) {\n        // Bail if the style does not change.\n        if (this._style === value) {\n            return;\n        }\n        // Update the internal style.\n        this._style = { ...value };\n        // Schedule a repaint of the content.\n        this.repaintContent();\n        // Schedule a repaint of the overlay.\n        this.repaintOverlay();\n    }\n    /**\n     * Get the cell renderer map for the data grid.\n     */\n    get cellRenderers() {\n        return this._cellRenderers;\n    }\n    /**\n     * Set the cell renderer map for the data grid.\n     */\n    set cellRenderers(value) {\n        // Bail if the renderer map does not change.\n        if (this._cellRenderers === value) {\n            return;\n        }\n        // Disconnect the old map.\n        this._cellRenderers.changed.disconnect(this._onRenderersChanged, this);\n        // Connect the new map.\n        value.changed.connect(this._onRenderersChanged, this);\n        // Update the internal renderer map.\n        this._cellRenderers = value;\n        // Schedule a repaint of the grid content.\n        this.repaintContent();\n    }\n    /**\n     * Get the header visibility for the data grid.\n     */\n    get headerVisibility() {\n        return this._headerVisibility;\n    }\n    /**\n     * Set the header visibility for the data grid.\n     */\n    set headerVisibility(value) {\n        // Bail if the visibility does not change.\n        if (this._headerVisibility === value) {\n            return;\n        }\n        // Update the internal visibility.\n        this._headerVisibility = value;\n        // Sync the viewport.\n        this._syncViewport();\n    }\n    /**\n     * Get the default sizes for the various sections of the data grid.\n     */\n    get defaultSizes() {\n        let rowHeight = this._rowSections.defaultSize;\n        let columnWidth = this._columnSections.defaultSize;\n        let rowHeaderWidth = this._rowHeaderSections.defaultSize;\n        let columnHeaderHeight = this._columnHeaderSections.defaultSize;\n        return { rowHeight, columnWidth, rowHeaderWidth, columnHeaderHeight };\n    }\n    /**\n     * Set the default sizes for the various sections of the data grid.\n     */\n    set defaultSizes(value) {\n        // Update the section default sizes.\n        this._rowSections.defaultSize = value.rowHeight;\n        this._columnSections.defaultSize = value.columnWidth;\n        this._rowHeaderSections.defaultSize = value.rowHeaderWidth;\n        this._columnHeaderSections.defaultSize = value.columnHeaderHeight;\n        // Sync the viewport.\n        this._syncViewport();\n    }\n    /**\n     * Get the minimum sizes for the various sections of the data grid.\n     */\n    get minimumSizes() {\n        let rowHeight = this._rowSections.minimumSize;\n        let columnWidth = this._columnSections.minimumSize;\n        let rowHeaderWidth = this._rowHeaderSections.minimumSize;\n        let columnHeaderHeight = this._columnHeaderSections.minimumSize;\n        return { rowHeight, columnWidth, rowHeaderWidth, columnHeaderHeight };\n    }\n    /**\n     * Set the minimum sizes for the various sections of the data grid.\n     */\n    set minimumSizes(value) {\n        // Update the section default sizes.\n        this._rowSections.minimumSize = value.rowHeight;\n        this._columnSections.minimumSize = value.columnWidth;\n        this._rowHeaderSections.minimumSize = value.rowHeaderWidth;\n        this._columnHeaderSections.minimumSize = value.columnHeaderHeight;\n        // Sync the viewport.\n        this._syncViewport();\n    }\n    /**\n     * Get the copy configuration for the data grid.\n     */\n    get copyConfig() {\n        return this._copyConfig;\n    }\n    /**\n     * Set the copy configuration for the data grid.\n     */\n    set copyConfig(value) {\n        this._copyConfig = value;\n    }\n    /**\n     * Get whether the last row is stretched.\n     */\n    get stretchLastRow() {\n        return this._stretchLastRow;\n    }\n    /**\n     * Set whether the last row is stretched.\n     */\n    set stretchLastRow(value) {\n        // Bail early if the value does not change.\n        if (value === this._stretchLastRow) {\n            return;\n        }\n        // Update the internal value.\n        this._stretchLastRow = value;\n        // Sync the viewport\n        this._syncViewport();\n    }\n    /**\n     * Get whether the last column is stretched.\n     */\n    get stretchLastColumn() {\n        return this._stretchLastColumn;\n    }\n    /**\n     * Set whether the last column is stretched.\n     */\n    set stretchLastColumn(value) {\n        // Bail early if the value does not change.\n        if (value === this._stretchLastColumn) {\n            return;\n        }\n        // Update the internal value.\n        this._stretchLastColumn = value;\n        // Sync the viewport\n        this._syncViewport();\n    }\n    /**\n     * The virtual width of the row headers.\n     */\n    get headerWidth() {\n        if (this._headerVisibility === 'none') {\n            return 0;\n        }\n        if (this._headerVisibility === 'column') {\n            return 0;\n        }\n        return this._rowHeaderSections.length;\n    }\n    /**\n     * The virtual height of the column headers.\n     */\n    get headerHeight() {\n        if (this._headerVisibility === 'none') {\n            return 0;\n        }\n        if (this._headerVisibility === 'row') {\n            return 0;\n        }\n        return this._columnHeaderSections.length;\n    }\n    /**\n     * The virtual width of the grid body.\n     *\n     * #### Notes\n     * This does *not* account for a stretched last column.\n     */\n    get bodyWidth() {\n        return this._columnSections.length;\n    }\n    /**\n     * The virtual height of the grid body.\n     *\n     * #### Notes\n     * This does *not* account for a stretched last row.\n     */\n    get bodyHeight() {\n        return this._rowSections.length;\n    }\n    /**\n     * The virtual width of the entire grid.\n     *\n     * #### Notes\n     * This does *not* account for a stretched last column.\n     */\n    get totalWidth() {\n        return this.headerWidth + this.bodyWidth;\n    }\n    /**\n     * The virtual height of the entire grid.\n     *\n     * #### Notes\n     * This does *not* account for a stretched last row.\n     */\n    get totalHeight() {\n        return this.headerHeight + this.bodyHeight;\n    }\n    /**\n     * The actual width of the viewport.\n     */\n    get viewportWidth() {\n        return this._viewportWidth;\n    }\n    /**\n     * The actual height of the viewport.\n     */\n    get viewportHeight() {\n        return this._viewportHeight;\n    }\n    /**\n     * The width of the visible portion of the grid body.\n     */\n    get pageWidth() {\n        return Math.max(0, this.viewportWidth - this.headerWidth);\n    }\n    /**\n     * The height of the visible portion of the grid body.\n     */\n    get pageHeight() {\n        return Math.max(0, this.viewportHeight - this.headerHeight);\n    }\n    /**\n     * The current scroll X position of the viewport.\n     */\n    get scrollX() {\n        return this._hScrollBar.value;\n    }\n    /**\n     * The current scroll Y position of the viewport.\n     */\n    get scrollY() {\n        return this._vScrollBar.value;\n    }\n    /**\n     * The maximum scroll X position for the grid.\n     */\n    get maxScrollX() {\n        return Math.max(0, this.bodyWidth - this.pageWidth - 1);\n    }\n    /**\n     * The maximum scroll Y position for the grid.\n     */\n    get maxScrollY() {\n        return Math.max(0, this.bodyHeight - this.pageHeight - 1);\n    }\n    /**\n     * The viewport widget for the data grid.\n     */\n    get viewport() {\n        return this._viewport;\n    }\n    /**\n     * The cell editor controller object for the data grid.\n     */\n    get editorController() {\n        return this._editorController;\n    }\n    set editorController(controller) {\n        this._editorController = controller;\n    }\n    /**\n     * Whether the cell editing is enabled for the data grid.\n     */\n    get editingEnabled() {\n        return this._editingEnabled;\n    }\n    set editingEnabled(enabled) {\n        this._editingEnabled = enabled;\n    }\n    /**\n     * Whether the grid cells are editable.\n     *\n     * `editingEnabled` flag must be on and grid must have required\n     * selection model, editor controller and data model properties.\n     */\n    get editable() {\n        return (this._editingEnabled &&\n            this._selectionModel !== null &&\n            this._editorController !== null &&\n            this.dataModel instanceof MutableDataModel);\n    }\n    /**\n     * The rendering context for painting the data grid.\n     */\n    get canvasGC() {\n        return this._canvasGC;\n    }\n    /**\n     * The row sections of the data grid.\n     */\n    get rowSections() {\n        return this._rowSections;\n    }\n    /**\n     * The column sections of the data grid.\n     */\n    get columnSections() {\n        return this._columnSections;\n    }\n    /**\n     * The row header sections of the data grid.\n     */\n    get rowHeaderSections() {\n        return this._rowHeaderSections;\n    }\n    /**\n     * The column header sections of the data grid.\n     */\n    get columnHeaderSections() {\n        return this._columnHeaderSections;\n    }\n    /**\n     * Scroll the grid to the specified row.\n     *\n     * @param row - The row index of the cell.\n     *\n     * #### Notes\n     * This is a no-op if the row is already visible.\n     */\n    scrollToRow(row) {\n        // Fetch the row count.\n        let nr = this._rowSections.count;\n        // Bail early if there is no content.\n        if (nr === 0) {\n            return;\n        }\n        // Floor the row index.\n        row = Math.floor(row);\n        // Clamp the row index.\n        row = Math.max(0, Math.min(row, nr - 1));\n        // Get the virtual bounds of the row.\n        let y1 = this._rowSections.offsetOf(row);\n        let y2 = this._rowSections.extentOf(row);\n        // Get the virtual bounds of the viewport.\n        let vy1 = this._scrollY;\n        let vy2 = this._scrollY + this.pageHeight - 1;\n        // Set up the delta variables.\n        let dy = 0;\n        // Compute the delta Y scroll.\n        if (y1 < vy1) {\n            dy = y1 - vy1 - 10;\n        }\n        else if (y2 > vy2) {\n            dy = y2 - vy2 + 10;\n        }\n        // Bail early if no scroll is needed.\n        if (dy === 0) {\n            return;\n        }\n        // Scroll by the computed delta.\n        this.scrollBy(0, dy);\n    }\n    /**\n     * Scroll the grid to the specified column.\n     *\n     * @param column - The column index of the cell.\n     *\n     * #### Notes\n     * This is a no-op if the column is already visible.\n     */\n    scrollToColumn(column) {\n        // Fetch the column count.\n        let nc = this._columnSections.count;\n        // Bail early if there is no content.\n        if (nc === 0) {\n            return;\n        }\n        // Floor the column index.\n        column = Math.floor(column);\n        // Clamp the column index.\n        column = Math.max(0, Math.min(column, nc - 1));\n        // Get the virtual bounds of the column.\n        let x1 = this._columnSections.offsetOf(column);\n        let x2 = this._columnSections.extentOf(column);\n        // Get the virtual bounds of the viewport.\n        let vx1 = this._scrollX;\n        let vx2 = this._scrollX + this.pageWidth - 1;\n        // Set up the delta variables.\n        let dx = 0;\n        // Compute the delta X scroll.\n        if (x1 < vx1) {\n            dx = x1 - vx1 - 10;\n        }\n        else if (x2 > vx2) {\n            dx = x2 - vx2 + 10;\n        }\n        // Bail early if no scroll is needed.\n        if (dx === 0) {\n            return;\n        }\n        // Scroll by the computed delta.\n        this.scrollBy(dx, 0);\n    }\n    /**\n     * Scroll the grid to the specified cell.\n     *\n     * @param row - The row index of the cell.\n     *\n     * @param column - The column index of the cell.\n     *\n     * #### Notes\n     * This is a no-op if the cell is already visible.\n     */\n    scrollToCell(row, column) {\n        // Fetch the row and column count.\n        let nr = this._rowSections.count;\n        let nc = this._columnSections.count;\n        // Bail early if there is no content.\n        if (nr === 0 || nc === 0) {\n            return;\n        }\n        // Floor the cell index.\n        row = Math.floor(row);\n        column = Math.floor(column);\n        // Clamp the cell index.\n        row = Math.max(0, Math.min(row, nr - 1));\n        column = Math.max(0, Math.min(column, nc - 1));\n        // Get the virtual bounds of the cell.\n        let x1 = this._columnSections.offsetOf(column);\n        let x2 = this._columnSections.extentOf(column);\n        let y1 = this._rowSections.offsetOf(row);\n        let y2 = this._rowSections.extentOf(row);\n        // Get the virtual bounds of the viewport.\n        let vx1 = this._scrollX;\n        let vx2 = this._scrollX + this.pageWidth - 1;\n        let vy1 = this._scrollY;\n        let vy2 = this._scrollY + this.pageHeight - 1;\n        // Set up the delta variables.\n        let dx = 0;\n        let dy = 0;\n        // Compute the delta X scroll.\n        if (x1 < vx1) {\n            dx = x1 - vx1 - 10;\n        }\n        else if (x2 > vx2) {\n            dx = x2 - vx2 + 10;\n        }\n        // Compute the delta Y scroll.\n        if (y1 < vy1) {\n            dy = y1 - vy1 - 10;\n        }\n        else if (y2 > vy2) {\n            dy = y2 - vy2 + 10;\n        }\n        // Bail early if no scroll is needed.\n        if (dx === 0 && dy === 0) {\n            return;\n        }\n        // Scroll by the computed delta.\n        this.scrollBy(dx, dy);\n    }\n    /**\n     * Move cursor down/up/left/right while making sure it remains\n     * within the bounds of selected rectangles\n     *\n     * @param direction - The direction of the movement.\n     */\n    moveCursor(direction) {\n        // Bail early if there is no selection\n        if (!this.dataModel ||\n            !this._selectionModel ||\n            this._selectionModel.isEmpty) {\n            return;\n        }\n        const iter = this._selectionModel.selections();\n        const onlyOne = iter.next() && !iter.next();\n        // if there is a single selection that is a single cell selection\n        // then move the selection and cursor within grid bounds\n        if (onlyOne) {\n            const currentSel = this._selectionModel.currentSelection();\n            if (currentSel.r1 === currentSel.r2 && currentSel.c1 === currentSel.c2) {\n                const dr = direction === 'down' ? 1 : direction === 'up' ? -1 : 0;\n                const dc = direction === 'right' ? 1 : direction === 'left' ? -1 : 0;\n                let newRow = currentSel.r1 + dr;\n                let newColumn = currentSel.c1 + dc;\n                const rowCount = this.dataModel.rowCount('body');\n                const columnCount = this.dataModel.columnCount('body');\n                if (newRow >= rowCount) {\n                    newRow = 0;\n                    newColumn += 1;\n                }\n                else if (newRow === -1) {\n                    newRow = rowCount - 1;\n                    newColumn -= 1;\n                }\n                if (newColumn >= columnCount) {\n                    newColumn = 0;\n                    newRow += 1;\n                    if (newRow >= rowCount) {\n                        newRow = 0;\n                    }\n                }\n                else if (newColumn === -1) {\n                    newColumn = columnCount - 1;\n                    newRow -= 1;\n                    if (newRow === -1) {\n                        newRow = rowCount - 1;\n                    }\n                }\n                this._selectionModel.select({\n                    r1: newRow,\n                    c1: newColumn,\n                    r2: newRow,\n                    c2: newColumn,\n                    cursorRow: newRow,\n                    cursorColumn: newColumn,\n                    clear: 'all'\n                });\n                return;\n            }\n        }\n        // if there are multiple selections, move cursor\n        // within selection rectangles\n        this._selectionModel.moveCursorWithinSelections(direction);\n    }\n    /**\n     * Scroll the grid to the current cursor position.\n     *\n     * #### Notes\n     * This is a no-op if the cursor is already visible or\n     * if there is no selection model installed on the grid.\n     */\n    scrollToCursor() {\n        // Bail early if there is no selection model.\n        if (!this._selectionModel) {\n            return;\n        }\n        // Fetch the cursor row and column.\n        let row = this._selectionModel.cursorRow;\n        let column = this._selectionModel.cursorColumn;\n        // Scroll to the cursor cell.\n        this.scrollToCell(row, column);\n    }\n    /**\n     * Scroll the viewport by the specified amount.\n     *\n     * @param dx - The X scroll amount.\n     *\n     * @param dy - The Y scroll amount.\n     */\n    scrollBy(dx, dy) {\n        this.scrollTo(this.scrollX + dx, this.scrollY + dy);\n    }\n    /**\n     * Scroll the viewport by one page.\n     *\n     * @param dir - The desired direction of the scroll.\n     */\n    scrollByPage(dir) {\n        let dx = 0;\n        let dy = 0;\n        switch (dir) {\n            case 'up':\n                dy = -this.pageHeight;\n                break;\n            case 'down':\n                dy = this.pageHeight;\n                break;\n            case 'left':\n                dx = -this.pageWidth;\n                break;\n            case 'right':\n                dx = this.pageWidth;\n                break;\n            default:\n                throw 'unreachable';\n        }\n        this.scrollTo(this.scrollX + dx, this.scrollY + dy);\n    }\n    /**\n     * Scroll the viewport by one cell-aligned step.\n     *\n     * @param dir - The desired direction of the scroll.\n     */\n    scrollByStep(dir) {\n        let r;\n        let c;\n        let x = this.scrollX;\n        let y = this.scrollY;\n        let rows = this._rowSections;\n        let columns = this._columnSections;\n        switch (dir) {\n            case 'up':\n                r = rows.indexOf(y - 1);\n                y = r < 0 ? y : rows.offsetOf(r);\n                break;\n            case 'down':\n                r = rows.indexOf(y);\n                y = r < 0 ? y : rows.offsetOf(r) + rows.sizeOf(r);\n                break;\n            case 'left':\n                c = columns.indexOf(x - 1);\n                x = c < 0 ? x : columns.offsetOf(c);\n                break;\n            case 'right':\n                c = columns.indexOf(x);\n                x = c < 0 ? x : columns.offsetOf(c) + columns.sizeOf(c);\n                break;\n            default:\n                throw 'unreachable';\n        }\n        this.scrollTo(x, y);\n    }\n    /**\n     * Scroll to the specified offset position.\n     *\n     * @param x - The desired X position.\n     *\n     * @param y - The desired Y position.\n     */\n    scrollTo(x, y) {\n        // Floor and clamp the position to the allowable range.\n        x = Math.max(0, Math.min(Math.floor(x), this.maxScrollX));\n        y = Math.max(0, Math.min(Math.floor(y), this.maxScrollY));\n        // Update the scroll bar values with the desired position.\n        this._hScrollBar.value = x;\n        this._vScrollBar.value = y;\n        // Post a scroll request message to the viewport.\n        MessageLoop.postMessage(this._viewport, Private$1.ScrollRequest);\n    }\n    /**\n     * Get the row count for a particular region in the data grid.\n     *\n     * @param region - The row region of interest.\n     *\n     * @returns The row count for the specified region.\n     */\n    rowCount(region) {\n        let count;\n        if (region === 'body') {\n            count = this._rowSections.count;\n        }\n        else {\n            count = this._columnHeaderSections.count;\n        }\n        return count;\n    }\n    /**\n     * Get the column count for a particular region in the data grid.\n     *\n     * @param region - The column region of interest.\n     *\n     * @returns The column count for the specified region.\n     */\n    columnCount(region) {\n        let count;\n        if (region === 'body') {\n            count = this._columnSections.count;\n        }\n        else {\n            count = this._rowHeaderSections.count;\n        }\n        return count;\n    }\n    /**\n     * Get the row at a virtual offset in the data grid.\n     *\n     * @param region - The region which holds the row of interest.\n     *\n     * @param offset - The virtual offset of the row of interest.\n     *\n     * @returns The index of the row, or `-1` if the offset is out of range.\n     *\n     * #### Notes\n     * This method accounts for a stretched last row.\n     */\n    rowAt(region, offset) {\n        // Bail early if the offset is negative.\n        if (offset < 0) {\n            return -1;\n        }\n        // Return early for the column header region.\n        if (region === 'column-header') {\n            return this._columnHeaderSections.indexOf(offset);\n        }\n        // Fetch the index.\n        let index = this._rowSections.indexOf(offset);\n        // Return early if the section is found.\n        if (index >= 0) {\n            return index;\n        }\n        // Bail early if the last row is not stretched.\n        if (!this._stretchLastRow) {\n            return -1;\n        }\n        // Fetch the geometry.\n        let bh = this.bodyHeight;\n        let ph = this.pageHeight;\n        // Bail early if no row stretching is required.\n        if (ph <= bh) {\n            return -1;\n        }\n        // Bail early if the offset is out of bounds.\n        if (offset >= ph) {\n            return -1;\n        }\n        // Otherwise, return the last row.\n        return this._rowSections.count - 1;\n    }\n    /**\n     * Get the column at a virtual offset in the data grid.\n     *\n     * @param region - The region which holds the column of interest.\n     *\n     * @param offset - The virtual offset of the column of interest.\n     *\n     * @returns The index of the column, or `-1` if the offset is out of range.\n     *\n     * #### Notes\n     * This method accounts for a stretched last column.\n     */\n    columnAt(region, offset) {\n        if (offset < 0) {\n            return -1;\n        }\n        // Return early for the row header region.\n        if (region === 'row-header') {\n            return this._rowHeaderSections.indexOf(offset);\n        }\n        // Fetch the index.\n        let index = this._columnSections.indexOf(offset);\n        // Return early if the section is found.\n        if (index >= 0) {\n            return index;\n        }\n        // Bail early if the last column is not stretched.\n        if (!this._stretchLastColumn) {\n            return -1;\n        }\n        // Fetch the geometry.\n        let bw = this.bodyWidth;\n        let pw = this.pageWidth;\n        // Bail early if no column stretching is required.\n        if (pw <= bw) {\n            return -1;\n        }\n        // Bail early if the offset is out of bounds.\n        if (offset >= pw) {\n            return -1;\n        }\n        // Otherwise, return the last column.\n        return this._columnSections.count - 1;\n    }\n    /**\n     * Get the offset of a row in the data grid.\n     *\n     * @param region - The region which holds the row of interest.\n     *\n     * @param index - The index of the row of interest.\n     *\n     * @returns The offset of the row, or `-1` if the index is out of range.\n     *\n     * #### Notes\n     * A stretched last row has no effect on the return value.\n     */\n    rowOffset(region, index) {\n        let offset;\n        if (region === 'body') {\n            offset = this._rowSections.offsetOf(index);\n        }\n        else {\n            offset = this._columnHeaderSections.offsetOf(index);\n        }\n        return offset;\n    }\n    /**\n     * Get the offset of a column in the data grid.\n     *\n     * @param region - The region which holds the column of interest.\n     *\n     * @param index - The index of the column of interest.\n     *\n     * @returns The offset of the column, or `-1` if the index is out of range.\n     *\n     * #### Notes\n     * A stretched last column has no effect on the return value.\n     */\n    columnOffset(region, index) {\n        let offset;\n        if (region === 'body') {\n            offset = this._columnSections.offsetOf(index);\n        }\n        else {\n            offset = this._rowHeaderSections.offsetOf(index);\n        }\n        return offset;\n    }\n    /**\n     * Get the size of a row in the data grid.\n     *\n     * @param region - The region which holds the row of interest.\n     *\n     * @param index - The index of the row of interest.\n     *\n     * @returns The size of the row, or `-1` if the index is out of range.\n     *\n     * #### Notes\n     * This method accounts for a stretched last row.\n     */\n    rowSize(region, index) {\n        // Return early for the column header region.\n        if (region === 'column-header') {\n            return this._columnHeaderSections.sizeOf(index);\n        }\n        // Fetch the row size.\n        let size = this._rowSections.sizeOf(index);\n        // Bail early if the index is out of bounds.\n        if (size < 0) {\n            return size;\n        }\n        // Return early if the last row is not stretched.\n        if (!this._stretchLastRow) {\n            return size;\n        }\n        // Return early if its not the last row.\n        if (index < this._rowSections.count - 1) {\n            return size;\n        }\n        // Fetch the geometry.\n        let bh = this.bodyHeight;\n        let ph = this.pageHeight;\n        // Return early if no stretching is needed.\n        if (ph <= bh) {\n            return size;\n        }\n        // Return the adjusted size.\n        return size + (ph - bh);\n    }\n    /**\n     * Get the size of a column in the data grid.\n     *\n     * @param region - The region which holds the column of interest.\n     *\n     * @param index - The index of the column of interest.\n     *\n     * @returns The size of the column, or `-1` if the index is out of range.\n     *\n     * #### Notes\n     * This method accounts for a stretched last column.\n     */\n    columnSize(region, index) {\n        // Return early for the row header region.\n        if (region === 'row-header') {\n            return this._rowHeaderSections.sizeOf(index);\n        }\n        // Fetch the column size.\n        let size = this._columnSections.sizeOf(index);\n        // Bail early if the index is out of bounds.\n        if (size < 0) {\n            return size;\n        }\n        // Return early if the last column is not stretched.\n        if (!this._stretchLastColumn) {\n            return size;\n        }\n        // Return early if its not the last column.\n        if (index < this._columnSections.count - 1) {\n            return size;\n        }\n        // Fetch the geometry.\n        let bw = this.bodyWidth;\n        let pw = this.pageWidth;\n        // Return early if no stretching is needed.\n        if (pw <= bw) {\n            return size;\n        }\n        // Return the adjusted size.\n        return size + (pw - bw);\n    }\n    /**\n     * Resize a row in the data grid.\n     *\n     * @param region - The region which holds the row of interest.\n     *\n     * @param index - The index of the row of interest.\n     *\n     * @param size - The desired size of the row.\n     */\n    resizeRow(region, index, size) {\n        let msg = new Private$1.RowResizeRequest(region, index, size);\n        MessageLoop.postMessage(this._viewport, msg);\n    }\n    /**\n     * Resize a column in the data grid.\n     *\n     * @param region - The region which holds the column of interest.\n     *\n     * @param index - The index of the column of interest.\n     *\n     * @param size - The desired size of the column.\n     */\n    resizeColumn(region, index, size) {\n        let msg = new Private$1.ColumnResizeRequest(region, index, size);\n        MessageLoop.postMessage(this._viewport, msg);\n    }\n    /**\n     * Reset modified rows to their default size.\n     *\n     * @param region - The row region of interest.\n     */\n    resetRows(region) {\n        switch (region) {\n            case 'all':\n                this._rowSections.reset();\n                this._columnHeaderSections.reset();\n                break;\n            case 'body':\n                this._rowSections.reset();\n                break;\n            case 'column-header':\n                this._columnHeaderSections.reset();\n                break;\n            default:\n                throw 'unreachable';\n        }\n        this.repaintContent();\n        this.repaintOverlay();\n    }\n    /**\n     * Reset modified columns to their default size.\n     *\n     * @param region - The column region of interest.\n     */\n    resetColumns(region) {\n        switch (region) {\n            case 'all':\n                this._columnSections.reset();\n                this._rowHeaderSections.reset();\n                break;\n            case 'body':\n                this._columnSections.reset();\n                break;\n            case 'row-header':\n                this._rowHeaderSections.reset();\n                break;\n            default:\n                throw 'unreachable';\n        }\n        this.repaintContent();\n        this.repaintOverlay();\n    }\n    /**\n     * Auto sizes column-header widths based on their text content.\n     * @param area which area to resize: 'body', 'row-header' or 'all'.\n     * @param padding padding added to resized columns (pixels).\n     * @param numCols specify cap on the number of column resizes (optional).\n     */\n    fitColumnNames(area = 'all', padding = 15, numCols) {\n        // Attempt resizing only if a data model is present.\n        if (this.dataModel) {\n            // Tracking remaining columns to be resized if numCols arg passed.\n            let colsRemaining = numCols === undefined || numCols < 0 ? undefined : numCols;\n            if (area === 'row-header' || area === 'all') {\n                // Respecting any column resize cap, if one has been passed.\n                if (colsRemaining !== undefined) {\n                    const rowColumnCount = this.dataModel.columnCount('row-header');\n                    /*\n                      If we have more row-header columns than columns available\n                      for resize, resize only remaining columns as per allowance\n                      and set remaining resize allowance number to 0.\n                    */\n                    if (colsRemaining - rowColumnCount < 0) {\n                        this._fitRowColumnHeaders(this.dataModel, padding, colsRemaining);\n                        colsRemaining = 0;\n                    }\n                    else {\n                        /*\n                          Otherwise the entire row-header column count can be resized.\n                          Resize all row-header columns and subtract from remaining\n                          column resize allowance.\n                        */\n                        this._fitRowColumnHeaders(this.dataModel, padding, rowColumnCount);\n                        colsRemaining = colsRemaining - rowColumnCount;\n                    }\n                }\n                else {\n                    // No column resize cap passed - resizing all columns.\n                    this._fitRowColumnHeaders(this.dataModel, padding);\n                }\n            }\n            if (area === 'body' || area === 'all') {\n                // Respecting any column resize cap, if one has been passed.\n                if (colsRemaining !== undefined) {\n                    const bodyColumnCount = this.dataModel.columnCount('body');\n                    /*\n                      If we have more body columns than columns available\n                      for resize, resize only remaining columns as per allowance\n                      and set remaining resize allowance number to 0.\n                    */\n                    if (colsRemaining - bodyColumnCount < 0) {\n                        this._fitBodyColumnHeaders(this.dataModel, padding, colsRemaining);\n                    }\n                    else {\n                        /*\n                          Otherwise the entire body column count can be resized.\n                          Resize based on the smallest number between remaining\n                          resize allowance and body column count.\n                        */\n                        this._fitBodyColumnHeaders(this.dataModel, padding, Math.min(colsRemaining, bodyColumnCount));\n                    }\n                }\n                else {\n                    // No column resize cap passed - resizing all columns.\n                    this._fitBodyColumnHeaders(this.dataModel, padding);\n                }\n            }\n        }\n    }\n    /**\n     * Map a client position to local viewport coordinates.\n     *\n     * @param clientX - The client X position of the mouse.\n     *\n     * @param clientY - The client Y position of the mouse.\n     *\n     * @returns The local viewport coordinates for the position.\n     */\n    mapToLocal(clientX, clientY) {\n        // Fetch the viewport rect.\n        let rect = this._viewport.node.getBoundingClientRect();\n        // Extract the rect coordinates.\n        let { left, top } = rect;\n        // Round the rect coordinates for sub-pixel positioning.\n        left = Math.floor(left);\n        top = Math.floor(top);\n        // Convert to local coordinates.\n        let lx = clientX - left;\n        let ly = clientY - top;\n        // Return the local coordinates.\n        return { lx, ly };\n    }\n    /**\n     * Map a client position to virtual grid coordinates.\n     *\n     * @param clientX - The client X position of the mouse.\n     *\n     * @param clientY - The client Y position of the mouse.\n     *\n     * @returns The virtual grid coordinates for the position.\n     */\n    mapToVirtual(clientX, clientY) {\n        // Convert to local coordiates.\n        let { lx, ly } = this.mapToLocal(clientX, clientY);\n        // Convert to virtual coordinates.\n        let vx = lx + this.scrollX - this.headerWidth;\n        let vy = ly + this.scrollY - this.headerHeight;\n        // Return the local coordinates.\n        return { vx, vy };\n    }\n    /**\n     * Hit test the viewport for the given client position.\n     *\n     * @param clientX - The client X position of the mouse.\n     *\n     * @param clientY - The client Y position of the mouse.\n     *\n     * @returns The hit test result, or `null` if the client\n     *   position is out of bounds.\n     *\n     * #### Notes\n     * This method accounts for a stretched last row and/or column.\n     */\n    hitTest(clientX, clientY) {\n        // Convert the mouse position into local coordinates.\n        let { lx, ly } = this.mapToLocal(clientX, clientY);\n        // Fetch the header and body dimensions.\n        let hw = this.headerWidth;\n        let hh = this.headerHeight;\n        let bw = this.bodyWidth;\n        let bh = this.bodyHeight;\n        let ph = this.pageHeight;\n        let pw = this.pageWidth;\n        // Adjust the body width for a stretched last column.\n        if (this._stretchLastColumn && pw > bw) {\n            bw = pw;\n        }\n        // Adjust the body height for a stretched last row.\n        if (this._stretchLastRow && ph > bh) {\n            bh = ph;\n        }\n        // Check for a corner header hit.\n        if (lx >= 0 && lx < hw && ly >= 0 && ly < hh) {\n            // Convert to unscrolled virtual coordinates.\n            let vx = lx;\n            let vy = ly;\n            // Fetch the row and column index.\n            let row = this.rowAt('column-header', vy);\n            let column = this.columnAt('row-header', vx);\n            // Fetch the cell offset position.\n            let ox = this.columnOffset('row-header', column);\n            let oy = this.rowOffset('column-header', row);\n            // Fetch cell width and height.\n            let width = this.columnSize('row-header', column);\n            let height = this.rowSize('column-header', row);\n            // Compute the leading and trailing positions.\n            let x = vx - ox;\n            let y = vy - oy;\n            // Return the hit test result.\n            return { region: 'corner-header', row, column, x, y, width, height };\n        }\n        // Check for a column header hit.\n        if (ly >= 0 && ly < hh && lx >= 0 && lx < hw + bw) {\n            // Convert to unscrolled virtual coordinates.\n            let vx = lx + this._scrollX - hw;\n            let vy = ly;\n            // Fetch the row and column index.\n            let row = this.rowAt('column-header', vy);\n            let column = this.columnAt('body', vx);\n            // Fetch the cell offset position.\n            let ox = this.columnOffset('body', column);\n            let oy = this.rowOffset('column-header', row);\n            // Fetch the cell width and height.\n            let width = this.columnSize('body', column);\n            let height = this.rowSize('column-header', row);\n            // Compute the leading and trailing positions.\n            let x = vx - ox;\n            let y = vy - oy;\n            // Return the hit test result.\n            return { region: 'column-header', row, column, x, y, width, height };\n        }\n        // Check for a row header hit.\n        if (lx >= 0 && lx < hw && ly >= 0 && ly < hh + bh) {\n            // Convert to unscrolled virtual coordinates.\n            let vx = lx;\n            let vy = ly + this._scrollY - hh;\n            // Fetch the row and column index.\n            let row = this.rowAt('body', vy);\n            let column = this.columnAt('row-header', vx);\n            // Fetch the cell offset position.\n            let ox = this.columnOffset('row-header', column);\n            let oy = this.rowOffset('body', row);\n            // Fetch the cell width and height.\n            let width = this.columnSize('row-header', column);\n            let height = this.rowSize('body', row);\n            // Compute the leading and trailing positions.\n            let x = vx - ox;\n            let y = vy - oy;\n            // Return the hit test result.\n            return { region: 'row-header', row, column, x, y, width, height };\n        }\n        // Check for a body hit.\n        if (lx >= hw && lx < hw + bw && ly >= hh && ly < hh + bh) {\n            // Convert to unscrolled virtual coordinates.\n            let vx = lx + this._scrollX - hw;\n            let vy = ly + this._scrollY - hh;\n            // Fetch the row and column index.\n            let row = this.rowAt('body', vy);\n            let column = this.columnAt('body', vx);\n            // Fetch the cell offset position.\n            let ox = this.columnOffset('body', column);\n            let oy = this.rowOffset('body', row);\n            // Fetch the cell width and height.\n            let width = this.columnSize('body', column);\n            let height = this.rowSize('body', row);\n            // Compute the part coordinates.\n            let x = vx - ox;\n            let y = vy - oy;\n            // Return the result.\n            return { region: 'body', row, column, x, y, width, height };\n        }\n        // Otherwise, it's a void space hit.\n        let row = -1;\n        let column = -1;\n        let x = -1;\n        let y = -1;\n        let width = -1;\n        let height = -1;\n        // Return the hit test result.\n        return { region: 'void', row, column, x, y, width, height };\n    }\n    /**\n     * Copy the current selection to the system clipboard.\n     *\n     * #### Notes\n     * The grid must have a data model and a selection model.\n     *\n     * The behavior can be configured via `DataGrid.copyConfig`.\n     */\n    copyToClipboard() {\n        // Fetch the data model.\n        let dataModel = this._dataModel;\n        // Bail early if there is no data model.\n        if (!dataModel) {\n            return;\n        }\n        // Fetch the selection model.\n        let selectionModel = this._selectionModel;\n        // Bail early if there is no selection model.\n        if (!selectionModel) {\n            return;\n        }\n        // Coerce the selections to an array.\n        let selections = Array.from(selectionModel.selections());\n        // Bail early if there are no selections.\n        if (selections.length === 0) {\n            return;\n        }\n        // Alert that multiple selections cannot be copied.\n        if (selections.length > 1) {\n            alert('Cannot copy multiple grid selections.');\n            return;\n        }\n        // Fetch the model counts.\n        let br = dataModel.rowCount('body');\n        let bc = dataModel.columnCount('body');\n        // Bail early if there is nothing to copy.\n        if (br === 0 || bc === 0) {\n            return;\n        }\n        // Unpack the selection.\n        let { r1, c1, r2, c2 } = selections[0];\n        // Clamp the selection to the model bounds.\n        r1 = Math.max(0, Math.min(r1, br - 1));\n        c1 = Math.max(0, Math.min(c1, bc - 1));\n        r2 = Math.max(0, Math.min(r2, br - 1));\n        c2 = Math.max(0, Math.min(c2, bc - 1));\n        // Ensure the limits are well-orderd.\n        if (r2 < r1)\n            [r1, r2] = [r2, r1];\n        if (c2 < c1)\n            [c1, c2] = [c2, c1];\n        // Fetch the header counts.\n        let rhc = dataModel.columnCount('row-header');\n        let chr = dataModel.rowCount('column-header');\n        // Unpack the copy config.\n        let separator = this._copyConfig.separator;\n        let format = this._copyConfig.format;\n        let headers = this._copyConfig.headers;\n        let warningThreshold = this._copyConfig.warningThreshold;\n        // Compute the number of cells to be copied.\n        let rowCount = r2 - r1 + 1;\n        let colCount = c2 - c1 + 1;\n        switch (headers) {\n            case 'none':\n                rhc = 0;\n                chr = 0;\n                break;\n            case 'row':\n                chr = 0;\n                colCount += rhc;\n                break;\n            case 'column':\n                rhc = 0;\n                rowCount += chr;\n                break;\n            case 'all':\n                rowCount += chr;\n                colCount += rhc;\n                break;\n            default:\n                throw 'unreachable';\n        }\n        // Compute the total cell count.\n        let cellCount = rowCount * colCount;\n        // Allow the user to cancel a large copy request.\n        if (cellCount > warningThreshold) {\n            let msg = `Copying ${cellCount} cells may take a while. Continue?`;\n            if (!window.confirm(msg)) {\n                return;\n            }\n        }\n        // Set up the format args.\n        let args = {\n            region: 'body',\n            row: 0,\n            column: 0,\n            value: null,\n            metadata: {}\n        };\n        // Allocate the array of rows.\n        let rows = new Array(rowCount);\n        // Iterate over the rows.\n        for (let j = 0; j < rowCount; ++j) {\n            // Allocate the array of cells.\n            let cells = new Array(colCount);\n            // Iterate over the columns.\n            for (let i = 0; i < colCount; ++i) {\n                // Set up the format variables.\n                let region;\n                let row;\n                let column;\n                // Populate the format variables.\n                if (j < chr && i < rhc) {\n                    region = 'corner-header';\n                    row = j;\n                    column = i;\n                }\n                else if (j < chr) {\n                    region = 'column-header';\n                    row = j;\n                    column = i - rhc + c1;\n                }\n                else if (i < rhc) {\n                    region = 'row-header';\n                    row = j - chr + r1;\n                    column = i;\n                }\n                else {\n                    region = 'body';\n                    row = j - chr + r1;\n                    column = i - rhc + c1;\n                }\n                // Populate the format args.\n                args.region = region;\n                args.row = row;\n                args.column = column;\n                args.value = dataModel.data(region, row, column);\n                args.metadata = dataModel.metadata(region, row, column);\n                // Format the cell.\n                cells[i] = format(args);\n            }\n            // Save the row of cells.\n            rows[j] = cells;\n        }\n        // Convert the cells into lines.\n        let lines = rows.map(cells => cells.join(separator));\n        // Convert the lines into text.\n        let text = lines.join('\\n');\n        // Copy the text to the clipboard.\n        ClipboardExt.copyText(text);\n    }\n    /**\n     * Process a message sent to the widget.\n     *\n     * @param msg - The message sent to the widget.\n     */\n    processMessage(msg) {\n        // Ignore child show/hide messages. The data grid controls the\n        // visibility of its children, and will manually dispatch the\n        // fit-request messages as a result of visibility change.\n        if (msg.type === 'child-shown' || msg.type === 'child-hidden') {\n            return;\n        }\n        // Recompute the scroll bar minimums before the layout refits.\n        if (msg.type === 'fit-request') {\n            let vsbLimits = ElementExt.sizeLimits(this._vScrollBar.node);\n            let hsbLimits = ElementExt.sizeLimits(this._hScrollBar.node);\n            this._vScrollBarMinWidth = vsbLimits.minWidth;\n            this._hScrollBarMinHeight = hsbLimits.minHeight;\n        }\n        // Process all other messages as normal.\n        super.processMessage(msg);\n    }\n    /**\n     * Intercept a message sent to a message handler.\n     *\n     * @param handler - The target handler of the message.\n     *\n     * @param msg - The message to be sent to the handler.\n     *\n     * @returns `true` if the message should continue to be processed\n     *   as normal, or `false` if processing should cease immediately.\n     */\n    messageHook(handler, msg) {\n        // Process viewport messages.\n        if (handler === this._viewport) {\n            this._processViewportMessage(msg);\n            return true;\n        }\n        // Process horizontal scroll bar messages.\n        if (handler === this._hScrollBar && msg.type === 'activate-request') {\n            this.activate();\n            return false;\n        }\n        // Process vertical scroll bar messages.\n        if (handler === this._vScrollBar && msg.type === 'activate-request') {\n            this.activate();\n            return false;\n        }\n        // Ignore all other messages.\n        return true;\n    }\n    /**\n     * Handle the DOM events for the data grid.\n     *\n     * @param event - The DOM event sent to the data grid.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the data grid's DOM node. It\n     * should not be called directly by user code.\n     */\n    handleEvent(event) {\n        switch (event.type) {\n            case 'keydown':\n                this._evtKeyDown(event);\n                break;\n            case 'mousedown':\n                this._evtMouseDown(event);\n                break;\n            case 'mousemove':\n                this._evtMouseMove(event);\n                break;\n            case 'mouseup':\n                this._evtMouseUp(event);\n                break;\n            case 'dblclick':\n                this._evtMouseDoubleClick(event);\n                break;\n            case 'mouseleave':\n                this._evtMouseLeave(event);\n                break;\n            case 'contextmenu':\n                this._evtContextMenu(event);\n                break;\n            case 'wheel':\n                this._evtWheel(event);\n                break;\n            case 'resize':\n                this._refreshDPI();\n                break;\n        }\n    }\n    /**\n     * Get the current viewport.\n     *\n     * @returns The current viewport as row/column coordinates.\n     * Returns undefined if the grid is not visible.\n     */\n    get currentViewport() {\n        let width = this.viewport.node.offsetWidth;\n        let height = this.viewport.node.offsetHeight;\n        width = Math.round(width);\n        height = Math.round(height);\n        if (width <= 0 || height <= 0) {\n            return;\n        }\n        const contentW = this._columnSections.length - this.scrollX;\n        const contentH = this._rowSections.length - this.scrollY;\n        const contentX = this.headerWidth;\n        const contentY = this.headerHeight;\n        const x1 = contentX;\n        const y1 = contentY;\n        const x2 = Math.min(width - 1, contentX + contentW - 1);\n        const y2 = Math.min(height - 1, contentY + contentH - 1);\n        const firstRow = this._rowSections.indexOf(y1 - contentY + this.scrollY);\n        const firstColumn = this._columnSections.indexOf(x1 - contentX + this.scrollX);\n        const lastRow = this._rowSections.indexOf(y2 - contentY + this.scrollY);\n        const lastColumn = this._columnSections.indexOf(x2 - contentX + this.scrollX);\n        return {\n            firstRow,\n            firstColumn,\n            lastRow,\n            lastColumn\n        };\n    }\n    /**\n     * A message handler invoked on an `'activate-request'` message.\n     */\n    onActivateRequest(msg) {\n        this.viewport.node.focus({ preventScroll: true });\n    }\n    /**\n     * A message handler invoked on a `'before-attach'` message.\n     */\n    onBeforeAttach(msg) {\n        window.addEventListener('resize', this);\n        this.node.addEventListener('wheel', this);\n        this._viewport.node.addEventListener('keydown', this);\n        this._viewport.node.addEventListener('mousedown', this);\n        this._viewport.node.addEventListener('mousemove', this);\n        this._viewport.node.addEventListener('dblclick', this);\n        this._viewport.node.addEventListener('mouseleave', this);\n        this._viewport.node.addEventListener('contextmenu', this);\n        this.repaintContent();\n        this.repaintOverlay();\n    }\n    /**\n     * A message handler invoked on an `'after-detach'` message.\n     */\n    onAfterDetach(msg) {\n        window.removeEventListener('resize', this);\n        this.node.removeEventListener('wheel', this);\n        this._viewport.node.removeEventListener('keydown', this);\n        this._viewport.node.removeEventListener('mousedown', this);\n        this._viewport.node.removeEventListener('mousemove', this);\n        this._viewport.node.removeEventListener('mouseleave', this);\n        this._viewport.node.removeEventListener('dblclick', this);\n        this._viewport.node.removeEventListener('contextmenu', this);\n        this._releaseMouse();\n    }\n    /**\n     * A message handler invoked on a `'before-show'` message.\n     */\n    onBeforeShow(msg) {\n        this.repaintContent();\n        this.repaintOverlay();\n    }\n    /**\n     * A message handler invoked on a `'resize'` message.\n     */\n    onResize(msg) {\n        if (this._editorController) {\n            this._editorController.cancel();\n        }\n        this._syncScrollState();\n    }\n    /**\n     * Schedule a repaint of all of the grid content.\n     */\n    repaintContent() {\n        let msg = new Private$1.PaintRequest('all', 0, 0, 0, 0);\n        MessageLoop.postMessage(this._viewport, msg);\n    }\n    /**\n     * Schedule a repaint of specific grid content.\n     */\n    repaintRegion(region, r1, c1, r2, c2) {\n        let msg = new Private$1.PaintRequest(region, r1, c1, r2, c2);\n        MessageLoop.postMessage(this._viewport, msg);\n    }\n    /**\n     * Schedule a repaint of the overlay.\n     */\n    repaintOverlay() {\n        MessageLoop.postMessage(this._viewport, Private$1.OverlayPaintRequest);\n    }\n    _getMaxWidthInColumn(index, columnRegion) {\n        const dataModel = this.dataModel;\n        if (!dataModel) {\n            return null;\n        }\n        const columnHeaderRegion = columnRegion == 'row-header' ? 'corner-header' : 'column-header';\n        return Math.max(this._getMaxWidthInArea(dataModel, index, columnHeaderRegion, 'column-header'), this._getMaxWidthInArea(dataModel, index, columnRegion, 'body'));\n    }\n    _getMaxWidthInArea(dataModel, index, region, rowRegion) {\n        const numRows = dataModel.rowCount(rowRegion);\n        // Will only allocate up to 1_000_000 elements otherwise performance can tank.\n        const configs = Array.from({ length: Math.min(numRows, 1000000) }, (_val, idx) => DataGrid._getConfig(dataModel, idx, index, region));\n        // Heuristic: Sort by the length of the text to render and only fully calculate the text width\n        // for the top 100_000 rows by text length\n        if (numRows > 100000) {\n            // Sort by descending length\n            configs.sort(x => -this._getTextToRender(x).length);\n        }\n        let maxWidth = 0;\n        for (let i = 0; i < numRows && i < 100000; ++i) {\n            const textWidth = this._getCellTextWidth(configs[i]);\n            maxWidth = Math.max(maxWidth, textWidth);\n        }\n        return maxWidth;\n    }\n    static _getConfig(dataModel, row, col, location) {\n        return {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0,\n            region: location,\n            row: row,\n            column: col,\n            value: DataGrid._getCellValue(dataModel, location, row, col),\n            metadata: DataGrid._getCellMetadata(dataModel, location, row, col)\n        };\n    }\n    _getTextToRender(config) {\n        const renderer = this.cellRenderers.get(config);\n        return renderer.getText(config);\n    }\n    _getCellTextWidth(config) {\n        // Get the renderer for the given cell.\n        const renderer = this.cellRenderers.get(config);\n        // Use the canvas context to measure the cell's text width\n        const gc = this.canvasGC;\n        gc.font = CellRenderer.resolveOption(renderer.font, config);\n        gc.fillStyle = CellRenderer.resolveOption(renderer.textColor, config);\n        gc.textAlign = CellRenderer.resolveOption(renderer.horizontalAlignment, config);\n        gc.textBaseline = 'bottom';\n        const text = this._getTextToRender(config);\n        return gc.measureText(text).width + 2 * renderer.horizontalPadding;\n    }\n    /**\n     * Ensure the canvas is at least the specified size.\n     *\n     * This method will retain the valid canvas content.\n     */\n    _resizeCanvasIfNeeded(width, height) {\n        // Scale the size by the dpi ratio.\n        width = width * this._dpiRatio;\n        height = height * this._dpiRatio;\n        // Compute the maximum canvas size for the given width and height.\n        let maxW = (Math.ceil((width + 1) / 512) + 1) * 512;\n        let maxH = (Math.ceil((height + 1) / 512) + 1) * 512;\n        // Get the current size of the canvas.\n        let curW = this._canvas.width;\n        let curH = this._canvas.height;\n        // Bail early if the canvas size is within bounds.\n        if (curW >= width && curH >= height && curW <= maxW && curH <= maxH) {\n            return;\n        }\n        // Compute the expanded canvas size.\n        let expW = maxW - 512;\n        let expH = maxH - 512;\n        // Set the transforms to the identity matrix.\n        this._canvasGC.setTransform(1, 0, 0, 1, 0, 0);\n        this._bufferGC.setTransform(1, 0, 0, 1, 0, 0);\n        this._overlayGC.setTransform(1, 0, 0, 1, 0, 0);\n        // Resize the buffer if needed.\n        if (curW < width) {\n            this._buffer.width = expW;\n        }\n        else if (curW > maxW) {\n            this._buffer.width = maxW;\n        }\n        // Resize the buffer height if needed.\n        if (curH < height) {\n            this._buffer.height = expH;\n        }\n        else if (curH > maxH) {\n            this._buffer.height = maxH;\n        }\n        // Test whether there is content to blit.\n        let needBlit = curW > 0 && curH > 0 && width > 0 && height > 0;\n        // Copy the valid canvas content into the buffer if needed.\n        if (needBlit) {\n            this._bufferGC.drawImage(this._canvas, 0, 0);\n        }\n        // Resize the canvas width if needed.\n        if (curW < width) {\n            this._canvas.width = expW;\n            this._canvas.style.width = `${expW / this._dpiRatio}px`;\n        }\n        else if (curW > maxW) {\n            this._canvas.width = maxW;\n            this._canvas.style.width = `${maxW / this._dpiRatio}px`;\n        }\n        // Resize the canvas height if needed.\n        if (curH < height) {\n            this._canvas.height = expH;\n            this._canvas.style.height = `${expH / this._dpiRatio}px`;\n        }\n        else if (curH > maxH) {\n            this._canvas.height = maxH;\n            this._canvas.style.height = `${maxH / this._dpiRatio}px`;\n        }\n        // Copy the valid canvas content from the buffer if needed.\n        if (needBlit) {\n            this._canvasGC.drawImage(this._buffer, 0, 0);\n        }\n        // Copy the valid overlay content into the buffer if needed.\n        if (needBlit) {\n            this._bufferGC.drawImage(this._overlay, 0, 0);\n        }\n        // Resize the overlay width if needed.\n        if (curW < width) {\n            this._overlay.width = expW;\n            this._overlay.style.width = `${expW / this._dpiRatio}px`;\n        }\n        else if (curW > maxW) {\n            this._overlay.width = maxW;\n            this._overlay.style.width = `${maxW / this._dpiRatio}px`;\n        }\n        // Resize the overlay height if needed.\n        if (curH < height) {\n            this._overlay.height = expH;\n            this._overlay.style.height = `${expH / this._dpiRatio}px`;\n        }\n        else if (curH > maxH) {\n            this._overlay.height = maxH;\n            this._overlay.style.height = `${maxH / this._dpiRatio}px`;\n        }\n        // Copy the valid overlay content from the buffer if needed.\n        if (needBlit) {\n            this._overlayGC.drawImage(this._buffer, 0, 0);\n        }\n    }\n    /**\n     * Sync the scroll bars and scroll state with the viewport.\n     *\n     * #### Notes\n     * If the visibility of either scroll bar changes, a synchronous\n     * fit-request will be dispatched to the data grid to immediately\n     * resize the viewport.\n     */\n    _syncScrollState() {\n        // Fetch the viewport dimensions.\n        let bw = this.bodyWidth;\n        let bh = this.bodyHeight;\n        let pw = this.pageWidth;\n        let ph = this.pageHeight;\n        // Get the current scroll bar visibility.\n        let hasVScroll = !this._vScrollBar.isHidden;\n        let hasHScroll = !this._hScrollBar.isHidden;\n        // Get the minimum sizes of the scroll bars.\n        let vsw = this._vScrollBarMinWidth;\n        let hsh = this._hScrollBarMinHeight;\n        // Get the page size as if no scroll bars are visible.\n        let apw = pw + (hasVScroll ? vsw : 0);\n        let aph = ph + (hasHScroll ? hsh : 0);\n        // Test whether scroll bars are needed for the adjusted size.\n        let needVScroll = aph < bh - 1;\n        let needHScroll = apw < bw - 1;\n        // Re-test the horizontal scroll if a vertical scroll is needed.\n        if (needVScroll && !needHScroll) {\n            needHScroll = apw - vsw < bw - 1;\n        }\n        // Re-test the vertical scroll if a horizontal scroll is needed.\n        if (needHScroll && !needVScroll) {\n            needVScroll = aph - hsh < bh - 1;\n        }\n        // If the visibility changes, immediately refit the grid.\n        if (needVScroll !== hasVScroll || needHScroll !== hasHScroll) {\n            this._vScrollBar.setHidden(!needVScroll);\n            this._hScrollBar.setHidden(!needHScroll);\n            this._scrollCorner.setHidden(!needVScroll || !needHScroll);\n            MessageLoop.sendMessage(this, Widget.Msg.FitRequest);\n        }\n        // Update the scroll bar limits.\n        this._vScrollBar.maximum = this.maxScrollY;\n        this._vScrollBar.page = this.pageHeight;\n        this._hScrollBar.maximum = this.maxScrollX;\n        this._hScrollBar.page = this.pageWidth;\n        // Re-clamp the scroll position.\n        this._scrollTo(this._scrollX, this._scrollY);\n    }\n    /**\n     * Sync the viewport to the given scroll position.\n     *\n     * #### Notes\n     * This schedules a full repaint and syncs the scroll state.\n     */\n    _syncViewport() {\n        this.repaintContent();\n        this.repaintOverlay();\n        this._syncScrollState();\n    }\n    /**\n     * Process a message sent to the viewport\n     */\n    _processViewportMessage(msg) {\n        switch (msg.type) {\n            case 'resize':\n                this._onViewportResize(msg);\n                break;\n            case 'scroll-request':\n                this._onViewportScrollRequest(msg);\n                break;\n            case 'paint-request':\n                this._onViewportPaintRequest(msg);\n                break;\n            case 'overlay-paint-request':\n                this._onViewportOverlayPaintRequest(msg);\n                break;\n            case 'row-resize-request':\n                this._onViewportRowResizeRequest(msg);\n                break;\n            case 'column-resize-request':\n                this._onViewportColumnResizeRequest(msg);\n                break;\n        }\n    }\n    /**\n     * A message hook invoked on a viewport `'resize'` message.\n     */\n    _onViewportResize(msg) {\n        // Bail early if the viewport is not visible.\n        if (!this._viewport.isVisible) {\n            return;\n        }\n        // Unpack the message data.\n        let { width, height } = msg;\n        // Measure the viewport node if the dimensions are unknown.\n        if (width === -1) {\n            width = this._viewport.node.offsetWidth;\n        }\n        if (height === -1) {\n            height = this._viewport.node.offsetHeight;\n        }\n        // Round the dimensions to the nearest pixel.\n        width = Math.round(width);\n        height = Math.round(height);\n        // Get the current size of the viewport.\n        let oldWidth = this._viewportWidth;\n        let oldHeight = this._viewportHeight;\n        // Updated internal viewport size.\n        this._viewportWidth = width;\n        this._viewportHeight = height;\n        // Resize the canvas if needed.\n        this._resizeCanvasIfNeeded(width, height);\n        // Bail early if there is nothing to paint.\n        if (width === 0 || height === 0) {\n            return;\n        }\n        // Paint the whole grid if the old size was zero.\n        if (oldWidth === 0 || oldHeight === 0) {\n            this.paintContent(0, 0, width, height);\n            this._paintOverlay();\n            return;\n        }\n        // Paint the right edge as needed.\n        if (this._stretchLastColumn && this.pageWidth > this.bodyWidth) {\n            let bx = this._columnSections.offsetOf(this._columnSections.count - 1);\n            let x = Math.min(this.headerWidth + bx, oldWidth);\n            this.paintContent(x, 0, width - x, height);\n        }\n        else if (width > oldWidth) {\n            this.paintContent(oldWidth, 0, width - oldWidth + 1, height);\n        }\n        // Paint the bottom edge as needed.\n        if (this._stretchLastRow && this.pageHeight > this.bodyHeight) {\n            let by = this._rowSections.offsetOf(this._rowSections.count - 1);\n            let y = Math.min(this.headerHeight + by, oldHeight);\n            this.paintContent(0, y, width, height - y);\n        }\n        else if (height > oldHeight) {\n            this.paintContent(0, oldHeight, width, height - oldHeight + 1);\n        }\n        // Paint the overlay.\n        this._paintOverlay();\n    }\n    /**\n     * A message hook invoked on a viewport `'scroll-request'` message.\n     */\n    _onViewportScrollRequest(msg) {\n        this._scrollTo(this._hScrollBar.value, this._vScrollBar.value);\n    }\n    /**\n     * A message hook invoked on a viewport `'paint-request'` message.\n     */\n    _onViewportPaintRequest(msg) {\n        // Bail early if the viewport is not visible.\n        if (!this._viewport.isVisible) {\n            return;\n        }\n        // Bail early if the viewport has zero area.\n        if (this._viewportWidth === 0 || this._viewportHeight === 0) {\n            return;\n        }\n        // Set up the paint limits.\n        let xMin = 0;\n        let yMin = 0;\n        let xMax = this._viewportWidth - 1;\n        let yMax = this._viewportHeight - 1;\n        // Fetch the scroll position.\n        let sx = this._scrollX;\n        let sy = this._scrollY;\n        // Fetch the header dimensions.\n        let hw = this.headerWidth;\n        let hh = this.headerHeight;\n        // Fetch the section lists.\n        let rs = this._rowSections;\n        let cs = this._columnSections;\n        let rhs = this._rowHeaderSections;\n        let chs = this._columnHeaderSections;\n        // Unpack the message data.\n        let { region, r1, c1, r2, c2 } = msg;\n        // Set up the paint variables.\n        let x1;\n        let y1;\n        let x2;\n        let y2;\n        // Fill the paint variables based on the paint region.\n        switch (region) {\n            case 'all':\n                x1 = xMin;\n                y1 = yMin;\n                x2 = xMax;\n                y2 = yMax;\n                break;\n            case 'body':\n                r1 = Math.max(0, Math.min(r1, rs.count));\n                c1 = Math.max(0, Math.min(c1, cs.count));\n                r2 = Math.max(0, Math.min(r2, rs.count));\n                c2 = Math.max(0, Math.min(c2, cs.count));\n                x1 = cs.offsetOf(c1) - sx + hw;\n                y1 = rs.offsetOf(r1) - sy + hh;\n                x2 = cs.extentOf(c2) - sx + hw;\n                y2 = rs.extentOf(r2) - sy + hh;\n                break;\n            case 'row-header':\n                r1 = Math.max(0, Math.min(r1, rs.count));\n                c1 = Math.max(0, Math.min(c1, rhs.count));\n                r2 = Math.max(0, Math.min(r2, rs.count));\n                c2 = Math.max(0, Math.min(c2, rhs.count));\n                x1 = rhs.offsetOf(c1);\n                y1 = rs.offsetOf(r1) - sy + hh;\n                x2 = rhs.extentOf(c2);\n                y2 = rs.extentOf(r2) - sy + hh;\n                break;\n            case 'column-header':\n                r1 = Math.max(0, Math.min(r1, chs.count));\n                c1 = Math.max(0, Math.min(c1, cs.count));\n                r2 = Math.max(0, Math.min(r2, chs.count));\n                c2 = Math.max(0, Math.min(c2, cs.count));\n                x1 = cs.offsetOf(c1) - sx + hw;\n                y1 = chs.offsetOf(r1);\n                x2 = cs.extentOf(c2) - sx + hw;\n                y2 = chs.extentOf(r2);\n                break;\n            case 'corner-header':\n                r1 = Math.max(0, Math.min(r1, chs.count));\n                c1 = Math.max(0, Math.min(c1, rhs.count));\n                r2 = Math.max(0, Math.min(r2, chs.count));\n                c2 = Math.max(0, Math.min(c2, rhs.count));\n                x1 = rhs.offsetOf(c1);\n                y1 = chs.offsetOf(r1);\n                x2 = rhs.extentOf(c2);\n                y2 = chs.extentOf(r2);\n                break;\n            default:\n                throw 'unreachable';\n        }\n        // Bail early if the dirty rect is outside the bounds.\n        if (x2 < xMin || y2 < yMin || x1 > xMax || y1 > yMax) {\n            return;\n        }\n        // Clamp the dirty rect to the paint bounds.\n        x1 = Math.max(xMin, Math.min(x1, xMax));\n        y1 = Math.max(yMin, Math.min(y1, yMax));\n        x2 = Math.max(xMin, Math.min(x2, xMax));\n        y2 = Math.max(yMin, Math.min(y2, yMax));\n        // Paint the content of the dirty rect.\n        this.paintContent(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n    }\n    /**\n     * A message hook invoked on a viewport `'overlay-paint-request'` message.\n     */\n    _onViewportOverlayPaintRequest(msg) {\n        // Bail early if the viewport is not visible.\n        if (!this._viewport.isVisible) {\n            return;\n        }\n        // Bail early if the viewport has zero area.\n        if (this._viewportWidth === 0 || this._viewportHeight === 0) {\n            return;\n        }\n        // Paint the content of the overlay.\n        this._paintOverlay();\n    }\n    /**\n     * A message hook invoked on a viewport `'row-resize-request'` message.\n     */\n    _onViewportRowResizeRequest(msg) {\n        if (msg.region === 'body') {\n            this._resizeRow(msg.index, msg.size);\n        }\n        else {\n            this._resizeColumnHeader(msg.index, msg.size);\n        }\n    }\n    /**\n     * A message hook invoked on a viewport `'column-resize-request'` message.\n     */\n    _onViewportColumnResizeRequest(msg) {\n        if (msg.region === 'body') {\n            this._resizeColumn(msg.index, msg.size);\n        }\n        else {\n            this._resizeRowHeader(msg.index, msg.size);\n        }\n    }\n    /**\n     * Handle the `thumbMoved` signal from a scroll bar.\n     */\n    _onThumbMoved(sender) {\n        MessageLoop.postMessage(this._viewport, Private$1.ScrollRequest);\n    }\n    /**\n     * Handle the `pageRequested` signal from a scroll bar.\n     */\n    _onPageRequested(sender, dir) {\n        if (sender === this._vScrollBar) {\n            this.scrollByPage(dir === 'decrement' ? 'up' : 'down');\n        }\n        else {\n            this.scrollByPage(dir === 'decrement' ? 'left' : 'right');\n        }\n    }\n    /**\n     * Handle the `stepRequested` signal from a scroll bar.\n     */\n    _onStepRequested(sender, dir) {\n        if (sender === this._vScrollBar) {\n            this.scrollByStep(dir === 'decrement' ? 'up' : 'down');\n        }\n        else {\n            this.scrollByStep(dir === 'decrement' ? 'left' : 'right');\n        }\n    }\n    /**\n     * A signal handler for the data model `changed` signal.\n     */\n    _onDataModelChanged(sender, args) {\n        switch (args.type) {\n            case 'rows-inserted':\n                this._onRowsInserted(args);\n                break;\n            case 'columns-inserted':\n                this._onColumnsInserted(args);\n                break;\n            case 'rows-removed':\n                this._onRowsRemoved(args);\n                break;\n            case 'columns-removed':\n                this._onColumnsRemoved(args);\n                break;\n            case 'rows-moved':\n                this._onRowsMoved(args);\n                break;\n            case 'columns-moved':\n                this._onColumnsMoved(args);\n                break;\n            case 'cells-changed':\n                this._onCellsChanged(args);\n                break;\n            case 'model-reset':\n                this._onModelReset(args);\n                break;\n            default:\n                throw 'unreachable';\n        }\n    }\n    /**\n     * A signal handler for the selection model `changed` signal.\n     */\n    _onSelectionsChanged(sender) {\n        this.repaintOverlay();\n    }\n    /**\n     * Handle rows being inserted in the data model.\n     */\n    _onRowsInserted(args) {\n        // Unpack the arg data.\n        let { region, index, span } = args;\n        // Bail early if there are no sections to insert.\n        if (span <= 0) {\n            return;\n        }\n        // Look up the relevant section list.\n        let list;\n        if (region === 'body') {\n            list = this._rowSections;\n        }\n        else {\n            list = this._columnHeaderSections;\n        }\n        // Insert the span, maintaining the scroll position as needed.\n        if (this._scrollY === this.maxScrollY && this.maxScrollY > 0) {\n            list.insert(index, span);\n            this._scrollY = this.maxScrollY;\n        }\n        else {\n            list.insert(index, span);\n        }\n        // Sync the viewport.\n        this._syncViewport();\n    }\n    /**\n     * Handle columns being inserted into the data model.\n     */\n    _onColumnsInserted(args) {\n        // Unpack the arg data.\n        let { region, index, span } = args;\n        // Bail early if there are no sections to insert.\n        if (span <= 0) {\n            return;\n        }\n        // Look up the relevant section list.\n        let list;\n        if (region === 'body') {\n            list = this._columnSections;\n        }\n        else {\n            list = this._rowHeaderSections;\n        }\n        // Insert the span, maintaining the scroll position as needed.\n        if (this._scrollX === this.maxScrollX && this.maxScrollX > 0) {\n            list.insert(index, span);\n            this._scrollX = this.maxScrollX;\n        }\n        else {\n            list.insert(index, span);\n        }\n        // Sync the viewport.\n        this._syncViewport();\n    }\n    /**\n     * Handle rows being removed from the data model.\n     */\n    _onRowsRemoved(args) {\n        // Unpack the arg data.\n        let { region, index, span } = args;\n        // Bail early if there are no sections to remove.\n        if (span <= 0) {\n            return;\n        }\n        // Look up the relevant section list.\n        let list;\n        if (region === 'body') {\n            list = this._rowSections;\n        }\n        else {\n            list = this._columnHeaderSections;\n        }\n        // Bail if the index or is invalid\n        if (index < 0 || index >= list.count) {\n            return;\n        }\n        // Remove the span, maintaining the scroll position as needed.\n        if (this._scrollY === this.maxScrollY && this.maxScrollY > 0) {\n            list.remove(index, span);\n            this._scrollY = this.maxScrollY;\n        }\n        else {\n            list.remove(index, span);\n        }\n        // Sync the viewport.\n        this._syncViewport();\n    }\n    /**\n     * Handle columns being removed from the data model.\n     */\n    _onColumnsRemoved(args) {\n        // Unpack the arg data.\n        let { region, index, span } = args;\n        // Bail early if there are no sections to remove.\n        if (span <= 0) {\n            return;\n        }\n        // Look up the relevant section list.\n        let list;\n        if (region === 'body') {\n            list = this._columnSections;\n        }\n        else {\n            list = this._rowHeaderSections;\n        }\n        // Bail if the index or is invalid\n        if (index < 0 || index >= list.count) {\n            return;\n        }\n        // Remove the span, maintaining the scroll position as needed.\n        if (this._scrollX === this.maxScrollX && this.maxScrollX > 0) {\n            list.remove(index, span);\n            this._scrollX = this.maxScrollX;\n        }\n        else {\n            list.remove(index, span);\n        }\n        // Sync the viewport.\n        this._syncViewport();\n    }\n    /**\n     * Handle rows moving in the data model.\n     */\n    _onRowsMoved(args) {\n        // Unpack the arg data.\n        let { region, index, span, destination } = args;\n        // Bail early if there are no sections to move.\n        if (span <= 0) {\n            return;\n        }\n        // Look up the relevant section list.\n        let list;\n        if (region === 'body') {\n            list = this._rowSections;\n        }\n        else {\n            list = this._columnHeaderSections;\n        }\n        // Bail early if the index is out of range.\n        if (index < 0 || index >= list.count) {\n            return;\n        }\n        // Clamp the move span to the limit.\n        span = Math.min(span, list.count - index);\n        // Clamp the destination index to the limit.\n        destination = Math.min(Math.max(0, destination), list.count - span);\n        // Bail early if there is no effective move.\n        if (index === destination) {\n            return;\n        }\n        // Compute the first affected index.\n        let r1 = Math.min(index, destination);\n        // Compute the last affected index.\n        let r2 = Math.max(index + span - 1, destination + span - 1);\n        // Move the sections in the list.\n        list.move(index, span, destination);\n        // Schedule a repaint of the dirty cells.\n        if (region === 'body') {\n            this.repaintRegion('body', r1, 0, r2, Infinity);\n            this.repaintRegion('row-header', r1, 0, r2, Infinity);\n        }\n        else {\n            this.repaintRegion('column-header', r1, 0, r2, Infinity);\n            this.repaintRegion('corner-header', r1, 0, r2, Infinity);\n        }\n        // Sync the viewport.\n        this._syncViewport();\n    }\n    /**\n     * Handle columns moving in the data model.\n     */\n    _onColumnsMoved(args) {\n        // Unpack the arg data.\n        let { region, index, span, destination } = args;\n        // Bail early if there are no sections to move.\n        if (span <= 0) {\n            return;\n        }\n        // Look up the relevant section list.\n        let list;\n        if (region === 'body') {\n            list = this._columnSections;\n        }\n        else {\n            list = this._rowHeaderSections;\n        }\n        // Bail early if the index is out of range.\n        if (index < 0 || index >= list.count) {\n            return;\n        }\n        // Clamp the move span to the limit.\n        span = Math.min(span, list.count - index);\n        // Clamp the destination index to the limit.\n        destination = Math.min(Math.max(0, destination), list.count - span);\n        // Bail early if there is no effective move.\n        if (index === destination) {\n            return;\n        }\n        // Move the sections in the list.\n        list.move(index, span, destination);\n        // Compute the first affected index.\n        let c1 = Math.min(index, destination);\n        // Compute the last affected index.\n        let c2 = Math.max(index + span - 1, destination + span - 1);\n        // Schedule a repaint of the dirty cells.\n        if (region === 'body') {\n            this.repaintRegion('body', 0, c1, Infinity, c2);\n            this.repaintRegion('column-header', 0, c1, Infinity, c2);\n        }\n        else {\n            this.repaintRegion('row-header', 0, c1, Infinity, c2);\n            this.repaintRegion('corner-header', 0, c1, Infinity, c2);\n        }\n        // Sync the viewport.\n        this._syncViewport();\n    }\n    /**\n     * Handle cells changing in the data model.\n     */\n    _onCellsChanged(args) {\n        // Unpack the arg data.\n        let { region, row, column, rowSpan, columnSpan } = args;\n        // Bail early if there are no cells to modify.\n        if (rowSpan <= 0 && columnSpan <= 0) {\n            return;\n        }\n        // Compute the changed cell bounds.\n        let r1 = row;\n        let c1 = column;\n        let r2 = r1 + rowSpan - 1;\n        let c2 = c1 + columnSpan - 1;\n        // Schedule a repaint of the cell content.\n        this.repaintRegion(region, r1, c1, r2, c2);\n    }\n    /**\n     * Handle a full data model reset.\n     */\n    _onModelReset(args) {\n        // Look up the various current section counts.\n        let nr = this._rowSections.count;\n        let nc = this._columnSections.count;\n        let nrh = this._rowHeaderSections.count;\n        let nch = this._columnHeaderSections.count;\n        // Compute the delta count for each region.\n        let dr = this._dataModel.rowCount('body') - nr;\n        let dc = this._dataModel.columnCount('body') - nc;\n        let drh = this._dataModel.columnCount('row-header') - nrh;\n        let dch = this._dataModel.rowCount('column-header') - nch;\n        // Update the row sections, if needed.\n        if (dr > 0) {\n            this._rowSections.insert(nr, dr);\n        }\n        else if (dr < 0) {\n            this._rowSections.remove(nr + dr, -dr);\n        }\n        // Update the column sections, if needed.\n        if (dc > 0) {\n            this._columnSections.insert(nc, dc);\n        }\n        else if (dc < 0) {\n            this._columnSections.remove(nc + dc, -dc);\n        }\n        // Update the row header sections, if needed.\n        if (drh > 0) {\n            this._rowHeaderSections.insert(nrh, drh);\n        }\n        else if (drh < 0) {\n            this._rowHeaderSections.remove(nrh + drh, -drh);\n        }\n        // Update the column header sections, if needed.\n        if (dch > 0) {\n            this._columnHeaderSections.insert(nch, dch);\n        }\n        else if (dch < 0) {\n            this._columnHeaderSections.remove(nch + dch, -dch);\n        }\n        // Sync the viewport.\n        this._syncViewport();\n    }\n    /**\n     * A signal handler for the renderer map `changed` signal.\n     */\n    _onRenderersChanged() {\n        this.repaintContent();\n    }\n    /**\n     * Handle the `'keydown'` event for the data grid.\n     */\n    _evtKeyDown(event) {\n        if (this._mousedown) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n        else if (this._keyHandler) {\n            this._keyHandler.onKeyDown(this, event);\n        }\n    }\n    /**\n     * Handle the `'mousedown'` event for the data grid.\n     */\n    _evtMouseDown(event) {\n        // Ignore everything except the left mouse button.\n        if (event.button !== 0) {\n            return;\n        }\n        // Activate the grid.\n        this.activate();\n        // Stop the event propagation.\n        event.preventDefault();\n        event.stopPropagation();\n        // Add the extra document listeners.\n        document.addEventListener('keydown', this, true);\n        document.addEventListener('mouseup', this, true);\n        document.addEventListener('mousedown', this, true);\n        document.addEventListener('mousemove', this, true);\n        document.addEventListener('contextmenu', this, true);\n        // Flip the mousedown flag.\n        this._mousedown = true;\n        // Dispatch to the mouse handler.\n        if (this._mouseHandler) {\n            this._mouseHandler.onMouseDown(this, event);\n        }\n    }\n    /**\n     * Handle the `'mousemove'` event for the data grid.\n     */\n    _evtMouseMove(event) {\n        // Stop the event propagation if the mouse is down.\n        if (this._mousedown) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n        // Bail if there is no mouse handler.\n        if (!this._mouseHandler) {\n            return;\n        }\n        // Dispatch to the mouse handler.\n        if (this._mousedown) {\n            this._mouseHandler.onMouseMove(this, event);\n        }\n        else {\n            this._mouseHandler.onMouseHover(this, event);\n        }\n    }\n    /**\n     * Handle the `'mouseup'` event for the data grid.\n     */\n    _evtMouseUp(event) {\n        // Ignore everything except the left mouse button.\n        if (event.button !== 0) {\n            return;\n        }\n        // Stop the event propagation.\n        event.preventDefault();\n        event.stopPropagation();\n        // Dispatch to the mouse handler.\n        if (this._mouseHandler) {\n            this._mouseHandler.onMouseUp(this, event);\n        }\n        // Release the mouse.\n        this._releaseMouse();\n    }\n    /**\n     * Handle the `'dblclick'` event for the data grid.\n     */\n    _evtMouseDoubleClick(event) {\n        // Ignore everything except the left mouse button.\n        if (event.button !== 0) {\n            return;\n        }\n        // Stop the event propagation.\n        event.preventDefault();\n        event.stopPropagation();\n        // Dispatch to the mouse handler.\n        if (this._mouseHandler) {\n            this._mouseHandler.onMouseDoubleClick(this, event);\n        }\n        // Release the mouse.\n        this._releaseMouse();\n    }\n    /**\n     * Handle the `'mouseleave'` event for the data grid.\n     */\n    _evtMouseLeave(event) {\n        if (this._mousedown) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n        else if (this._mouseHandler) {\n            this._mouseHandler.onMouseLeave(this, event);\n        }\n    }\n    /**\n     * Handle the `'contextmenu'` event for the data grid.\n     */\n    _evtContextMenu(event) {\n        if (this._mousedown) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n        else if (this._mouseHandler) {\n            this._mouseHandler.onContextMenu(this, event);\n        }\n    }\n    /**\n     * Handle the `'wheel'` event for the data grid.\n     */\n    _evtWheel(event) {\n        // Ignore the event if `accel` is held.\n        if (Platform.accelKey(event)) {\n            return;\n        }\n        // Bail early if there is no mouse handler.\n        if (!this._mouseHandler) {\n            return;\n        }\n        // Dispatch to the mouse handler.\n        this._mouseHandler.onWheel(this, event);\n    }\n    /**\n     * Release the mouse grab.\n     */\n    _releaseMouse() {\n        // Clear the mousedown flag.\n        this._mousedown = false;\n        // Relase the mouse handler.\n        if (this._mouseHandler) {\n            this._mouseHandler.release();\n        }\n        // Remove the document listeners.\n        document.removeEventListener('keydown', this, true);\n        document.removeEventListener('mouseup', this, true);\n        document.removeEventListener('mousedown', this, true);\n        document.removeEventListener('mousemove', this, true);\n        document.removeEventListener('contextmenu', this, true);\n    }\n    /**\n     * Refresh the dpi ratio.\n     */\n    _refreshDPI() {\n        // Get the best integral value for the dpi ratio.\n        let dpiRatio = Math.ceil(window.devicePixelRatio);\n        // Bail early if the computed dpi ratio has not changed.\n        if (this._dpiRatio === dpiRatio) {\n            return;\n        }\n        // Update the internal dpi ratio.\n        this._dpiRatio = dpiRatio;\n        // Schedule a repaint of the content.\n        this.repaintContent();\n        // Schedule a repaint of the overlay.\n        this.repaintOverlay();\n        // Update the canvas size for the new dpi ratio.\n        this._resizeCanvasIfNeeded(this._viewportWidth, this._viewportHeight);\n        // Ensure the canvas style is scaled for the new ratio.\n        this._canvas.style.width = `${this._canvas.width / this._dpiRatio}px`;\n        this._canvas.style.height = `${this._canvas.height / this._dpiRatio}px`;\n        // Ensure the overlay style is scaled for the new ratio.\n        this._overlay.style.width = `${this._overlay.width / this._dpiRatio}px`;\n        this._overlay.style.height = `${this._overlay.height / this._dpiRatio}px`;\n    }\n    /**\n     * Resize a row section immediately.\n     */\n    _resizeRow(index, size) {\n        // Look up the target section list.\n        let list = this._rowSections;\n        // Bail early if the index is out of range.\n        if (index < 0 || index >= list.count) {\n            return;\n        }\n        // Look up the old size of the section.\n        let oldSize = list.sizeOf(index);\n        // Normalize the new size of the section.\n        let newSize = list.clampSize(size);\n        // Bail early if the size does not change.\n        if (oldSize === newSize) {\n            return;\n        }\n        // Resize the section in the list.\n        list.resize(index, newSize);\n        // Get the current size of the viewport.\n        let vw = this._viewportWidth;\n        let vh = this._viewportHeight;\n        // If there is nothing to paint, sync the scroll state.\n        if (!this._viewport.isVisible || vw === 0 || vh === 0) {\n            this._syncScrollState();\n            return;\n        }\n        // Compute the size delta.\n        let delta = newSize - oldSize;\n        // Look up the column header height.\n        let hh = this.headerHeight;\n        // Compute the viewport offset of the section.\n        let offset = list.offsetOf(index) + hh - this._scrollY;\n        // Bail early if there is nothing to paint.\n        if (hh >= vh || offset >= vh) {\n            this._syncScrollState();\n            return;\n        }\n        // Update the scroll position if the section is not visible.\n        if (offset + oldSize <= hh) {\n            this._scrollY += delta;\n            this._syncScrollState();\n            return;\n        }\n        // Compute the paint origin of the section.\n        let pos = Math.max(hh, offset);\n        // Paint from the section onward if it spans the viewport.\n        if (offset + oldSize >= vh || offset + newSize >= vh) {\n            this.paintContent(0, pos, vw, vh - pos);\n            this._paintOverlay();\n            this._syncScrollState();\n            return;\n        }\n        // Compute the X blit dimensions.\n        let sx = 0;\n        let sw = vw;\n        let dx = 0;\n        // Compute the Y blit dimensions.\n        let sy;\n        let sh;\n        let dy;\n        if (offset + newSize <= hh) {\n            sy = hh - delta;\n            sh = vh - sy;\n            dy = hh;\n        }\n        else {\n            sy = offset + oldSize;\n            sh = vh - sy;\n            dy = sy + delta;\n        }\n        // Blit the valid content to the destination.\n        this._blitContent(this._canvas, sx, sy, sw, sh, dx, dy);\n        // Repaint the section if needed.\n        if (newSize > 0 && offset + newSize > hh) {\n            this.paintContent(0, pos, vw, offset + newSize - pos);\n        }\n        // Paint the trailing space as needed.\n        if (this._stretchLastRow && this.pageHeight > this.bodyHeight) {\n            let r = this._rowSections.count - 1;\n            let y = hh + this._rowSections.offsetOf(r);\n            this.paintContent(0, y, vw, vh - y);\n        }\n        else if (delta < 0) {\n            this.paintContent(0, vh + delta, vw, -delta);\n        }\n        // Repaint merged cells that are intersected by the resized row\n        // Otherwise it will be cut in two by the valid content, and drawn incorrectly\n        for (const rgn of ['body', 'row-header']) {\n            const cellGroups = CellGroup.getCellGroupsAtRow(this.dataModel, rgn, index);\n            let paintRgn = {\n                region: rgn,\n                xMin: 0,\n                xMax: 0,\n                yMin: 0,\n                yMax: 0\n            };\n            let backgroundColor = undefined;\n            switch (rgn) {\n                case 'body':\n                    paintRgn.xMin = this.headerWidth;\n                    paintRgn.xMax = this.headerWidth + this.bodyWidth;\n                    paintRgn.yMin = this.headerHeight;\n                    paintRgn.yMax = this.headerHeight + this.bodyHeight;\n                    backgroundColor = this._style.backgroundColor;\n                    break;\n                case 'row-header':\n                    paintRgn.xMin = 0;\n                    paintRgn.xMax = this.headerWidth;\n                    paintRgn.yMin = this.headerHeight;\n                    paintRgn.yMax = this.headerHeight + this.bodyHeight;\n                    backgroundColor = this._style.headerBackgroundColor;\n                    break;\n            }\n            this._paintMergedCells(cellGroups, paintRgn, backgroundColor);\n        }\n        // Paint the overlay.\n        this._paintOverlay();\n        // Sync the scroll state.\n        this._syncScrollState();\n    }\n    /**\n     * Resize a column section immediately.\n     */\n    _resizeColumn(index, size) {\n        // Look up the target section list.\n        let list = this._columnSections;\n        // Bail early if the index is out of range.\n        if (index < 0 || index >= list.count) {\n            return;\n        }\n        const adjustedSize = size !== null && size !== void 0 ? size : this._getMaxWidthInColumn(index, 'body');\n        if (!adjustedSize || adjustedSize == 0) {\n            return;\n        }\n        // Look up the old size of the section.\n        let oldSize = list.sizeOf(index);\n        // Normalize the new size of the section.\n        let newSize = list.clampSize(adjustedSize);\n        // Bail early if the size does not change.\n        if (oldSize === newSize) {\n            return;\n        }\n        // Resize the section in the list.\n        list.resize(index, newSize);\n        // Get the current size of the viewport.\n        let vw = this._viewportWidth;\n        let vh = this._viewportHeight;\n        // If there is nothing to paint, sync the scroll state.\n        if (!this._viewport.isVisible || vw === 0 || vh === 0) {\n            this._syncScrollState();\n            return;\n        }\n        // Compute the size delta.\n        let delta = newSize - oldSize;\n        // Look up the row header width.\n        let hw = this.headerWidth;\n        // Compute the viewport offset of the section.\n        let offset = list.offsetOf(index) + hw - this._scrollX;\n        // Bail early if there is nothing to paint.\n        if (hw >= vw || offset >= vw) {\n            this._syncScrollState();\n            return;\n        }\n        // Update the scroll position if the section is not visible.\n        if (offset + oldSize <= hw) {\n            this._scrollX += delta;\n            this._syncScrollState();\n            return;\n        }\n        // Compute the paint origin of the section.\n        let pos = Math.max(hw, offset);\n        // Paint from the section onward if it spans the viewport.\n        if (offset + oldSize >= vw || offset + newSize >= vw) {\n            this.paintContent(pos, 0, vw - pos, vh);\n            this._paintOverlay();\n            this._syncScrollState();\n            return;\n        }\n        // Compute the Y blit dimensions.\n        let sy = 0;\n        let sh = vh;\n        let dy = 0;\n        // Compute the X blit dimensions.\n        let sx;\n        let sw;\n        let dx;\n        if (offset + newSize <= hw) {\n            sx = hw - delta;\n            sw = vw - sx;\n            dx = hw;\n        }\n        else {\n            sx = offset + oldSize;\n            sw = vw - sx;\n            dx = sx + delta;\n        }\n        // Blit the valid content to the destination.\n        this._blitContent(this._canvas, sx, sy, sw, sh, dx, dy);\n        // Repaint the section if needed.\n        if (newSize > 0 && offset + newSize > hw) {\n            this.paintContent(pos, 0, offset + newSize - pos, vh);\n        }\n        // Paint the trailing space as needed.\n        if (this._stretchLastColumn && this.pageWidth > this.bodyWidth) {\n            let c = this._columnSections.count - 1;\n            let x = hw + this._columnSections.offsetOf(c);\n            this.paintContent(x, 0, vw - x, vh);\n        }\n        else if (delta < 0) {\n            this.paintContent(vw + delta, 0, -delta, vh);\n        }\n        // Repaint merged cells that are intersected by the resized column\n        // Otherwise it will be cut in two by the valid content, and drawn incorrectly\n        for (const rgn of ['body', 'column-header']) {\n            const cellGroups = CellGroup.getCellGroupsAtColumn(this.dataModel, rgn, index);\n            let paintRgn = {\n                region: rgn,\n                xMin: 0,\n                xMax: 0,\n                yMin: 0,\n                yMax: 0\n            };\n            let backgroundColor = undefined;\n            switch (rgn) {\n                case 'body':\n                    paintRgn.xMin = this.headerWidth;\n                    paintRgn.xMax = this.headerWidth + this.bodyWidth;\n                    paintRgn.yMin = this.headerHeight;\n                    paintRgn.yMax = this.headerHeight + this.bodyHeight;\n                    backgroundColor = this._style.backgroundColor;\n                    break;\n                case 'column-header':\n                    paintRgn.xMin = this.headerWidth;\n                    paintRgn.xMax = this.headerWidth + this.bodyWidth;\n                    paintRgn.yMin = 0;\n                    paintRgn.yMax = this.headerHeight;\n                    backgroundColor = this._style.headerBackgroundColor;\n                    break;\n            }\n            this._paintMergedCells(cellGroups, paintRgn, backgroundColor);\n        }\n        // Paint the overlay.\n        this._paintOverlay();\n        // Sync the scroll state after painting.\n        this._syncScrollState();\n    }\n    /**\n     * Resize a row header section immediately.\n     */\n    _resizeRowHeader(index, size) {\n        // Look up the target section list.\n        let list = this._rowHeaderSections;\n        // Bail early if the index is out of range.\n        if (index < 0 || index >= list.count) {\n            return;\n        }\n        const adjustedSize = size !== null && size !== void 0 ? size : this._getMaxWidthInColumn(index, 'row-header');\n        if (!adjustedSize || adjustedSize == 0) {\n            return;\n        }\n        // Look up the old size of the section.\n        let oldSize = list.sizeOf(index);\n        // Normalize the new size of the section.\n        let newSize = list.clampSize(adjustedSize);\n        // Bail early if the size does not change.\n        if (oldSize === newSize) {\n            return;\n        }\n        // Resize the section in the list.\n        list.resize(index, newSize);\n        // Get the current size of the viewport.\n        let vw = this._viewportWidth;\n        let vh = this._viewportHeight;\n        // If there is nothing to paint, sync the scroll state.\n        if (!this._viewport.isVisible || vw === 0 || vh === 0) {\n            this._syncScrollState();\n            return;\n        }\n        // Compute the size delta.\n        let delta = newSize - oldSize;\n        // Look up the offset of the section.\n        let offset = list.offsetOf(index);\n        // Bail early if the section is fully outside the viewport.\n        if (offset >= vw) {\n            this._syncScrollState();\n            return;\n        }\n        // Paint the entire tail if the section spans the viewport.\n        if (offset + oldSize >= vw || offset + newSize >= vw) {\n            this.paintContent(offset, 0, vw - offset, vh);\n            this._paintOverlay();\n            this._syncScrollState();\n            return;\n        }\n        // Compute the blit content dimensions.\n        let sx = offset + oldSize;\n        let sy = 0;\n        let sw = vw - sx;\n        let sh = vh;\n        let dx = sx + delta;\n        let dy = 0;\n        // Blit the valid content to the destination.\n        this._blitContent(this._canvas, sx, sy, sw, sh, dx, dy);\n        // Repaint the header section if needed.\n        if (newSize > 0) {\n            this.paintContent(offset, 0, newSize, vh);\n        }\n        // Paint the trailing space as needed.\n        if (this._stretchLastColumn && this.pageWidth > this.bodyWidth) {\n            let c = this._columnSections.count - 1;\n            let x = this.headerWidth + this._columnSections.offsetOf(c);\n            this.paintContent(x, 0, vw - x, vh);\n        }\n        else if (delta < 0) {\n            this.paintContent(vw + delta, 0, -delta, vh);\n        }\n        // Repaint merged cells that are intersected by the resized row\n        // Otherwise it will be cut in two by the valid content, and drawn incorrectly\n        for (const rgn of [\n            'corner-header',\n            'row-header'\n        ]) {\n            const cellGroups = CellGroup.getCellGroupsAtColumn(this.dataModel, rgn, index);\n            let paintRgn = {\n                region: rgn,\n                xMin: 0,\n                xMax: 0,\n                yMin: 0,\n                yMax: 0\n            };\n            switch (rgn) {\n                case 'corner-header':\n                    paintRgn.xMin = 0;\n                    paintRgn.xMax = this.headerWidth;\n                    paintRgn.yMin = 0;\n                    paintRgn.yMax = this.headerHeight;\n                    break;\n                case 'row-header':\n                    paintRgn.xMin = 0;\n                    paintRgn.xMax = this.headerWidth;\n                    paintRgn.yMin = this.headerHeight;\n                    paintRgn.yMax = this.headerHeight + this.bodyHeight;\n                    break;\n            }\n            this._paintMergedCells(cellGroups, paintRgn, this._style.headerBackgroundColor);\n        }\n        // Paint the overlay.\n        this._paintOverlay();\n        // Sync the scroll state after painting.\n        this._syncScrollState();\n    }\n    /**\n     * Resize a column header section immediately.\n     */\n    _resizeColumnHeader(index, size) {\n        // Look up the target section list.\n        let list = this._columnHeaderSections;\n        // Bail early if the index is out of range.\n        if (index < 0 || index >= list.count) {\n            return;\n        }\n        // Look up the old size of the section.\n        let oldSize = list.sizeOf(index);\n        // Normalize the new size of the section.\n        let newSize = list.clampSize(size);\n        // Bail early if the size does not change.\n        if (oldSize === newSize) {\n            return;\n        }\n        // Resize the section in the list.\n        list.resize(index, newSize);\n        // Get the current size of the viewport.\n        let vw = this._viewportWidth;\n        let vh = this._viewportHeight;\n        // If there is nothing to paint, sync the scroll state.\n        if (!this._viewport.isVisible || vw === 0 || vh === 0) {\n            this._syncScrollState();\n            return;\n        }\n        // Paint the overlay.\n        this._paintOverlay();\n        // Compute the size delta.\n        let delta = newSize - oldSize;\n        // Look up the offset of the section.\n        let offset = list.offsetOf(index);\n        // Bail early if the section is fully outside the viewport.\n        if (offset >= vh) {\n            this._syncScrollState();\n            return;\n        }\n        // Paint the entire tail if the section spans the viewport.\n        if (offset + oldSize >= vh || offset + newSize >= vh) {\n            this.paintContent(0, offset, vw, vh - offset);\n            this._paintOverlay();\n            this._syncScrollState();\n            return;\n        }\n        // Compute the blit content dimensions.\n        let sx = 0;\n        let sy = offset + oldSize;\n        let sw = vw;\n        let sh = vh - sy;\n        let dx = 0;\n        let dy = sy + delta;\n        // Blit the valid contents to the destination.\n        this._blitContent(this._canvas, sx, sy, sw, sh, dx, dy);\n        // Repaint the header section if needed.\n        if (newSize > 0) {\n            this.paintContent(0, offset, vw, newSize);\n        }\n        // Paint the trailing space as needed.\n        if (this._stretchLastRow && this.pageHeight > this.bodyHeight) {\n            let r = this._rowSections.count - 1;\n            let y = this.headerHeight + this._rowSections.offsetOf(r);\n            this.paintContent(0, y, vw, vh - y);\n        }\n        else if (delta < 0) {\n            this.paintContent(0, vh + delta, vw, -delta);\n        }\n        // Repaint merged cells that are intersected by the resized row\n        // Otherwise it will be cut in two by the valid content, and drawn incorrectly\n        for (const rgn of [\n            'corner-header',\n            'column-header'\n        ]) {\n            const cellGroups = CellGroup.getCellGroupsAtRow(this.dataModel, rgn, index);\n            let paintRgn = {\n                region: rgn,\n                xMin: 0,\n                xMax: 0,\n                yMin: 0,\n                yMax: 0\n            };\n            switch (rgn) {\n                case 'corner-header':\n                    paintRgn.xMin = 0;\n                    paintRgn.xMax = this.headerWidth;\n                    paintRgn.yMin = 0;\n                    paintRgn.yMax = this.headerHeight;\n                    break;\n                case 'column-header':\n                    paintRgn.xMin = this.headerWidth;\n                    paintRgn.xMax = this.headerWidth + this.bodyWidth;\n                    paintRgn.yMin = 0;\n                    paintRgn.yMax = this.headerHeight;\n                    break;\n            }\n            this._paintMergedCells(cellGroups, paintRgn, this._style.headerBackgroundColor);\n        }\n        // Paint the overlay.\n        this._paintOverlay();\n        // Sync the scroll state after painting.\n        this._syncScrollState();\n    }\n    /**\n     * Scroll immediately to the specified offset position.\n     */\n    _scrollTo(x, y) {\n        // Bail if no data model found.\n        if (!this.dataModel) {\n            return;\n        }\n        // Floor and clamp the position to the allowable range.\n        x = Math.max(0, Math.min(Math.floor(x), this.maxScrollX));\n        y = Math.max(0, Math.min(Math.floor(y), this.maxScrollY));\n        // Synchronize the scroll bar values.\n        this._hScrollBar.value = x;\n        this._vScrollBar.value = y;\n        // Compute the delta scroll amount.\n        let dx = x - this._scrollX;\n        let dy = y - this._scrollY;\n        // Bail early if there is no effective scroll.\n        if (dx === 0 && dy === 0) {\n            return;\n        }\n        // Bail early if the viewport is not visible.\n        if (!this._viewport.isVisible) {\n            this._scrollX = x;\n            this._scrollY = y;\n            return;\n        }\n        // Get the current size of the viewport.\n        let width = this._viewportWidth;\n        let height = this._viewportHeight;\n        // Bail early if the viewport is empty.\n        if (width === 0 || height === 0) {\n            this._scrollX = x;\n            this._scrollY = y;\n            return;\n        }\n        // Get the visible content origin.\n        let contentX = this.headerWidth;\n        let contentY = this.headerHeight;\n        // Get the visible content dimensions.\n        let contentWidth = width - contentX;\n        let contentHeight = height - contentY;\n        // Bail early if there is no content to draw.\n        if (contentWidth <= 0 && contentHeight <= 0) {\n            this._scrollX = x;\n            this._scrollY = y;\n            return;\n        }\n        // Compute the area which needs painting for the `dx` scroll.\n        let dxArea = 0;\n        if (dx !== 0 && contentWidth > 0) {\n            if (Math.abs(dx) >= contentWidth) {\n                dxArea = contentWidth * height;\n            }\n            else {\n                dxArea = Math.abs(dx) * height;\n            }\n        }\n        // Compute the area which needs painting for the `dy` scroll.\n        let dyArea = 0;\n        if (dy !== 0 && contentHeight > 0) {\n            if (Math.abs(dy) >= contentHeight) {\n                dyArea = width * contentHeight;\n            }\n            else {\n                dyArea = width * Math.abs(dy);\n            }\n        }\n        // If the area sum is larger than the total, paint everything.\n        if (dxArea + dyArea >= width * height) {\n            this._scrollX = x;\n            this._scrollY = y;\n            this.paintContent(0, 0, width, height);\n            this._paintOverlay();\n            return;\n        }\n        // Update the internal Y scroll position.\n        this._scrollY = y;\n        // Scroll the Y axis if needed. If the scroll distance exceeds\n        // the visible height, paint everything. Otherwise, blit the\n        // valid content and paint the dirty region.\n        if (dy !== 0 && contentHeight > 0) {\n            if (Math.abs(dy) >= contentHeight) {\n                this.paintContent(0, contentY, width, contentHeight);\n            }\n            else {\n                const x = 0;\n                const y = dy < 0 ? contentY : contentY + dy;\n                const w = width;\n                const h = contentHeight - Math.abs(dy);\n                this._blitContent(this._canvas, x, y, w, h, x, y - dy);\n                this.paintContent(0, dy < 0 ? contentY : height - dy, width, Math.abs(dy));\n                // Repaint merged cells that are intersected by the scroll level\n                // Otherwise it will be cut in two by the valid content, and drawn incorrectly\n                for (const rgn of ['body', 'row-header']) {\n                    const cellgroups = CellGroup.getCellGroupsAtRegion(this.dataModel, rgn);\n                    let paintRgn = {\n                        region: rgn,\n                        xMin: 0,\n                        xMax: 0,\n                        yMin: 0,\n                        yMax: 0\n                    };\n                    let backgroundColor = undefined;\n                    switch (rgn) {\n                        case 'body':\n                            paintRgn.xMin = this.headerWidth;\n                            paintRgn.xMax = this.headerWidth + this.bodyWidth;\n                            paintRgn.yMin = this.headerHeight;\n                            paintRgn.yMax = this.headerHeight + this.bodyHeight;\n                            backgroundColor = this._style.backgroundColor;\n                            break;\n                        case 'row-header':\n                            paintRgn.xMin = 0;\n                            paintRgn.xMax = this.headerWidth;\n                            paintRgn.yMin = this.headerHeight;\n                            paintRgn.yMax = this.headerHeight + this.bodyHeight;\n                            backgroundColor = this._style.headerBackgroundColor;\n                            break;\n                    }\n                    this._paintMergedCells(cellgroups, paintRgn, backgroundColor);\n                }\n            }\n        }\n        // Update the internal X scroll position.\n        this._scrollX = x;\n        // Scroll the X axis if needed. If the scroll distance exceeds\n        // the visible width, paint everything. Otherwise, blit the\n        // valid content and paint the dirty region.\n        if (dx !== 0 && contentWidth > 0) {\n            if (Math.abs(dx) >= contentWidth) {\n                this.paintContent(contentX, 0, contentWidth, height);\n            }\n            else {\n                const x = dx < 0 ? contentX : contentX + dx;\n                const y = 0;\n                const w = contentWidth - Math.abs(dx);\n                const h = height;\n                this._blitContent(this._canvas, x, y, w, h, x - dx, y);\n                this.paintContent(dx < 0 ? contentX : width - dx, 0, Math.abs(dx), height);\n                // Repaint merged cells that are intersected by the scroll level\n                // Otherwise it will be cut in two by the valid content, and drawn incorrectly\n                for (const rgn of ['body', 'column-header']) {\n                    const cellGroups = CellGroup.getCellGroupsAtRegion(this.dataModel, rgn);\n                    let paintRgn = {\n                        region: rgn,\n                        xMin: 0,\n                        xMax: 0,\n                        yMin: 0,\n                        yMax: 0\n                    };\n                    let backgroundColor = undefined;\n                    switch (rgn) {\n                        case 'body':\n                            paintRgn.xMin = this.headerWidth;\n                            paintRgn.xMax = this.headerWidth + this.bodyWidth;\n                            paintRgn.yMin = this.headerHeight;\n                            paintRgn.yMax = this.headerHeight + this.bodyHeight;\n                            backgroundColor = this._style.backgroundColor;\n                            break;\n                        case 'column-header':\n                            paintRgn.xMin = this.headerWidth;\n                            paintRgn.xMax = this.headerWidth + this.bodyWidth;\n                            paintRgn.yMin = 0;\n                            paintRgn.yMax = this.headerHeight;\n                            backgroundColor = this._style.headerBackgroundColor;\n                            break;\n                    }\n                    this._paintMergedCells(cellGroups, paintRgn, backgroundColor);\n                }\n            }\n        }\n        // Paint the overlay.\n        this._paintOverlay();\n    }\n    /**\n     * Blit content into the on-screen grid canvas.\n     *\n     * The rect should be expressed in viewport coordinates.\n     *\n     * This automatically accounts for the dpi ratio.\n     */\n    _blitContent(source, x, y, w, h, dx, dy) {\n        // Scale the blit coordinates by the dpi ratio.\n        x *= this._dpiRatio;\n        y *= this._dpiRatio;\n        w *= this._dpiRatio;\n        h *= this._dpiRatio;\n        dx *= this._dpiRatio;\n        dy *= this._dpiRatio;\n        // Save the current gc state.\n        this._canvasGC.save();\n        // Set the transform to the identity matrix.\n        this._canvasGC.setTransform(1, 0, 0, 1, 0, 0);\n        // Draw the specified content.\n        this._canvasGC.drawImage(source, x, y, w, h, dx, dy, w, h);\n        // Restore the gc state.\n        this._canvasGC.restore();\n    }\n    /**\n     * Paint the grid content for the given dirty rect.\n     *\n     * The rect should be expressed in valid viewport coordinates.\n     *\n     * This is the primary paint entry point. The individual `_draw*`\n     * methods should not be invoked directly. This method dispatches\n     * to the drawing methods in the correct order.\n     */\n    paintContent(rx, ry, rw, rh) {\n        // Scale the canvas and buffer GC for the dpi ratio.\n        this._canvasGC.setTransform(this._dpiRatio, 0, 0, this._dpiRatio, 0, 0);\n        this._bufferGC.setTransform(this._dpiRatio, 0, 0, this._dpiRatio, 0, 0);\n        // Clear the dirty rect of all content.\n        this._canvasGC.clearRect(rx, ry, rw, rh);\n        // Draw the void region.\n        this._drawVoidRegion(rx, ry, rw, rh);\n        // Draw the body region.\n        this._drawBodyRegion(rx, ry, rw, rh);\n        // Draw the row header region.\n        this._drawRowHeaderRegion(rx, ry, rw, rh);\n        // Draw the column header region.\n        this._drawColumnHeaderRegion(rx, ry, rw, rh);\n        // Draw the corner header region.\n        this.drawCornerHeaderRegion(rx, ry, rw, rh);\n    }\n    /**\n     * Resizes body column headers so their text fits\n     * without clipping or wrapping.\n     * @param dataModel\n     */\n    _fitBodyColumnHeaders(dataModel, padding, numCols) {\n        // Get the body column count\n        const bodyColumnCount = numCols === undefined ? dataModel.columnCount('body') : numCols;\n        for (let i = 0; i < bodyColumnCount; i++) {\n            /*\n              if we're working with nested column headers,\n              retrieve the nested levels and iterate on them.\n            */\n            const numRows = dataModel.rowCount('column-header');\n            /*\n              Calculate the maximum text width, across\n              all nested rows under a given column number.\n            */\n            let maxWidth = 0;\n            for (let j = 0; j < numRows; j++) {\n                const config = DataGrid._getConfig(dataModel, j, i, 'column-header');\n                const textWidth = this._getCellTextWidth(config);\n                // Update the maximum width for that column.\n                maxWidth = Math.max(maxWidth, textWidth);\n            }\n            /*\n              Send a resize message with new width for the given column.\n              Using a padding of 15 pixels to leave some room.\n            */\n            this.resizeColumn('body', i, maxWidth + padding);\n        }\n    }\n    /**\n     * Resizes row header columns so their text fits\n     * without clipping or wrapping.\n     * @param dataModel\n     */\n    _fitRowColumnHeaders(dataModel, padding, numCols) {\n        /*\n          if we're working with nested row headers,\n          retrieve the nested levels and iterate on them.\n        */\n        const rowColumnCount = numCols === undefined ? dataModel.columnCount('row-header') : numCols;\n        for (let i = 0; i < rowColumnCount; i++) {\n            const numCols = dataModel.rowCount('column-header');\n            /*\n              Calculate the maximum text width, across\n              all nested columns under a given row index.\n            */\n            let maxWidth = 0;\n            for (let j = 0; j < numCols; j++) {\n                const config = DataGrid._getConfig(dataModel, j, i, 'corner-header');\n                const textWidth = this._getCellTextWidth(config);\n                maxWidth = Math.max(maxWidth, textWidth);\n            }\n            /*\n              Send a resize message with new width for the given column.\n              Using a padding of 15 pixels to leave some room.\n            */\n            this.resizeColumn('row-header', i, maxWidth + padding);\n        }\n    }\n    /**\n     * Paint the overlay content for the entire grid.\n     *\n     * This is the primary overlay paint entry point. The individual\n     * `_draw*` methods should not be invoked directly. This method\n     * dispatches to the drawing methods in the correct order.\n     */\n    _paintOverlay() {\n        // Scale the overlay GC for the dpi ratio.\n        this._overlayGC.setTransform(this._dpiRatio, 0, 0, this._dpiRatio, 0, 0);\n        // Clear the overlay of all content.\n        this._overlayGC.clearRect(0, 0, this._overlay.width, this._overlay.height);\n        // Draw the body selections.\n        this._drawBodySelections();\n        // Draw the row header selections.\n        this._drawRowHeaderSelections();\n        // Draw the column header selections.\n        this._drawColumnHeaderSelections();\n        // Draw the cursor.\n        this._drawCursor();\n        // Draw the shadows.\n        this._drawShadows();\n    }\n    /**\n     * Draw the void region for the dirty rect.\n     */\n    _drawVoidRegion(rx, ry, rw, rh) {\n        // Look up the void color.\n        let color = this._style.voidColor;\n        // Bail if there is no void color.\n        if (!color) {\n            return;\n        }\n        // Fill the dirty rect with the void color.\n        this._canvasGC.fillStyle = color;\n        this._canvasGC.fillRect(rx, ry, rw, rh);\n    }\n    /**\n     * Draw the body region which intersects the dirty rect.\n     */\n    _drawBodyRegion(rx, ry, rw, rh) {\n        // Get the visible content dimensions.\n        let contentW = this._columnSections.length - this._scrollX;\n        let contentH = this._rowSections.length - this._scrollY;\n        // Bail if there is no content to draw.\n        if (contentW <= 0 || contentH <= 0) {\n            return;\n        }\n        // Get the visible content origin.\n        let contentX = this.headerWidth;\n        let contentY = this.headerHeight;\n        // Bail if the dirty rect does not intersect the content area.\n        if (rx + rw <= contentX) {\n            return;\n        }\n        if (ry + rh <= contentY) {\n            return;\n        }\n        if (rx >= contentX + contentW) {\n            return;\n        }\n        if (ry >= contentY + contentH) {\n            return;\n        }\n        // Fetch the geometry.\n        let bh = this.bodyHeight;\n        let bw = this.bodyWidth;\n        let ph = this.pageHeight;\n        let pw = this.pageWidth;\n        // Get the upper and lower bounds of the dirty content area.\n        let x1 = Math.max(rx, contentX);\n        let y1 = Math.max(ry, contentY);\n        let x2 = Math.min(rx + rw - 1, contentX + contentW - 1);\n        let y2 = Math.min(ry + rh - 1, contentY + contentH - 1);\n        // Convert the dirty content bounds into cell bounds.\n        let r1 = this._rowSections.indexOf(y1 - contentY + this._scrollY);\n        let c1 = this._columnSections.indexOf(x1 - contentX + this._scrollX);\n        let r2 = this._rowSections.indexOf(y2 - contentY + this._scrollY);\n        let c2 = this._columnSections.indexOf(x2 - contentX + this._scrollX);\n        // Fetch the max row and column.\n        let maxRow = this._rowSections.count - 1;\n        let maxColumn = this._columnSections.count - 1;\n        // Handle a dirty content area larger than the cell count.\n        if (r2 < 0) {\n            r2 = maxRow;\n        }\n        if (c2 < 0) {\n            c2 = maxColumn;\n        }\n        // Convert the cell bounds back to visible coordinates.\n        let x = this._columnSections.offsetOf(c1) + contentX - this._scrollX;\n        let y = this._rowSections.offsetOf(r1) + contentY - this._scrollY;\n        // Set up the paint region size variables.\n        let width = 0;\n        let height = 0;\n        // Allocate the section sizes arrays.\n        let rowSizes = new Array(r2 - r1 + 1);\n        let columnSizes = new Array(c2 - c1 + 1);\n        // Get the row sizes for the region.\n        for (let j = r1; j <= r2; ++j) {\n            let size = this._rowSections.sizeOf(j);\n            rowSizes[j - r1] = size;\n            height += size;\n        }\n        // Get the column sizes for the region.\n        for (let i = c1; i <= c2; ++i) {\n            let size = this._columnSections.sizeOf(i);\n            columnSizes[i - c1] = size;\n            width += size;\n        }\n        // Adjust the geometry if the last row is streched.\n        if (this._stretchLastRow && ph > bh && r2 === maxRow) {\n            let dh = this.pageHeight - this.bodyHeight;\n            rowSizes[rowSizes.length - 1] += dh;\n            height += dh;\n            y2 += dh;\n        }\n        // Adjust the geometry if the last column is streched.\n        if (this._stretchLastColumn && pw > bw && c2 === maxColumn) {\n            let dw = this.pageWidth - this.bodyWidth;\n            columnSizes[columnSizes.length - 1] += dw;\n            width += dw;\n            x2 += dw;\n        }\n        // Create the paint region object.\n        let rgn = {\n            region: 'body',\n            xMin: x1,\n            yMin: y1,\n            xMax: x2,\n            yMax: y2,\n            x,\n            y,\n            width,\n            height,\n            row: r1,\n            column: c1,\n            rowSizes,\n            columnSizes\n        };\n        // Draw the background.\n        this._drawBackground(rgn, this._style.backgroundColor);\n        // Draw the row background.\n        this._drawRowBackground(rgn, this._style.rowBackgroundColor);\n        // Draw the column background.\n        this._drawColumnBackground(rgn, this._style.columnBackgroundColor);\n        // Draw the cell content for the paint region.\n        this._drawCells(rgn);\n        // Draw the horizontal grid lines.\n        this._drawHorizontalGridLines(rgn, this._style.horizontalGridLineColor || this._style.gridLineColor);\n        // Draw the vertical grid lines.\n        this._drawVerticalGridLines(rgn, this._style.verticalGridLineColor || this._style.gridLineColor);\n        // Get the cellgroups from the cell-region that intersects with the paint region\n        const cellGroups = CellGroup.getCellGroupsAtRegion(this.dataModel, rgn.region).filter(group => {\n            return this.cellGroupInteresectsRegion(group, rgn);\n        });\n        // Draw merged cells\n        this._paintMergedCells(cellGroups, rgn, this._style.backgroundColor);\n    }\n    /**\n     * Draw the row header region which intersects the dirty rect.\n     */\n    _drawRowHeaderRegion(rx, ry, rw, rh) {\n        // Get the visible content dimensions.\n        let contentW = this.headerWidth;\n        let contentH = this.bodyHeight - this._scrollY;\n        // Bail if there is no content to draw.\n        if (contentW <= 0 || contentH <= 0) {\n            return;\n        }\n        // Get the visible content origin.\n        let contentX = 0;\n        let contentY = this.headerHeight;\n        // Bail if the dirty rect does not intersect the content area.\n        if (rx + rw <= contentX) {\n            return;\n        }\n        if (ry + rh <= contentY) {\n            return;\n        }\n        if (rx >= contentX + contentW) {\n            return;\n        }\n        if (ry >= contentY + contentH) {\n            return;\n        }\n        // Fetch the geometry.\n        let bh = this.bodyHeight;\n        let ph = this.pageHeight;\n        // Get the upper and lower bounds of the dirty content area.\n        let x1 = rx;\n        let y1 = Math.max(ry, contentY);\n        let x2 = Math.min(rx + rw - 1, contentX + contentW - 1);\n        let y2 = Math.min(ry + rh - 1, contentY + contentH - 1);\n        // Convert the dirty content bounds into cell bounds.\n        let r1 = this._rowSections.indexOf(y1 - contentY + this._scrollY);\n        let c1 = this._rowHeaderSections.indexOf(x1);\n        let r2 = this._rowSections.indexOf(y2 - contentY + this._scrollY);\n        let c2 = this._rowHeaderSections.indexOf(x2);\n        // Fetch max row and column.\n        let maxRow = this._rowSections.count - 1;\n        let maxColumn = this._rowHeaderSections.count - 1;\n        // Handle a dirty content area larger than the cell count.\n        if (r2 < 0) {\n            r2 = maxRow;\n        }\n        if (c2 < 0) {\n            c2 = maxColumn;\n        }\n        // Convert the cell bounds back to visible coordinates.\n        let x = this._rowHeaderSections.offsetOf(c1);\n        let y = this._rowSections.offsetOf(r1) + contentY - this._scrollY;\n        // Set up the paint region size variables.\n        let width = 0;\n        let height = 0;\n        // Allocate the section sizes arrays.\n        let rowSizes = new Array(r2 - r1 + 1);\n        let columnSizes = new Array(c2 - c1 + 1);\n        // Get the row sizes for the region.\n        for (let j = r1; j <= r2; ++j) {\n            let size = this._rowSections.sizeOf(j);\n            rowSizes[j - r1] = size;\n            height += size;\n        }\n        // Get the column sizes for the region.\n        for (let i = c1; i <= c2; ++i) {\n            let size = this._rowHeaderSections.sizeOf(i);\n            columnSizes[i - c1] = size;\n            width += size;\n        }\n        // Adjust the geometry if the last row is stretched.\n        if (this._stretchLastRow && ph > bh && r2 === maxRow) {\n            let dh = this.pageHeight - this.bodyHeight;\n            rowSizes[rowSizes.length - 1] += dh;\n            height += dh;\n            y2 += dh;\n        }\n        // Create the paint region object.\n        let rgn = {\n            region: 'row-header',\n            xMin: x1,\n            yMin: y1,\n            xMax: x2,\n            yMax: y2,\n            x,\n            y,\n            width,\n            height,\n            row: r1,\n            column: c1,\n            rowSizes,\n            columnSizes\n        };\n        // Draw the background.\n        this._drawBackground(rgn, this._style.headerBackgroundColor);\n        // Draw the cell content for the paint region.\n        this._drawCells(rgn);\n        // Draw the horizontal grid lines.\n        this._drawHorizontalGridLines(rgn, this._style.headerHorizontalGridLineColor ||\n            this._style.headerGridLineColor);\n        // Draw the vertical grid lines.\n        this._drawVerticalGridLines(rgn, this._style.headerVerticalGridLineColor || this._style.headerGridLineColor);\n        // Get the cellgroups from the cell-region that intersects with the paint region\n        const cellGroups = CellGroup.getCellGroupsAtRegion(this.dataModel, rgn.region).filter(group => {\n            return this.cellGroupInteresectsRegion(group, rgn);\n        });\n        // Draw merged cells\n        this._paintMergedCells(cellGroups, rgn, this._style.headerBackgroundColor);\n    }\n    /**\n     * Draw the column header region which intersects the dirty rect.\n     */\n    _drawColumnHeaderRegion(rx, ry, rw, rh) {\n        // Get the visible content dimensions.\n        let contentW = this.bodyWidth - this._scrollX;\n        let contentH = this.headerHeight;\n        // Bail if there is no content to draw.\n        if (contentW <= 0 || contentH <= 0) {\n            return;\n        }\n        // Get the visible content origin.\n        let contentX = this.headerWidth;\n        let contentY = 0;\n        // Bail if the dirty rect does not intersect the content area.\n        if (rx + rw <= contentX) {\n            return;\n        }\n        if (ry + rh <= contentY) {\n            return;\n        }\n        if (rx >= contentX + contentW) {\n            return;\n        }\n        if (ry >= contentY + contentH) {\n            return;\n        }\n        // Fetch the geometry.\n        let bw = this.bodyWidth;\n        let pw = this.pageWidth;\n        // Get the upper and lower bounds of the dirty content area.\n        let x1 = Math.max(rx, contentX);\n        let y1 = ry;\n        let x2 = Math.min(rx + rw - 1, contentX + contentW - 1);\n        let y2 = Math.min(ry + rh - 1, contentY + contentH - 1);\n        // Convert the dirty content bounds into cell bounds.\n        let r1 = this._columnHeaderSections.indexOf(y1);\n        let c1 = this._columnSections.indexOf(x1 - contentX + this._scrollX);\n        let r2 = this._columnHeaderSections.indexOf(y2);\n        let c2 = this._columnSections.indexOf(x2 - contentX + this._scrollX);\n        // Fetch the max row and column.\n        let maxRow = this._columnHeaderSections.count - 1;\n        let maxColumn = this._columnSections.count - 1;\n        // Handle a dirty content area larger than the cell count.\n        if (r2 < 0) {\n            r2 = maxRow;\n        }\n        if (c2 < 0) {\n            c2 = maxColumn;\n        }\n        // Convert the cell bounds back to visible coordinates.\n        let x = this._columnSections.offsetOf(c1) + contentX - this._scrollX;\n        let y = this._columnHeaderSections.offsetOf(r1);\n        // Set up the paint region size variables.\n        let width = 0;\n        let height = 0;\n        // Allocate the section sizes arrays.\n        let rowSizes = new Array(r2 - r1 + 1);\n        let columnSizes = new Array(c2 - c1 + 1);\n        // Get the row sizes for the region.\n        for (let j = r1; j <= r2; ++j) {\n            let size = this._columnHeaderSections.sizeOf(j);\n            rowSizes[j - r1] = size;\n            height += size;\n        }\n        // Get the column sizes for the region.\n        for (let i = c1; i <= c2; ++i) {\n            let size = this._columnSections.sizeOf(i);\n            columnSizes[i - c1] = size;\n            width += size;\n        }\n        // Adjust the geometry if the last column is stretched.\n        if (this._stretchLastColumn && pw > bw && c2 === maxColumn) {\n            let dw = this.pageWidth - this.bodyWidth;\n            columnSizes[columnSizes.length - 1] += dw;\n            width += dw;\n            x2 += dw;\n        }\n        // Create the paint region object.\n        let rgn = {\n            region: 'column-header',\n            xMin: x1,\n            yMin: y1,\n            xMax: x2,\n            yMax: y2,\n            x,\n            y,\n            width,\n            height,\n            row: r1,\n            column: c1,\n            rowSizes,\n            columnSizes\n        };\n        // Draw the background.\n        this._drawBackground(rgn, this._style.headerBackgroundColor);\n        // Draw the cell content for the paint region.\n        this._drawCells(rgn);\n        // Draw the horizontal grid lines.\n        this._drawHorizontalGridLines(rgn, this._style.headerHorizontalGridLineColor ||\n            this._style.headerGridLineColor);\n        // Draw the vertical grid lines.\n        this._drawVerticalGridLines(rgn, this._style.headerVerticalGridLineColor || this._style.headerGridLineColor);\n        // Get the cellgroups from the cell-region that intersects with the paint region\n        const cellGroups = CellGroup.getCellGroupsAtRegion(this.dataModel, rgn.region).filter(group => {\n            return this.cellGroupInteresectsRegion(group, rgn);\n        });\n        // Draw merged cells\n        this._paintMergedCells(cellGroups, rgn, this._style.headerBackgroundColor);\n    }\n    /**\n     * Draw the corner header region which intersects the dirty rect.\n     */\n    drawCornerHeaderRegion(rx, ry, rw, rh) {\n        // Get the visible content dimensions.\n        let contentW = this.headerWidth;\n        let contentH = this.headerHeight;\n        // Bail if there is no content to draw.\n        if (contentW <= 0 || contentH <= 0) {\n            return;\n        }\n        // Get the visible content origin.\n        let contentX = 0;\n        let contentY = 0;\n        // Bail if the dirty rect does not intersect the content area.\n        if (rx + rw <= contentX) {\n            return;\n        }\n        if (ry + rh <= contentY) {\n            return;\n        }\n        if (rx >= contentX + contentW) {\n            return;\n        }\n        if (ry >= contentY + contentH) {\n            return;\n        }\n        // Get the upper and lower bounds of the dirty content area.\n        let x1 = rx;\n        let y1 = ry;\n        let x2 = Math.min(rx + rw - 1, contentX + contentW - 1);\n        let y2 = Math.min(ry + rh - 1, contentY + contentH - 1);\n        // Convert the dirty content bounds into cell bounds.\n        let r1 = this._columnHeaderSections.indexOf(y1);\n        let c1 = this._rowHeaderSections.indexOf(x1);\n        let r2 = this._columnHeaderSections.indexOf(y2);\n        let c2 = this._rowHeaderSections.indexOf(x2);\n        // Handle a dirty content area larger than the cell count.\n        if (r2 < 0) {\n            r2 = this._columnHeaderSections.count - 1;\n        }\n        if (c2 < 0) {\n            c2 = this._rowHeaderSections.count - 1;\n        }\n        // Convert the cell bounds back to visible coordinates.\n        let x = this._rowHeaderSections.offsetOf(c1);\n        let y = this._columnHeaderSections.offsetOf(r1);\n        // Set up the paint region size variables.\n        let width = 0;\n        let height = 0;\n        // Allocate the section sizes arrays.\n        let rowSizes = new Array(r2 - r1 + 1);\n        let columnSizes = new Array(c2 - c1 + 1);\n        // Get the row sizes for the region.\n        for (let j = r1; j <= r2; ++j) {\n            let size = this._columnHeaderSections.sizeOf(j);\n            rowSizes[j - r1] = size;\n            height += size;\n        }\n        // Get the column sizes for the region.\n        for (let i = c1; i <= c2; ++i) {\n            let size = this._rowHeaderSections.sizeOf(i);\n            columnSizes[i - c1] = size;\n            width += size;\n        }\n        // Create the paint region object.\n        let rgn = {\n            region: 'corner-header',\n            xMin: x1,\n            yMin: y1,\n            xMax: x2,\n            yMax: y2,\n            x,\n            y,\n            width,\n            height,\n            row: r1,\n            column: c1,\n            rowSizes,\n            columnSizes\n        };\n        // Draw the background.\n        this._drawBackground(rgn, this._style.headerBackgroundColor);\n        // Draw the cell content for the paint region.\n        this._drawCells(rgn);\n        // Draw the horizontal grid lines.\n        this._drawHorizontalGridLines(rgn, this._style.headerHorizontalGridLineColor ||\n            this._style.headerGridLineColor);\n        // Draw the vertical grid lines.\n        this._drawVerticalGridLines(rgn, this._style.headerVerticalGridLineColor || this._style.headerGridLineColor);\n        // Get the cellgroups from the cell-region that intersects with the paint region\n        const cellGroups = CellGroup.getCellGroupsAtRegion(this.dataModel, rgn.region).filter(group => {\n            return this.cellGroupInteresectsRegion(group, rgn);\n        });\n        // Draw merged cells\n        this._paintMergedCells(cellGroups, rgn, this._style.headerBackgroundColor);\n    }\n    /**\n     * Draw the background for the given paint region.\n     */\n    _drawBackground(rgn, color) {\n        // Bail if there is no color to draw.\n        if (!color) {\n            return;\n        }\n        // Unpack the region.\n        let { xMin, yMin, xMax, yMax } = rgn;\n        // Fill the region with the specified color.\n        this._canvasGC.fillStyle = color;\n        this._canvasGC.fillRect(xMin, yMin, xMax - xMin + 1, yMax - yMin + 1);\n    }\n    /**\n     * Draw the row background for the given paint region.\n     */\n    _drawRowBackground(rgn, colorFn) {\n        // Bail if there is no color function.\n        if (!colorFn) {\n            return;\n        }\n        // Compute the X bounds for the row.\n        let x1 = Math.max(rgn.xMin, rgn.x);\n        let x2 = Math.min(rgn.x + rgn.width - 1, rgn.xMax);\n        // Draw the background for the rows in the region.\n        for (let y = rgn.y, j = 0, n = rgn.rowSizes.length; j < n; ++j) {\n            // Fetch the size of the row.\n            let size = rgn.rowSizes[j];\n            // Skip zero sized rows.\n            if (size === 0) {\n                continue;\n            }\n            // Get the background color for the row.\n            let color = colorFn(rgn.row + j);\n            // Fill the row with the background color if needed.\n            if (color) {\n                let y1 = Math.max(rgn.yMin, y);\n                let y2 = Math.min(y + size - 1, rgn.yMax);\n                this._canvasGC.fillStyle = color;\n                this._canvasGC.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n            }\n            // Increment the running Y coordinate.\n            y += size;\n        }\n    }\n    /**\n     * Draw the column background for the given paint region.\n     */\n    _drawColumnBackground(rgn, colorFn) {\n        // Bail if there is no color function.\n        if (!colorFn) {\n            return;\n        }\n        // Compute the Y bounds for the column.\n        let y1 = Math.max(rgn.yMin, rgn.y);\n        let y2 = Math.min(rgn.y + rgn.height - 1, rgn.yMax);\n        // Draw the background for the columns in the region.\n        for (let x = rgn.x, i = 0, n = rgn.columnSizes.length; i < n; ++i) {\n            // Fetch the size of the column.\n            let size = rgn.columnSizes[i];\n            // Skip zero sized columns.\n            if (size === 0) {\n                continue;\n            }\n            // Get the background color for the column.\n            let color = colorFn(rgn.column + i);\n            // Fill the column with the background color if needed.\n            if (color) {\n                let x1 = Math.max(rgn.xMin, x);\n                let x2 = Math.min(x + size - 1, rgn.xMax);\n                this._canvasGC.fillStyle = color;\n                this._canvasGC.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n            }\n            // Increment the running X coordinate.\n            x += size;\n        }\n    }\n    /**\n     * Returns column size\n     * @param region\n     * @param index\n     */\n    _getColumnSize(region, index) {\n        if (region === 'corner-header') {\n            return this._rowHeaderSections.sizeOf(index);\n        }\n        return this.columnSize(region, index);\n    }\n    /**\n     * Returns row size\n     * @param region\n     * @param index\n     */\n    _getRowSize(region, index) {\n        if (region === 'corner-header') {\n            return this._columnHeaderSections.sizeOf(index);\n        }\n        return this.rowSize(region, index);\n    }\n    /**\n     * Draw the cells for the given paint region.\n     */\n    _drawCells(rgn) {\n        // Bail if there is no data model.\n        if (!this._dataModel) {\n            return;\n        }\n        // Set up the cell config object for rendering.\n        let config = {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0,\n            region: rgn.region,\n            row: 0,\n            column: 0,\n            value: null,\n            metadata: DataModel.emptyMetadata\n        };\n        let groupIndex = -1;\n        // Save the buffer gc before wrapping.\n        this._bufferGC.save();\n        // Wrap the buffer gc for painting the cells.\n        let gc = new GraphicsContext(this._bufferGC);\n        let height = 0;\n        // Loop over the columns in the region.\n        for (let x = rgn.x, i = 0, n = rgn.columnSizes.length; i < n; ++i) {\n            // Fetch the size of the column.\n            let width = rgn.columnSizes[i];\n            // Skip zero sized columns.\n            if (width === 0) {\n                continue;\n            }\n            // Compute the column index.\n            let column = rgn.column + i;\n            // Update the config for the current column.\n            config.x = x;\n            config.width = width;\n            config.column = column;\n            // Loop over the rows in the column.\n            for (let y = rgn.y, j = 0, n = rgn.rowSizes.length; j < n; ++j) {\n                // Fetch the size of the row.\n                height = rgn.rowSizes[j];\n                // Skip zero sized rows.\n                if (height === 0) {\n                    continue;\n                }\n                // Compute the row index.\n                let row = rgn.row + j;\n                groupIndex = CellGroup.getGroupIndex(this.dataModel, config.region, row, column);\n                // For merged cell regions, don't do anything, we draw merged regions later.\n                if (groupIndex !== -1) {\n                    y += height;\n                    continue;\n                }\n                // Clear the buffer rect for the cell.\n                gc.clearRect(x, y, width, height);\n                let value = DataGrid._getCellValue(this.dataModel, rgn.region, row, column);\n                let metadata = DataGrid._getCellMetadata(this.dataModel, rgn.region, row, column);\n                // Update the config for the current cell.\n                config.y = y;\n                config.height = height;\n                config.width = width;\n                config.row = row;\n                config.value = value;\n                config.metadata = metadata;\n                // Get the renderer for the cell.\n                let renderer = this._cellRenderers.get(config);\n                // Save the GC state.\n                gc.save();\n                // Paint the cell into the off-screen buffer.\n                try {\n                    if (renderer instanceof AsyncCellRenderer) {\n                        if (renderer.isReady(config)) {\n                            renderer.paint(gc, config);\n                        }\n                        else {\n                            renderer.paintPlaceholder(gc, config);\n                            renderer.load(config).then(() => {\n                                const r1 = row;\n                                const r2 = row + 1;\n                                const c1 = column;\n                                const c2 = column + 1;\n                                this.repaintRegion(rgn.region, r1, c1, r2, c2);\n                            });\n                        }\n                    }\n                    else {\n                        renderer.paint(gc, config);\n                    }\n                }\n                catch (err) {\n                    console.error(err);\n                }\n                // Restore the GC state.\n                gc.restore();\n                // Compute the actual X bounds for the cell.\n                let x1 = Math.max(rgn.xMin, config.x);\n                let x2 = Math.min(config.x + config.width - 1, rgn.xMax);\n                // Compute the actual Y bounds for the cell.\n                let y1 = Math.max(rgn.yMin, config.y);\n                let y2 = Math.min(config.y + config.height - 1, rgn.yMax);\n                this._blitContent(this._buffer, x1, y1, x2 - x1 + 1, y2 - y1 + 1, x1, y1);\n                // Increment the running Y coordinate.\n                y += height;\n            }\n            // Restore the GC state.\n            gc.restore();\n            // Increment the running X coordinate.\n            x += width;\n        }\n        // Dispose of the wrapped gc.\n        gc.dispose();\n        // Restore the final buffer gc state.\n        this._bufferGC.restore();\n    }\n    // TODO Move this in the utils file (but we need the PaintRegion typing)\n    cellGroupInteresectsRegion(group, rgn) {\n        const rgnR1 = rgn.row;\n        const rgnR2 = rgn.row + rgn.rowSizes.length;\n        const rgnC1 = rgn.column;\n        const rgnC2 = rgn.column + rgn.columnSizes.length;\n        const dx = Math.min(group.r2, rgnR2) - Math.max(group.r1, rgnR1);\n        const dy = Math.min(group.c2, rgnC2) - Math.max(group.c1, rgnC1);\n        return dx >= 0 && dy >= 0;\n    }\n    static _getCellValue(dm, region, row, col) {\n        // Get the value for the cell.\n        try {\n            return dm.data(region, row, col);\n        }\n        catch (err) {\n            console.error(err);\n            return null;\n        }\n    }\n    static _getCellMetadata(dm, region, row, col) {\n        // Get the metadata for the cell.\n        try {\n            return dm.metadata(region, row, col);\n        }\n        catch (err) {\n            console.error(err);\n            return DataModel.emptyMetadata;\n        }\n    }\n    /**\n     * Paint group cells.\n     */\n    _paintMergedCells(cellGroups, rgn, backgroundColor) {\n        // Bail if there is no data model.\n        if (!this._dataModel) {\n            return;\n        }\n        // Set up the cell config object for rendering.\n        let config = {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0,\n            region: rgn.region,\n            row: 0,\n            column: 0,\n            value: null,\n            metadata: DataModel.emptyMetadata\n        };\n        if (backgroundColor) {\n            this._canvasGC.fillStyle = backgroundColor;\n        }\n        // Set the line width for the grid lines.\n        this._canvasGC.lineWidth = 1;\n        // Save the buffer gc before wrapping.\n        this._bufferGC.save();\n        // Wrap the buffer gc for painting the cells.\n        let gc = new GraphicsContext(this._bufferGC);\n        for (const group of cellGroups) {\n            let width = 0;\n            for (let c = group.c1; c <= group.c2; c++) {\n                width += this._getColumnSize(rgn.region, c);\n            }\n            let height = 0;\n            for (let r = group.r1; r <= group.r2; r++) {\n                height += this._getRowSize(rgn.region, r);\n            }\n            let value = DataGrid._getCellValue(this.dataModel, rgn.region, group.r1, group.c1);\n            let metadata = DataGrid._getCellMetadata(this.dataModel, rgn.region, group.r1, group.c2);\n            let x = 0;\n            let y = 0;\n            switch (rgn.region) {\n                case 'body':\n                    x =\n                        this._columnSections.offsetOf(group.c1) +\n                            this.headerWidth -\n                            this._scrollX;\n                    y =\n                        this._rowSections.offsetOf(group.r1) +\n                            this.headerHeight -\n                            this._scrollY;\n                    break;\n                case 'column-header':\n                    x =\n                        this._columnSections.offsetOf(group.c1) +\n                            this.headerWidth -\n                            this._scrollX;\n                    y = this._rowSections.offsetOf(group.r1);\n                    break;\n                case 'row-header':\n                    x = this._columnSections.offsetOf(group.c1);\n                    y =\n                        this._rowSections.offsetOf(group.r1) +\n                            this.headerHeight -\n                            this._scrollY;\n                    break;\n                case 'corner-header':\n                    x = this._columnSections.offsetOf(group.c1);\n                    y = this._rowSections.offsetOf(group.r1);\n                    break;\n            }\n            config.x = x;\n            config.y = y;\n            config.width = width;\n            config.height = height;\n            config.region = rgn.region;\n            config.row = group.r1;\n            config.column = group.c1;\n            config.value = value;\n            config.metadata = metadata;\n            // Compute the actual X bounds for the cell.\n            const x1 = Math.max(rgn.xMin, x);\n            const x2 = Math.min(x + width - 2, rgn.xMax);\n            // Compute the actual Y bounds for the cell.\n            const y1 = Math.max(rgn.yMin, y);\n            const y2 = Math.min(y + height - 2, rgn.yMax);\n            if (x2 <= x1 || y2 <= y1) {\n                continue;\n            }\n            // Draw the background.\n            if (backgroundColor) {\n                this._canvasGC.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n            }\n            // Get the renderer for the cell.\n            let renderer = this._cellRenderers.get(config);\n            // Clear the buffer rect for the cell.\n            gc.clearRect(config.x, config.y, width, height);\n            // Save the GC state.\n            gc.save();\n            // Paint the cell into the off-screen buffer.\n            try {\n                if (renderer instanceof AsyncCellRenderer) {\n                    if (renderer.isReady(config)) {\n                        renderer.paint(gc, config);\n                    }\n                    else {\n                        renderer.paintPlaceholder(gc, config);\n                        const r1 = group.r1;\n                        const r2 = group.r2;\n                        const c1 = group.c1;\n                        const c2 = group.c2;\n                        renderer.load(config).then(() => {\n                            this.repaintRegion(rgn.region, r1, c1, r2, c2);\n                        });\n                    }\n                }\n                else {\n                    renderer.paint(gc, config);\n                }\n            }\n            catch (err) {\n                console.error(err);\n            }\n            // Restore the GC state.\n            gc.restore();\n            this._blitContent(this._buffer, x1, y1, x2 - x1 + 1, y2 - y1 + 1, x1, y1);\n        }\n        // Dispose of the wrapped gc.\n        gc.dispose();\n        // Restore the final buffer gc state.\n        this._bufferGC.restore();\n    }\n    /**\n     * Draw the horizontal grid lines for the given paint region.\n     */\n    _drawHorizontalGridLines(rgn, color) {\n        // Bail if there is no color to draw.\n        if (!color) {\n            return;\n        }\n        // Compute the X bounds for the horizontal lines.\n        const x1 = Math.max(rgn.xMin, rgn.x);\n        const x2 = Math.min(rgn.x + rgn.width, rgn.xMax + 1);\n        // Begin the path for the grid lines.\n        this._canvasGC.beginPath();\n        // Set the line width for the grid lines.\n        this._canvasGC.lineWidth = 1;\n        // Fetch the geometry.\n        const bh = this.bodyHeight;\n        const ph = this.pageHeight;\n        // Fetch the number of grid lines to be drawn.\n        let n = rgn.rowSizes.length;\n        // Adjust the count down if the last line shouldn't be drawn.\n        if (this._stretchLastRow && ph > bh) {\n            if (rgn.row + n === this._rowSections.count) {\n                n -= 1;\n            }\n        }\n        // Draw the horizontal grid lines.\n        for (let y = rgn.y, j = 0; j < n; ++j) {\n            // Fetch the size of the row.\n            let size = rgn.rowSizes[j];\n            // Skip zero sized rows.\n            if (size === 0) {\n                continue;\n            }\n            // Compute the Y position of the line.\n            let pos = y + size - 1;\n            // Draw the line if it's in range of the dirty rect.\n            if (pos >= rgn.yMin && pos <= rgn.yMax) {\n                this._canvasGC.moveTo(x1, pos + 0.5);\n                this._canvasGC.lineTo(x2, pos + 0.5);\n            }\n            // Increment the running Y coordinate.\n            y += size;\n        }\n        // Stroke the lines with the specified color.\n        this._canvasGC.strokeStyle = color;\n        this._canvasGC.stroke();\n    }\n    /**\n     * Draw the vertical grid lines for the given paint region.\n     */\n    _drawVerticalGridLines(rgn, color) {\n        // Bail if there is no color to draw.\n        if (!color) {\n            return;\n        }\n        // Compute the Y bounds for the vertical lines.\n        const y1 = Math.max(rgn.yMin, rgn.y);\n        const y2 = Math.min(rgn.y + rgn.height, rgn.yMax + 1);\n        // Begin the path for the grid lines\n        this._canvasGC.beginPath();\n        // Set the line width for the grid lines.\n        this._canvasGC.lineWidth = 1;\n        // Fetch the geometry.\n        const bw = this.bodyWidth;\n        const pw = this.pageWidth;\n        // Fetch the number of grid lines to be drawn.\n        let n = rgn.columnSizes.length;\n        // Adjust the count down if the last line shouldn't be drawn.\n        if (this._stretchLastColumn && pw > bw) {\n            if (rgn.column + n === this._columnSections.count) {\n                n -= 1;\n            }\n        }\n        // Draw the vertical grid lines.\n        for (let x = rgn.x, i = 0; i < n; ++i) {\n            // Fetch the size of the column.\n            let size = rgn.columnSizes[i];\n            // Skip zero sized columns.\n            if (size === 0) {\n                continue;\n            }\n            // Compute the X position of the line.\n            let pos = x + size - 1;\n            // Draw the line if it's in range of the dirty rect.\n            if (pos >= rgn.xMin && pos <= rgn.xMax) {\n                this._canvasGC.moveTo(pos + 0.5, y1);\n                this._canvasGC.lineTo(pos + 0.5, y2);\n            }\n            // Increment the running X coordinate.\n            x += size;\n        }\n        // Stroke the lines with the specified color.\n        this._canvasGC.strokeStyle = color;\n        this._canvasGC.stroke();\n    }\n    /**\n     * Draw the body selections for the data grid.\n     */\n    _drawBodySelections() {\n        // Fetch the selection model.\n        let model = this._selectionModel;\n        // Bail early if there are no selections.\n        if (!model || model.isEmpty) {\n            return;\n        }\n        // Fetch the selection colors.\n        let fill = this._style.selectionFillColor;\n        let stroke = this._style.selectionBorderColor;\n        // Bail early if there is nothing to draw.\n        if (!fill && !stroke) {\n            return;\n        }\n        // Fetch the scroll geometry.\n        let sx = this._scrollX;\n        let sy = this._scrollY;\n        // Get the first visible cell of the grid.\n        let r1 = this._rowSections.indexOf(sy);\n        let c1 = this._columnSections.indexOf(sx);\n        // Bail early if there are no visible cells.\n        if (r1 < 0 || c1 < 0) {\n            return;\n        }\n        // Fetch the extra geometry.\n        let bw = this.bodyWidth;\n        let bh = this.bodyHeight;\n        let pw = this.pageWidth;\n        let ph = this.pageHeight;\n        let hw = this.headerWidth;\n        let hh = this.headerHeight;\n        // Get the last visible cell of the grid.\n        let r2 = this._rowSections.indexOf(sy + ph);\n        let c2 = this._columnSections.indexOf(sx + pw);\n        // Fetch the max row and column.\n        let maxRow = this._rowSections.count - 1;\n        let maxColumn = this._columnSections.count - 1;\n        // Clamp the last cell if the void space is visible.\n        r2 = r2 < 0 ? maxRow : r2;\n        c2 = c2 < 0 ? maxColumn : c2;\n        // Fetch the overlay gc.\n        let gc = this._overlayGC;\n        // Save the gc state.\n        gc.save();\n        // Set up the body clipping rect.\n        gc.beginPath();\n        gc.rect(hw, hh, pw, ph);\n        gc.clip();\n        // Set up the gc style.\n        if (fill) {\n            gc.fillStyle = fill;\n        }\n        if (stroke) {\n            gc.strokeStyle = stroke;\n            gc.lineWidth = 1;\n        }\n        // Iterate over the selections.\n        for (let s of model.selections()) {\n            // Skip the section if it's not visible.\n            if (s.r1 < r1 && s.r2 < r1) {\n                continue;\n            }\n            if (s.r1 > r2 && s.r2 > r2) {\n                continue;\n            }\n            if (s.c1 < c1 && s.c2 < c1) {\n                continue;\n            }\n            if (s.c1 > c2 && s.c2 > c2) {\n                continue;\n            }\n            // Clamp the cell to the model bounds.\n            let sr1 = Math.max(0, Math.min(s.r1, maxRow));\n            let sc1 = Math.max(0, Math.min(s.c1, maxColumn));\n            let sr2 = Math.max(0, Math.min(s.r2, maxRow));\n            let sc2 = Math.max(0, Math.min(s.c2, maxColumn));\n            // Swap index order if needed.\n            let tmp;\n            if (sr1 > sr2) {\n                tmp = sr1;\n                sr1 = sr2;\n                sr2 = tmp;\n            }\n            if (sc1 > sc2) {\n                tmp = sc1;\n                sc1 = sc2;\n                sc2 = tmp;\n            }\n            const joinedGroup = CellGroup.joinCellGroupWithMergedCellGroups(this.dataModel, { r1: sr1, r2: sr2, c1: sc1, c2: sc2 }, 'body');\n            sr1 = joinedGroup.r1;\n            sr2 = joinedGroup.r2;\n            sc1 = joinedGroup.c1;\n            sc2 = joinedGroup.c2;\n            // Convert to pixel coordinates.\n            let x1 = this._columnSections.offsetOf(sc1) - sx + hw;\n            let y1 = this._rowSections.offsetOf(sr1) - sy + hh;\n            let x2 = this._columnSections.extentOf(sc2) - sx + hw;\n            let y2 = this._rowSections.extentOf(sr2) - sy + hh;\n            // Adjust the trailing X coordinate for column stretch.\n            if (this._stretchLastColumn && pw > bw && sc2 === maxColumn) {\n                x2 = hw + pw - 1;\n            }\n            // Adjust the trailing Y coordinate for row stretch.\n            if (this._stretchLastRow && ph > bh && sr2 === maxRow) {\n                y2 = hh + ph - 1;\n            }\n            // Clamp the bounds to just outside of the clipping rect.\n            x1 = Math.max(hw - 1, x1);\n            y1 = Math.max(hh - 1, y1);\n            x2 = Math.min(hw + pw + 1, x2);\n            y2 = Math.min(hh + ph + 1, y2);\n            // Skip zero sized ranges.\n            if (x2 < x1 || y2 < y1) {\n                continue;\n            }\n            // Fill the rect if needed.\n            if (fill) {\n                gc.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n            }\n            // Stroke the rect if needed.\n            if (stroke) {\n                gc.strokeRect(x1 - 0.5, y1 - 0.5, x2 - x1 + 1, y2 - y1 + 1);\n            }\n        }\n        // Restore the gc state.\n        gc.restore();\n    }\n    /**\n     * Draw the row header selections for the data grid.\n     */\n    _drawRowHeaderSelections() {\n        // Fetch the selection model.\n        let model = this._selectionModel;\n        // Bail early if there are no selections or if the selectionMode is the entire column.\n        if (!model || model.isEmpty || model.selectionMode == 'column') {\n            return;\n        }\n        // Bail early if the row headers are not visible.\n        if (this.headerWidth === 0 || this.pageHeight === 0) {\n            return;\n        }\n        // Fetch the selection colors.\n        let fill = this._style.headerSelectionFillColor;\n        let stroke = this._style.headerSelectionBorderColor;\n        // Bail early if there is nothing to draw.\n        if (!fill && !stroke) {\n            return;\n        }\n        // Fetch common geometry.\n        let sy = this._scrollY;\n        let bh = this.bodyHeight;\n        let ph = this.pageHeight;\n        let hw = this.headerWidth;\n        let hh = this.headerHeight;\n        let rs = this._rowSections;\n        // Fetch the overlay gc.\n        let gc = this._overlayGC;\n        // Save the gc state.\n        gc.save();\n        // Set up the header clipping rect.\n        gc.beginPath();\n        gc.rect(0, hh, hw, ph);\n        gc.clip();\n        // Set up the gc style.\n        if (fill) {\n            gc.fillStyle = fill;\n        }\n        if (stroke) {\n            gc.strokeStyle = stroke;\n            gc.lineWidth = 1;\n        }\n        // Fetch the max row.\n        let maxRow = rs.count - 1;\n        // Fetch the visible rows.\n        let r1 = rs.indexOf(sy);\n        let r2 = rs.indexOf(sy + ph - 1);\n        r2 = r2 < 0 ? maxRow : r2;\n        // Iterate over the visible rows.\n        for (let j = r1; j <= r2; ++j) {\n            // Skip rows which aren't selected.\n            if (!model.isRowSelected(j)) {\n                continue;\n            }\n            // Get the dimensions of the row.\n            let y = rs.offsetOf(j) - sy + hh;\n            let h = rs.sizeOf(j);\n            // Adjust the height for row stretch.\n            if (this._stretchLastRow && ph > bh && j === maxRow) {\n                h = hh + ph - y;\n            }\n            // Skip zero sized rows.\n            if (h === 0) {\n                continue;\n            }\n            // Fill the rect if needed.\n            if (fill) {\n                gc.fillRect(0, y, hw, h);\n            }\n            // Draw the border if needed.\n            if (stroke) {\n                gc.beginPath();\n                gc.moveTo(hw - 0.5, y - 1);\n                gc.lineTo(hw - 0.5, y + h);\n                gc.stroke();\n            }\n        }\n        // Restore the gc state.\n        gc.restore();\n    }\n    /**\n     * Draw the column header selections for the data grid.\n     */\n    _drawColumnHeaderSelections() {\n        // Fetch the selection model.\n        let model = this._selectionModel;\n        // Bail early if there are no selections or if the selectionMode is the entire row\n        if (!model || model.isEmpty || model.selectionMode == 'row') {\n            return;\n        }\n        // Bail early if the column headers are not visible.\n        if (this.headerHeight === 0 || this.pageWidth === 0) {\n            return;\n        }\n        // Fetch the selection colors.\n        let fill = this._style.headerSelectionFillColor;\n        let stroke = this._style.headerSelectionBorderColor;\n        // Bail early if there is nothing to draw.\n        if (!fill && !stroke) {\n            return;\n        }\n        // Fetch common geometry.\n        let sx = this._scrollX;\n        let bw = this.bodyWidth;\n        let pw = this.pageWidth;\n        let hw = this.headerWidth;\n        let hh = this.headerHeight;\n        let cs = this._columnSections;\n        // Fetch the overlay gc.\n        let gc = this._overlayGC;\n        // Save the gc state.\n        gc.save();\n        // Set up the header clipping rect.\n        gc.beginPath();\n        gc.rect(hw, 0, pw, hh);\n        gc.clip();\n        // Set up the gc style.\n        if (fill) {\n            gc.fillStyle = fill;\n        }\n        if (stroke) {\n            gc.strokeStyle = stroke;\n            gc.lineWidth = 1;\n        }\n        // Fetch the max column.\n        let maxCol = cs.count - 1;\n        // Fetch the visible columns.\n        let c1 = cs.indexOf(sx);\n        let c2 = cs.indexOf(sx + pw - 1);\n        c2 = c2 < 0 ? maxCol : c2;\n        // Iterate over the visible columns.\n        for (let i = c1; i <= c2; ++i) {\n            // Skip columns which aren't selected.\n            if (!model.isColumnSelected(i)) {\n                continue;\n            }\n            // Get the dimensions of the column.\n            let x = cs.offsetOf(i) - sx + hw;\n            let w = cs.sizeOf(i);\n            // Adjust the width for column stretch.\n            if (this._stretchLastColumn && pw > bw && i === maxCol) {\n                w = hw + pw - x;\n            }\n            // Skip zero sized columns.\n            if (w === 0) {\n                continue;\n            }\n            // Fill the rect if needed.\n            if (fill) {\n                gc.fillRect(x, 0, w, hh);\n            }\n            // Draw the border if needed.\n            if (stroke) {\n                gc.beginPath();\n                gc.moveTo(x - 1, hh - 0.5);\n                gc.lineTo(x + w, hh - 0.5);\n                gc.stroke();\n            }\n        }\n        // Restore the gc state.\n        gc.restore();\n    }\n    /**\n     * Draw the overlay cursor for the data grid.\n     */\n    _drawCursor() {\n        // Fetch the selection model.\n        let model = this._selectionModel;\n        // Bail early if there is no cursor.\n        if (!model || model.isEmpty || model.selectionMode !== 'cell') {\n            return;\n        }\n        // Extract the style information.\n        let fill = this._style.cursorFillColor;\n        let stroke = this._style.cursorBorderColor;\n        // Bail early if there is nothing to draw.\n        if (!fill && !stroke) {\n            return;\n        }\n        // Fetch the cursor location.\n        let startRow = model.cursorRow;\n        let startColumn = model.cursorColumn;\n        // Fetch the max row and column.\n        let maxRow = this._rowSections.count - 1;\n        let maxColumn = this._columnSections.count - 1;\n        // Bail early if the cursor is out of bounds.\n        if (startRow < 0 || startRow > maxRow) {\n            return;\n        }\n        if (startColumn < 0 || startColumn > maxColumn) {\n            return;\n        }\n        let endRow = startRow;\n        let endColumn = startColumn;\n        const joinedGroup = CellGroup.joinCellGroupWithMergedCellGroups(this.dataModel, { r1: startRow, r2: endRow, c1: startColumn, c2: endColumn }, 'body');\n        startRow = joinedGroup.r1;\n        endRow = joinedGroup.r2;\n        startColumn = joinedGroup.c1;\n        endColumn = joinedGroup.c2;\n        // Fetch geometry.\n        let sx = this._scrollX;\n        let sy = this._scrollY;\n        let bw = this.bodyWidth;\n        let bh = this.bodyHeight;\n        let pw = this.pageWidth;\n        let ph = this.pageHeight;\n        let hw = this.headerWidth;\n        let hh = this.headerHeight;\n        let vw = this._viewportWidth;\n        let vh = this._viewportHeight;\n        // Get the cursor bounds in viewport coordinates.\n        let x1 = this._columnSections.offsetOf(startColumn) - sx + hw;\n        let x2 = this._columnSections.extentOf(endColumn) - sx + hw;\n        let y1 = this._rowSections.offsetOf(startRow) - sy + hh;\n        let y2 = this._rowSections.extentOf(endRow) - sy + hh;\n        // Adjust the trailing X coordinate for column stretch.\n        if (this._stretchLastColumn && pw > bw && startColumn === maxColumn) {\n            x2 = vw - 1;\n        }\n        // Adjust the trailing Y coordinate for row stretch.\n        if (this._stretchLastRow && ph > bh && startRow === maxRow) {\n            y2 = vh - 1;\n        }\n        // Skip zero sized cursors.\n        if (x2 < x1 || y2 < y1) {\n            return;\n        }\n        // Bail early if the cursor is off the screen.\n        if (x1 - 1 >= vw || y1 - 1 >= vh || x2 + 1 < hw || y2 + 1 < hh) {\n            return;\n        }\n        // Fetch the overlay gc.\n        let gc = this._overlayGC;\n        // Save the gc state.\n        gc.save();\n        // Set up the body clipping rect.\n        gc.beginPath();\n        gc.rect(hw, hh, pw, ph);\n        gc.clip();\n        // Clear any existing overlay content.\n        gc.clearRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n        // Fill the cursor rect if needed.\n        if (fill) {\n            // Set up the fill style.\n            gc.fillStyle = fill;\n            // Fill the cursor rect.\n            gc.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n        }\n        // Stroke the cursor border if needed.\n        if (stroke) {\n            // Set up the stroke style.\n            gc.strokeStyle = stroke;\n            gc.lineWidth = 2;\n            // Stroke the cursor rect.\n            gc.strokeRect(x1, y1, x2 - x1, y2 - y1);\n        }\n        // Restore the gc state.\n        gc.restore();\n    }\n    /**\n     * Draw the overlay shadows for the data grid.\n     */\n    _drawShadows() {\n        // Fetch the scroll shadow from the style.\n        let shadow = this._style.scrollShadow;\n        // Bail early if there is no shadow to draw.\n        if (!shadow) {\n            return;\n        }\n        // Fetch the scroll position.\n        let sx = this._scrollX;\n        let sy = this._scrollY;\n        // Fetch maximum scroll position.\n        let sxMax = this.maxScrollX;\n        let syMax = this.maxScrollY;\n        // Fetch the header width and height.\n        let hw = this.headerWidth;\n        let hh = this.headerHeight;\n        // Fetch the page width and height.\n        let pw = this.pageWidth;\n        let ph = this.pageHeight;\n        // Fetch the viewport width and height.\n        let vw = this._viewportWidth;\n        let vh = this._viewportHeight;\n        // Fetch the body width and height.\n        let bw = this.bodyWidth;\n        let bh = this.bodyHeight;\n        // Adjust the body size for row and column stretch.\n        if (this._stretchLastRow && ph > bh) {\n            bh = ph;\n        }\n        if (this._stretchLastColumn && pw > bw) {\n            bw = pw;\n        }\n        // Fetch the gc object.\n        let gc = this._overlayGC;\n        // Save the gc state.\n        gc.save();\n        // Draw the column header shadow if needed.\n        if (sy > 0) {\n            // Set up the gradient coordinates.\n            let x0 = 0;\n            let y0 = hh;\n            let x1 = 0;\n            let y1 = y0 + shadow.size;\n            // Create the gradient object.\n            let grad = gc.createLinearGradient(x0, y0, x1, y1);\n            // Set the gradient stops.\n            grad.addColorStop(0, shadow.color1);\n            grad.addColorStop(0.5, shadow.color2);\n            grad.addColorStop(1, shadow.color3);\n            // Set up the rect coordinates.\n            let x = 0;\n            let y = hh;\n            let w = hw + Math.min(pw, bw - sx);\n            let h = shadow.size;\n            // Fill the shadow rect with the fill style.\n            gc.fillStyle = grad;\n            gc.fillRect(x, y, w, h);\n        }\n        // Draw the row header shadow if needed.\n        if (sx > 0) {\n            // Set up the gradient coordinates.\n            let x0 = hw;\n            let y0 = 0;\n            let x1 = x0 + shadow.size;\n            let y1 = 0;\n            // Create the gradient object.\n            let grad = gc.createLinearGradient(x0, y0, x1, y1);\n            // Set the gradient stops.\n            grad.addColorStop(0, shadow.color1);\n            grad.addColorStop(0.5, shadow.color2);\n            grad.addColorStop(1, shadow.color3);\n            // Set up the rect coordinates.\n            let x = hw;\n            let y = 0;\n            let w = shadow.size;\n            let h = hh + Math.min(ph, bh - sy);\n            // Fill the shadow rect with the fill style.\n            gc.fillStyle = grad;\n            gc.fillRect(x, y, w, h);\n        }\n        // Draw the column footer shadow if needed.\n        if (sy < syMax) {\n            // Set up the gradient coordinates.\n            let x0 = 0;\n            let y0 = vh;\n            let x1 = 0;\n            let y1 = vh - shadow.size;\n            // Create the gradient object.\n            let grad = gc.createLinearGradient(x0, y0, x1, y1);\n            // Set the gradient stops.\n            grad.addColorStop(0, shadow.color1);\n            grad.addColorStop(0.5, shadow.color2);\n            grad.addColorStop(1, shadow.color3);\n            // Set up the rect coordinates.\n            let x = 0;\n            let y = vh - shadow.size;\n            let w = hw + Math.min(pw, bw - sx);\n            let h = shadow.size;\n            // Fill the shadow rect with the fill style.\n            gc.fillStyle = grad;\n            gc.fillRect(x, y, w, h);\n        }\n        // Draw the row footer shadow if needed.\n        if (sx < sxMax) {\n            // Set up the gradient coordinates.\n            let x0 = vw;\n            let y0 = 0;\n            let x1 = vw - shadow.size;\n            let y1 = 0;\n            // Create the gradient object.\n            let grad = gc.createLinearGradient(x0, y0, x1, y1);\n            // Set the gradient stops.\n            grad.addColorStop(0, shadow.color1);\n            grad.addColorStop(0.5, shadow.color2);\n            grad.addColorStop(1, shadow.color3);\n            // Set up the rect coordinates.\n            let x = vw - shadow.size;\n            let y = 0;\n            let w = shadow.size;\n            let h = hh + Math.min(ph, bh - sy);\n            // Fill the shadow rect with the fill style.\n            gc.fillStyle = grad;\n            gc.fillRect(x, y, w, h);\n        }\n        // Restore the gc state.\n        gc.restore();\n    }\n}\n/**\n * The namespace for the `DataGrid` class statics.\n */\n(function (DataGrid) {\n    /**\n     * A generic format function for the copy handler.\n     *\n     * @param args - The format args for the function.\n     *\n     * @returns The string representation of the value.\n     *\n     * #### Notes\n     * This function uses `String()` to coerce a value to a string.\n     */\n    function copyFormatGeneric(args) {\n        if (args.value === null || args.value === undefined) {\n            return '';\n        }\n        return String(args.value);\n    }\n    DataGrid.copyFormatGeneric = copyFormatGeneric;\n    /**\n     * The default theme for a data grid.\n     */\n    DataGrid.defaultStyle = {\n        voidColor: '#F3F3F3',\n        backgroundColor: '#FFFFFF',\n        gridLineColor: 'rgba(20, 20, 20, 0.15)',\n        headerBackgroundColor: '#F3F3F3',\n        headerGridLineColor: 'rgba(20, 20, 20, 0.25)',\n        selectionFillColor: 'rgba(49, 119, 229, 0.2)',\n        selectionBorderColor: 'rgba(0, 107, 247, 1.0)',\n        cursorBorderColor: 'rgba(0, 107, 247, 1.0)',\n        headerSelectionFillColor: 'rgba(20, 20, 20, 0.1)',\n        headerSelectionBorderColor: 'rgba(0, 107, 247, 1.0)',\n        scrollShadow: {\n            size: 10,\n            color1: 'rgba(0, 0, 0, 0.20)',\n            color2: 'rgba(0, 0, 0, 0.05)',\n            color3: 'rgba(0, 0, 0, 0.00)'\n        }\n    };\n    /**\n     * The default sizes for a data grid.\n     */\n    DataGrid.defaultSizes = {\n        rowHeight: 20,\n        columnWidth: 64,\n        rowHeaderWidth: 64,\n        columnHeaderHeight: 20\n    };\n    /**\n     * The default minimum sizes for a data grid.\n     */\n    DataGrid.minimumSizes = {\n        rowHeight: 20,\n        columnWidth: 10,\n        rowHeaderWidth: 10,\n        columnHeaderHeight: 20\n    };\n    /**\n     * The default copy config for a data grid.\n     */\n    DataGrid.defaultCopyConfig = {\n        separator: '\\t',\n        format: copyFormatGeneric,\n        headers: 'none',\n        warningThreshold: 1e6\n    };\n})(DataGrid || (DataGrid = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$1;\n(function (Private) {\n    /**\n     * A singleton `scroll-request` conflatable message.\n     */\n    Private.ScrollRequest = new ConflatableMessage('scroll-request');\n    /**\n     * A singleton `overlay-paint-request` conflatable message.\n     */\n    Private.OverlayPaintRequest = new ConflatableMessage('overlay-paint-request');\n    /**\n     * Create a new zero-sized canvas element.\n     */\n    function createCanvas() {\n        let canvas = document.createElement('canvas');\n        canvas.width = 0;\n        canvas.height = 0;\n        return canvas;\n    }\n    Private.createCanvas = createCanvas;\n    /**\n     * Checks whether a given regions has merged cells in it.\n     * @param dataModel grid's data model.\n     * @param region the paint region to be checked.\n     * @returns boolean.\n     */\n    function regionHasMergedCells(dataModel, region) {\n        const regionGroups = CellGroup.getCellGroupsAtRegion(dataModel, region);\n        return regionGroups.length > 0;\n    }\n    Private.regionHasMergedCells = regionHasMergedCells;\n    /**\n     * A conflatable message which merges dirty paint regions.\n     */\n    class PaintRequest extends ConflatableMessage {\n        /**\n         * Construct a new paint request messages.\n         *\n         * @param region - The cell region for the paint.\n         *\n         * @param r1 - The top-left row of the dirty region.\n         *\n         * @param c1 - The top-left column of the dirty region.\n         *\n         * @param r2 - The bottom-right row of the dirty region.\n         *\n         * @param c2 - The bottom-right column of the dirty region.\n         */\n        constructor(region, r1, c1, r2, c2) {\n            super('paint-request');\n            this._region = region;\n            this._r1 = r1;\n            this._c1 = c1;\n            this._r2 = r2;\n            this._c2 = c2;\n        }\n        /**\n         * The cell region for the paint.\n         */\n        get region() {\n            return this._region;\n        }\n        /**\n         * The top-left row of the dirty region.\n         */\n        get r1() {\n            return this._r1;\n        }\n        /**\n         * The top-left column of the dirty region.\n         */\n        get c1() {\n            return this._c1;\n        }\n        /**\n         * The bottom-right row of the dirty region.\n         */\n        get r2() {\n            return this._r2;\n        }\n        /**\n         * The bottom-right column of the dirty region.\n         */\n        get c2() {\n            return this._c2;\n        }\n        /**\n         * Conflate this message with another paint request.\n         */\n        conflate(other) {\n            // Bail early if the request is already painting everything.\n            if (this._region === 'all') {\n                return true;\n            }\n            // Any region can conflate with the `'all'` region.\n            if (other._region === 'all') {\n                this._region = 'all';\n                return true;\n            }\n            // Otherwise, do not conflate with a different region.\n            if (this._region !== other._region) {\n                return false;\n            }\n            // Conflate the region to the total boundary.\n            this._r1 = Math.min(this._r1, other._r1);\n            this._c1 = Math.min(this._c1, other._c1);\n            this._r2 = Math.max(this._r2, other._r2);\n            this._c2 = Math.max(this._c2, other._c2);\n            return true;\n        }\n    }\n    Private.PaintRequest = PaintRequest;\n    /**\n     * A conflatable message for resizing rows.\n     */\n    class RowResizeRequest extends ConflatableMessage {\n        /**\n         * Construct a new row resize request.\n         *\n         * @param region - The row region which holds the section.\n         *\n         * @param index - The index of row in the region.\n         *\n         * @param size - The target size of the section.\n         */\n        constructor(region, index, size) {\n            super('row-resize-request');\n            this._region = region;\n            this._index = index;\n            this._size = size;\n        }\n        /**\n         * The row region which holds the section.\n         */\n        get region() {\n            return this._region;\n        }\n        /**\n         * The index of the row in the region.\n         */\n        get index() {\n            return this._index;\n        }\n        /**\n         * The target size of the section.\n         */\n        get size() {\n            return this._size;\n        }\n        /**\n         * Conflate this message with another row resize request.\n         */\n        conflate(other) {\n            if (this._region !== other._region || this._index !== other._index) {\n                return false;\n            }\n            this._size = other._size;\n            return true;\n        }\n    }\n    Private.RowResizeRequest = RowResizeRequest;\n    /**\n     * A conflatable message for resizing columns.\n     */\n    class ColumnResizeRequest extends ConflatableMessage {\n        /**\n         * Construct a new column resize request.\n         *\n         * @param region - The column region which holds the section.\n         *\n         * @param index - The index of column in the region.\n         *\n         * @param size - The target size of the section.\n         *               If null, then infer the size to fit.\n         */\n        constructor(region, index, size) {\n            super('column-resize-request');\n            this._region = region;\n            this._index = index;\n            this._size = size;\n        }\n        /**\n         * The column region which holds the section.\n         */\n        get region() {\n            return this._region;\n        }\n        /**\n         * The index of the column in the region.\n         */\n        get index() {\n            return this._index;\n        }\n        /**\n         * The target size of the section.\n         */\n        get size() {\n            return this._size;\n        }\n        /**\n         * Conflate this message with another column resize request.\n         */\n        conflate(other) {\n            if (this._region !== other._region || this._index !== other._index) {\n                return false;\n            }\n            this._size = other._size;\n            return true;\n        }\n    }\n    Private.ColumnResizeRequest = ColumnResizeRequest;\n})(Private$1 || (Private$1 = {}));\n\n/**\n * A data model implementation for in-memory JSON data.\n */\nclass JSONModel extends DataModel {\n    /**\n     * Create a data model with static JSON data.\n     *\n     * @param options - The options for initializing the data model.\n     */\n    constructor(options) {\n        super();\n        let split = Private.splitFields(options.schema);\n        this._data = options.data;\n        this._bodyFields = split.bodyFields;\n        this._headerFields = split.headerFields;\n        this._missingValues = Private.createMissingMap(options.schema);\n    }\n    /**\n     * Get the row count for a region in the data model.\n     *\n     * @param region - The row region of interest.\n     *\n     * @returns - The row count for the region.\n     */\n    rowCount(region) {\n        if (region === 'body') {\n            return this._data.length;\n        }\n        return 1; // TODO multiple column-header rows?\n    }\n    /**\n     * Get the column count for a region in the data model.\n     *\n     * @param region - The column region of interest.\n     *\n     * @returns - The column count for the region.\n     */\n    columnCount(region) {\n        if (region === 'body') {\n            return this._bodyFields.length;\n        }\n        return this._headerFields.length;\n    }\n    /**\n     * Get the data value for a cell in the data model.\n     *\n     * @param region - The cell region of interest.\n     *\n     * @param row - The row index of the cell of interest.\n     *\n     * @param column - The column index of the cell of interest.\n     *\n     * @returns - The data value for the specified cell.\n     *\n     * #### Notes\n     * A `missingValue` as defined by the schema is converted to `null`.\n     */\n    data(region, row, column) {\n        // Set up the field and value variables.\n        let field;\n        let value;\n        // Look up the field and value for the region.\n        switch (region) {\n            case 'body':\n                field = this._bodyFields[column];\n                value = this._data[row][field.name];\n                break;\n            case 'column-header':\n                field = this._bodyFields[column];\n                value = field.title || field.name;\n                break;\n            case 'row-header':\n                field = this._headerFields[column];\n                value = this._data[row][field.name];\n                break;\n            case 'corner-header':\n                field = this._headerFields[column];\n                value = field.title || field.name;\n                break;\n            default:\n                throw 'unreachable';\n        }\n        // Test whether the value is a missing value.\n        let missing = this._missingValues !== null &&\n            typeof value === 'string' &&\n            this._missingValues[value] === true;\n        // Return the final value.\n        return missing ? null : value;\n    }\n    /**\n     * Get the metadata for a cell in the data model.\n     *\n     * @param region - The cell region of interest.\n     *\n     * @param row - The row index of the cell of of interest.\n     *\n     * @param column - The column index of the cell of interest.\n     *\n     * @returns The metadata for the cell.\n     */\n    metadata(region, row, column) {\n        if (region === 'body' || region === 'column-header') {\n            return this._bodyFields[column];\n        }\n        return this._headerFields[column];\n    }\n}\n/**\n * The namespace for the module implementation details.\n */\nvar Private;\n(function (Private) {\n    /**\n     * Split the schema fields into header and body fields.\n     */\n    function splitFields(schema) {\n        // Normalize the primary keys.\n        let primaryKeys;\n        if (schema.primaryKey === undefined) {\n            primaryKeys = [];\n        }\n        else if (typeof schema.primaryKey === 'string') {\n            primaryKeys = [schema.primaryKey];\n        }\n        else {\n            primaryKeys = schema.primaryKey;\n        }\n        // Separate the fields for the body and header.\n        let bodyFields = [];\n        let headerFields = [];\n        for (let field of schema.fields) {\n            if (primaryKeys.indexOf(field.name) === -1) {\n                bodyFields.push(field);\n            }\n            else {\n                headerFields.push(field);\n            }\n        }\n        // Return the separated fields.\n        return { bodyFields, headerFields };\n    }\n    Private.splitFields = splitFields;\n    /**\n     * Create a missing values map for a schema.\n     *\n     * This returns `null` if there are no missing values.\n     */\n    function createMissingMap(schema) {\n        // Bail early if there are no missing values.\n        if (!schema.missingValues || schema.missingValues.length === 0) {\n            return null;\n        }\n        // Collect the missing values into a map.\n        let result = Object.create(null);\n        for (let value of schema.missingValues) {\n            result[value] = true;\n        }\n        // Return the populated map.\n        return result;\n    }\n    Private.createMissingMap = createMissingMap;\n})(Private || (Private = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2023, Lumino Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nconst PERCENTAGE_REGEX = /^(\\d+(\\.\\d+)?)%$/;\nconst PIXEL_REGEX = /^(\\d+(\\.\\d+)?)px$/;\n/**\n * A cell renderer which renders data values as images.\n */\nclass ImageRenderer extends AsyncCellRenderer {\n    /**\n     * Construct a new text renderer.\n     *\n     * @param options - The options for initializing the renderer.\n     */\n    constructor(options = {}) {\n        super();\n        this.backgroundColor = options.backgroundColor || '';\n        this.textColor = options.textColor || '#000000';\n        this.placeholder = options.placeholder || '...';\n        this.width = options.width || '';\n        // Not using the || operator, because the empty string '' is a valid value\n        this.height = options.height === undefined ? '100%' : options.height;\n    }\n    /**\n     * Whether the renderer is ready or not for that specific config.\n     * If it's not ready, the datagrid will paint the placeholder.\n     * If it's ready, the datagrid will paint the image synchronously.\n     *\n     * @param config - The configuration data for the cell.\n     *\n     * @returns Whether the renderer is ready for this config or not.\n     */\n    isReady(config) {\n        return (!config.value || ImageRenderer.dataCache.get(config.value) !== undefined);\n    }\n    /**\n     * Load the image asynchronously for a specific config.\n     *\n     * @param config - The configuration data for the cell.\n     */\n    async load(config) {\n        // Bail early if there is nothing to do\n        if (!config.value) {\n            return;\n        }\n        const value = config.value;\n        const loadedPromise = new PromiseDelegate();\n        ImageRenderer.dataCache.set(value, undefined);\n        const img = new Image();\n        img.onload = () => {\n            ImageRenderer.dataCache.set(value, img);\n            loadedPromise.resolve();\n        };\n        img.src = value;\n        return loadedPromise.promise;\n    }\n    /**\n     * Paint the placeholder for a cell, waiting for the renderer to be ready.\n     *\n     * @param gc - The graphics context to use for drawing.\n     *\n     * @param config - The configuration data for the cell.\n     */\n    paintPlaceholder(gc, config) {\n        this.drawBackground(gc, config);\n        this.drawPlaceholder(gc, config);\n    }\n    /**\n     * Paint the content for a cell.\n     *\n     * @param gc - The graphics context to use for drawing.\n     *\n     * @param config - The configuration data for the cell.\n     */\n    paint(gc, config) {\n        this.drawBackground(gc, config);\n        this.drawImage(gc, config);\n    }\n    /**\n     * Draw the background for the cell.\n     *\n     * @param gc - The graphics context to use for drawing.\n     *\n     * @param config - The configuration data for the cell.\n     */\n    drawBackground(gc, config) {\n        // Resolve the background color for the cell.\n        const color = CellRenderer.resolveOption(this.backgroundColor, config);\n        // Bail if there is no background color to draw.\n        if (!color) {\n            return;\n        }\n        // Fill the cell with the background color.\n        gc.fillStyle = color;\n        gc.fillRect(config.x, config.y, config.width, config.height);\n    }\n    /**\n     * Draw the placeholder for the cell.\n     *\n     * @param gc - The graphics context to use for drawing.\n     *\n     * @param config - The configuration data for the cell.\n     */\n    drawPlaceholder(gc, config) {\n        const placeholder = CellRenderer.resolveOption(this.placeholder, config);\n        const color = CellRenderer.resolveOption(this.textColor, config);\n        const textX = config.x + config.width / 2;\n        const textY = config.y + config.height / 2;\n        // Draw the placeholder.\n        gc.fillStyle = color;\n        gc.fillText(placeholder, textX, textY);\n    }\n    /**\n     * Draw the image for the cell.\n     *\n     * @param gc - The graphics context to use for drawing.\n     *\n     * @param config - The configuration data for the cell.\n     */\n    drawImage(gc, config) {\n        // Bail early if there is nothing to draw\n        if (!config.value) {\n            return;\n        }\n        const img = ImageRenderer.dataCache.get(config.value);\n        // If it's not loaded yet, show the placeholder\n        if (!img) {\n            return this.drawPlaceholder(gc, config);\n        }\n        const width = CellRenderer.resolveOption(this.width, config);\n        const height = CellRenderer.resolveOption(this.height, config);\n        // width and height are unset, we display the image with its original size\n        if (!width && !height) {\n            gc.drawImage(img, config.x, config.y);\n            return;\n        }\n        let requestedWidth = img.width;\n        let requestedHeight = img.height;\n        let widthPercentageMatch;\n        let widthPixelMatch;\n        let heightPercentageMatch;\n        let heightPixelMatch;\n        if ((widthPercentageMatch = width.match(PERCENTAGE_REGEX))) {\n            requestedWidth =\n                (parseFloat(widthPercentageMatch[1]) / 100) * config.width;\n        }\n        else if ((widthPixelMatch = width.match(PIXEL_REGEX))) {\n            requestedWidth = parseFloat(widthPixelMatch[1]);\n        }\n        if ((heightPercentageMatch = height.match(PERCENTAGE_REGEX))) {\n            requestedHeight =\n                (parseFloat(heightPercentageMatch[1]) / 100) * config.height;\n        }\n        else if ((heightPixelMatch = height.match(PIXEL_REGEX))) {\n            requestedHeight = parseFloat(heightPixelMatch[1]);\n        }\n        // If width is not set, we compute it respecting the image size ratio\n        if (!width) {\n            requestedWidth = (img.width / img.height) * requestedHeight;\n        }\n        // If height is not set, we compute it respecting the image size ratio\n        if (!height) {\n            requestedHeight = (img.height / img.width) * requestedWidth;\n        }\n        gc.drawImage(img, config.x, config.y, requestedWidth, requestedHeight);\n    }\n}\nImageRenderer.dataCache = new Map();\n\nexport { AsyncCellRenderer, BasicKeyHandler, BasicMouseHandler, BasicSelectionModel, BooleanCellEditor, CellEditor, CellEditorController, CellGroup, CellRenderer, DataGrid, DataModel, DateCellEditor, DynamicOptionCellEditor, GraphicsContext, HyperlinkRenderer, ImageRenderer, InputCellEditor, IntegerCellEditor, IntegerInputValidator, JSONModel, MutableDataModel, NumberCellEditor, NumberInputValidator, OptionCellEditor, PassInputValidator, RendererMap, SectionList, SelectionModel, TextCellEditor, TextInputValidator, TextRenderer, resolveOption };\n//# sourceMappingURL=index.es6.js.map\n"],"names":["BasicKeyHandler","constructor","this","_disposed","isDisposed","dispose","onKeyDown","grid","event","editable","selectionModel","cursorRow","cursorColumn","input","String","fromCharCode","keyCode","test","row","column","cell","editorController","edit","getKeyboardLayout","keyForKeydownEvent","stopPropagation","preventDefault","onArrowLeft","onArrowRight","onArrowUp","onArrowDown","onPageUp","onPageDown","onEscape","onDelete","onKeyC","moveCursor","shiftKey","scrollToCursor","model","shift","accel","Platform","accelKey","scrollTo","scrollY","scrollByStep","mode","selectionMode","r","c","cs","currentSelection","r1","r2","c1","c2","cr","cc","clear","select","scrollToColumn","maxScrollX","Infinity","scrollX","scrollToRow","maxScrollY","scrollByPage","n","Math","floor","pageHeight","defaultSizes","rowHeight","isEmpty","dataModel","maxRow","rowCount","maxColumn","columnCount","s","selections","sr1","max","min","sc1","sr2","sc2","setData","copyToClipboard","CellRenderer","resolveOption","option","config","TextRenderer","options","super","font","textColor","backgroundColor","verticalAlignment","horizontalAlignment","horizontalPadding","format","formatGeneric","elideDirection","wrapText","paint","gc","drawBackground","drawText","color","fillStyle","fillRect","x","y","width","height","getText","text","vAlign","hAlign","boxHeight","textHeight","measureFontHeight","textX","textY","boxWidth","beginPath","rect","clip","textAlign","textBaseline","fillText","textWidth","measureText","wordsInColumn","split","curY","textInCurrentLine","length","curLineTextWidth","i","curSubString","substring","curSubStringWidth","nextLineText","curWord","incrementedText","join","incrementedTextWidth","elide","textArr","slice","missing","value","undefined","formatFixed","digits","Number","toFixed","formatPrecision","toPrecision","formatExponential","toExponential","formatIntlNumber","nft","Intl","NumberFormat","locales","formatDate","Date","toDateString","formatTime","toTimeString","formatISODateTime","toISOString","formatUTCDateTime","toUTCString","formatIntlDateTime","dtf","DateTimeFormat","Private$6","fontHeightCache","fontMeasurementGC","normFont","fontMeasurementNode","style","document","body","appendChild","offsetHeight","removeChild","Private","Object","create","node","createElement","position","top","left","visibility","textContent","canvas","getContext","HyperlinkRenderer","url","urlName","CellGroup","areCellGroupsIntersectingAtAxis","group1","group2","axis","areCellGroupsIntersecting","getGroupIndex","rgn","numGroups","groupCount","group","getGroup","groupIndex","getCellGroupsAtRegion","groupsAtRegion","push","joinCellGroups","groups","startRow","MAX_VALUE","endRow","MIN_VALUE","startColumn","endColumn","joinCellGroupWithMergedCellGroups","region","joinedGroup","mergedCellGroups","g","mergedGroup","getCellGroupsAtRow","groupsAtRow","getCellGroupsAtColumn","groupsAtColumn","joinCellGroupsIntersectingAtAxis","regions","groupsAtAxis","concat","mergedGroupAtAxis","splice","BasicMouseHandler","_pressData","release","type","timeout","override","onMouseHover","hit","hitTest","clientX","clientY","handle","Private$5","resizeHandleForHitTest","cursor","cursorForHandle","createCellConfigObject","renderer","cellRenderers","get","viewport","onMouseLeave","onMouseDown","window","open","Drag","overrideCursor","localX","localY","index","size","columnSize","rowSize","selectionGroup","onMouseMove","data","dy","resizeRow","dx","resizeColumn","lx","ly","mapToLocal","hw","headerWidth","hh","headerHeight","vpw","viewportWidth","vph","viewportHeight","sx","sy","msx","msy","computeTimeout","setTimeout","autoselect","vx","vy","mapToVirtual","bodyWidth","bodyHeight","rowAt","columnAt","onMouseUp","onMouseDoubleClick","_a","_b","_c","colIndex","colRegion","cv","currentViewport","firstColumn","lastColumn","ci","onContextMenu","onWheel","deltaX","deltaY","deltaMode","ds","columnWidth","pageWidth","scrollBy","cursorMap","pressData","metadata","lw","lh","tw","th","result","scrollToCell","delta","abs","right","bottom","hyperlink","none","SelectionModel","_changed","Signal","_selectionMode","changed","connect","onDataModelChanged","isRowSelected","some","Private$4","containsRow","isColumnSelected","containsColumn","isCellSelected","containsCell","sender","args","emitChanged","emit","selection","BasicSelectionModel","arguments","_cursorRow","_cursorColumn","_cursorRectIndex","_selections","moveCursorWithinSelections","direction","firstSelection","cursorRect","dr","dc","newRow","newColumn","moveToNextRect","moveToPreviousRect","pop","alreadySelected","filter","lr","lc","j","AsyncCellRenderer","DEFAULT_INVALID_INPUT_MESSAGE","PassInputValidator","validate","valid","TextInputValidator","minLength","NaN","maxLength","pattern","message","isNaN","IntegerInputValidator","NumberInputValidator","CellEditor","inputChanged","validityNotification","_validInput","_gridWheelEventHandler","removeEventListener","_closeValidityNotification","viewportOccluder","onCommit","onCancel","validator","createValidatorBasedOnType","updatePosition","addEventListener","_addContainer","startEditing","cancel","validInput","getInput","error","console","log","setValidity","editorContainer","classList","remove","add","Notification","target","placement","show","RegExp","constraint","minimum","maximum","getCellInfo","columnX","rowY","cellGroup","columnOffset","rowOffset","cellInfo","commit","cursorMovement","className","pointerEvents","close","InputCellEditor","handleEvent","_onKeyDown","_onBlur","_onInput","_unbindEvents","createWidget","deserialize","focus","bindEvents","toString","spellcheck","inputType","TextCellEditor","NumberCellEditor","step","trim","floatValue","parseFloat","Error","IntegerCellEditor","intValue","parseInt","DateCellEditor","_createWidget","_input","_deserialize","_bindEvents","BooleanCellEditor","checked","OptionCellEditor","_isMultiSelect","_select","multiple","values","item","selected","indexOf","selectedOptions","editorContainerRect","getBoundingClientRect","maxHeight","Array","isArray","items","enum","bind","DynamicOptionCellEditor","listId","list","id","valueSet","Set","forEach","setAttribute","Widget","createNode","_message","addClass","setFlag","Flag","DisallowLayout","_target","_placement","attach","_evtMouseDown","update","messageNode","getElementsByClassName","onBeforeAttach","msg","onAfterDetach","onUpdateRequest","targetRect","alignItems","justifyContent","innerHTML","button","container","CellEditorController","_editor","_cell","_typeBasedOverrides","Map","_metadataBasedOverrides","setEditor","identifier","editor","set","key","_metadataIdentifierToKey","_onCommit","_onCancel","_getEditor","response","_getDataTypeKey","_objectToKey","object","str","_metadataMatchesIdentifier","hasOwnProperty","identifierValue","metadataValue","_getMetadataBasedEditor","editorMatched","dtKey","has","DataModel","emptyMetadata","MutableDataModel","freeze","GraphicsContext","context","_context","_state","Private$3","State","next","restore","strokeStyle","lineCap","lineDashOffset","lineJoin","lineWidth","miterLimit","shadowBlur","shadowColor","shadowOffsetX","shadowOffsetY","imageSmoothingEnabled","globalAlpha","globalCompositeOperation","getLineDash","setLineDash","segments","rotate","angle","scale","transform","m11","m12","m21","m22","translate","setTransform","save","closePath","isPointInPath","fillRule","arc","radius","startAngle","endAngle","anticlockwise","arcTo","x1","y1","x2","y2","bezierCurveTo","cp1x","cp1y","cp2x","cp2y","ellipse","radiusX","radiusY","rotation","lineTo","moveTo","quadraticCurveTo","cpx","cpy","w","h","fill","stroke","clearRect","maxWidth","strokeRect","strokeText","createLinearGradient","x0","y0","createRadialGradient","r0","createPattern","image","repetition","createImageData","apply","getImageData","sw","sh","putImageData","drawImage","drawFocusIfNeeded","element","pi","pool","state","other","RendererMap","fallback","_values","_fallback","err","SectionList","_count","_length","_sections","_minimumSize","minimumSize","_defaultSize","defaultSize","count","prev","curr","offset","clampSize","ArrayExt","lowerBound","Private$2","offsetCmp","section","span","offsetOf","indexCmp","extentOf","sizeOf","resize","insert","removed","k","move","destination","i1","k1","i2","k2","upperBound","pivot","count1","count2","span1","span2","k3","reset","DataGrid","_scrollX","_scrollY","_viewportWidth","_viewportHeight","_mousedown","_keyHandler","_mouseHandler","_vScrollBarMinWidth","_hScrollBarMinHeight","_dpiRatio","ceil","devicePixelRatio","_dataModel","_selectionModel","_editingEnabled","_style","defaultStyle","_stretchLastRow","stretchLastRow","_stretchLastColumn","stretchLastColumn","_headerVisibility","headerVisibility","_cellRenderers","_copyConfig","copyConfig","defaultCopyConfig","_onRenderersChanged","minimumSizes","_rowSections","_columnSections","_rowHeaderSections","rowHeaderWidth","_columnHeaderSections","columnHeaderHeight","_canvas","Private$1","createCanvas","_buffer","_overlay","_canvasGC","_bufferGC","_overlayGC","_viewport","tabIndex","outline","_vScrollBar","ScrollBar","orientation","_hScrollBar","_scrollCorner","_editorController","MessageLoop","installMessageHook","hide","thumbMoved","_onThumbMoved","pageRequested","_onPageRequested","stepRequested","_onStepRequested","GridLayout","setCellConfig","layout","rowSpacing","columnSpacing","fitPolicy","setRowStretch","setColumnStretch","addWidget","_releaseMouse","disconnect","_onDataModelChanged","_syncViewport","_onSelectionsChanged","repaintOverlay","keyHandler","mouseHandler","repaintContent","totalWidth","totalHeight","controller","editingEnabled","enabled","canvasGC","rowSections","columnSections","rowHeaderSections","columnHeaderSections","nr","vy1","vy2","nc","vx1","vx2","iter","onlyOne","currentSel","dir","rows","columns","postMessage","ScrollRequest","bh","ph","bw","pw","RowResizeRequest","ColumnResizeRequest","resetRows","resetColumns","fitColumnNames","area","padding","numCols","colsRemaining","rowColumnCount","_fitRowColumnHeaders","bodyColumnCount","_fitBodyColumnHeaders","ox","oy","from","alert","br","bc","rhc","chr","separator","headers","warningThreshold","colCount","cellCount","confirm","cells","lines","map","ClipboardExt","copyText","processMessage","vsbLimits","ElementExt","sizeLimits","hsbLimits","minWidth","minHeight","messageHook","handler","_processViewportMessage","activate","_evtKeyDown","_evtMouseMove","_evtMouseUp","_evtMouseDoubleClick","_evtMouseLeave","_evtContextMenu","_evtWheel","_refreshDPI","offsetWidth","round","contentW","contentH","contentX","contentY","firstRow","lastRow","onActivateRequest","preventScroll","onBeforeShow","onResize","_syncScrollState","PaintRequest","repaintRegion","OverlayPaintRequest","_getMaxWidthInColumn","columnRegion","columnHeaderRegion","_getMaxWidthInArea","rowRegion","numRows","configs","_val","idx","_getConfig","sort","_getTextToRender","_getCellTextWidth","col","location","_getCellValue","_getCellMetadata","_resizeCanvasIfNeeded","maxW","maxH","curW","curH","expW","expH","needBlit","hasVScroll","isHidden","hasHScroll","vsw","hsh","apw","aph","needVScroll","needHScroll","setHidden","sendMessage","Msg","FitRequest","page","_scrollTo","_onViewportResize","_onViewportScrollRequest","_onViewportPaintRequest","_onViewportOverlayPaintRequest","_onViewportRowResizeRequest","_onViewportColumnResizeRequest","isVisible","oldWidth","oldHeight","paintContent","_paintOverlay","bx","by","xMin","yMin","xMax","yMax","rs","rhs","chs","_resizeRow","_resizeColumnHeader","_resizeColumn","_resizeRowHeader","_onRowsInserted","_onColumnsInserted","_onRowsRemoved","_onColumnsRemoved","_onRowsMoved","_onColumnsMoved","_onCellsChanged","_onModelReset","rowSpan","columnSpan","nrh","nch","drh","dch","dpiRatio","oldSize","newSize","vw","vh","pos","_blitContent","cellGroups","paintRgn","headerBackgroundColor","_paintMergedCells","adjustedSize","contentWidth","contentHeight","dxArea","dyArea","cellgroups","source","rx","ry","rw","rh","_drawVoidRegion","_drawBodyRegion","_drawRowHeaderRegion","_drawColumnHeaderRegion","drawCornerHeaderRegion","_drawBodySelections","_drawRowHeaderSelections","_drawColumnHeaderSelections","_drawCursor","_drawShadows","voidColor","rowSizes","columnSizes","dh","dw","_drawBackground","_drawRowBackground","rowBackgroundColor","_drawColumnBackground","columnBackgroundColor","_drawCells","_drawHorizontalGridLines","horizontalGridLineColor","gridLineColor","_drawVerticalGridLines","verticalGridLineColor","cellGroupInteresectsRegion","headerHorizontalGridLineColor","headerGridLineColor","headerVerticalGridLineColor","colorFn","_getColumnSize","_getRowSize","isReady","paintPlaceholder","load","then","rgnR1","rgnR2","rgnC1","rgnC2","dm","selectionFillColor","selectionBorderColor","tmp","headerSelectionFillColor","headerSelectionBorderColor","maxCol","cursorFillColor","cursorBorderColor","shadow","scrollShadow","sxMax","syMax","grad","addColorStop","color1","color2","color3","copyFormatGeneric","ConflatableMessage","regionHasMergedCells","regionGroups","_region","_r1","_c1","_r2","_c2","conflate","_index","_size","JSONModel","splitFields","schema","_data","_bodyFields","bodyFields","_headerFields","headerFields","_missingValues","createMissingMap","field","name","title","primaryKeys","primaryKey","fields","missingValues","PERCENTAGE_REGEX","PIXEL_REGEX","ImageRenderer","placeholder","dataCache","loadedPromise","PromiseDelegate","img","Image","onload","resolve","src","promise","drawPlaceholder","requestedWidth","requestedHeight","widthPercentageMatch","widthPixelMatch","heightPercentageMatch","heightPixelMatch","match"],"sourceRoot":""}